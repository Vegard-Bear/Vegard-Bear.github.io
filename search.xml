<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【leetcode-226】翻转二叉树</title>
      <link href="/2020/12/02/leetcode-226/"/>
      <url>/2020/12/02/leetcode-226/</url>
      
        <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/invert-binary-tree/" target="_blank" rel="noopener">226. 翻转二叉树</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>翻转一棵二叉树。</p><p>示例：</p><p>输入：</p><pre class="line-numbers language-go"><code class="language-go">     <span class="token number">4</span>   <span class="token operator">/</span>   \  <span class="token number">2</span>     <span class="token number">7</span> <span class="token operator">/</span> \   <span class="token operator">/</span> \<span class="token number">1</span>   <span class="token number">3</span> <span class="token number">6</span>   <span class="token number">9</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出：</p><pre class="line-numbers language-go"><code class="language-go">     <span class="token number">4</span>   <span class="token operator">/</span>   \  <span class="token number">7</span>     <span class="token number">2</span> <span class="token operator">/</span> \   <span class="token operator">/</span> \<span class="token number">9</span>   <span class="token number">6</span> <span class="token number">3</span>   <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">/** * Definition for a binary tree node. * type TreeNode struct { *     Val int *     Left *TreeNode *     Right *TreeNode * } */</span><span class="token keyword">func</span> <span class="token function">invertTree</span><span class="token punctuation">(</span>root <span class="token operator">*</span>TreeNode<span class="token punctuation">)</span> <span class="token operator">*</span>TreeNode <span class="token punctuation">{</span>    <span class="token keyword">if</span> root <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">nil</span>    <span class="token punctuation">}</span>    temp <span class="token operator">:=</span> root<span class="token punctuation">.</span>Left    root<span class="token punctuation">.</span>Left <span class="token operator">=</span> root<span class="token punctuation">.</span>Right    root<span class="token punctuation">.</span>Right <span class="token operator">=</span> temp    <span class="token function">invertTree</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>Left<span class="token punctuation">)</span>    <span class="token function">invertTree</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>Right<span class="token punctuation">)</span>    <span class="token keyword">return</span> root<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fabric 链上数据防篡改</title>
      <link href="/2020/08/15/tamper-with-data/"/>
      <url>/2020/08/15/tamper-with-data/</url>
      
        <content type="html"><![CDATA[<blockquote><p>近日，因为工作需要，对 fabric 数据防篡改机制进行了研究，这里提供了一种验证链上数据防篡改的场景以供参考</p></blockquote><h1 id="基本思路："><a href="#基本思路：" class="headerlink" title="基本思路："></a>基本思路：</h1><p>进入某个peer节点修改本地的 Couch DB 数据，修改完后再调用链码发送一笔交易，发现执行结果是该 peer 节点的数据重新变为修改前的数据，说明篡改数据失败，系统具有放篡改能力。</p><p>具体操作如下，为了简化操作，直接借助官方使用 couchdb 样例，链码为 mymarble</p><p>先进入 firstnetwork 目录，执行以下命令起一个使用 couchdb 的byfn网络</p><pre><code>./byfn.sh up -c mychannel -s couchdb</code></pre><p>然后进入客户端</p><pre><code>docker exec -it cli bashexport CHANNEL_NAME=mychannel</code></pre><p>执行以下命令</p><pre><code># peer0.org1 安装链码CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/mspCORE_PEER_ADDRESS=peer0.org1.example.com:7051CORE_PEER_LOCALMSPID=&quot;Org1MSP&quot;CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crtpeer chaincode install -n  mymarble  -v 1.0.0  -p github.com/chaincode/marbles02/go# peer1.org1 安装链码CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/mspCORE_PEER_ADDRESS=peer1.org1.example.com:8051CORE_PEER_LOCALMSPID=&quot;Org1MSP&quot;CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer1.org1.example.com/tls/ca.crtpeer chaincode install -n  mymarble  -v 1.0.0  -p github.com/chaincode/marbles02/go# peer0.org2 安装链码CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/mspCORE_PEER_ADDRESS=peer0.org2.example.com:9051CORE_PEER_LOCALMSPID=&quot;Org2MSP&quot;CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crtpeer chaincode install -n  mymarble  -v 1.0.0  -p github.com/chaincode/marbles02/go# peer1.org2 安装链码CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/mspCORE_PEER_ADDRESS=peer1.org2.example.com:10051CORE_PEER_LOCALMSPID=&quot;Org2MSP&quot;CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer1.org2.example.com/tls/ca.crtpeer chaincode install -n  mymarble  -v 1.0.0  -p github.com/chaincode/marbles02/go# 实例化链链码peer chaincode instantiate -o orderer.example.com:7050 --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C mychannel -n mymarble -v 1.0.0 -c &#39;{&quot;Args&quot;:[&quot;init&quot;]}&#39; -P &quot;AND (&#39;Org1MSP.peer&#39;,&#39;Org2MSP.peer&#39;)&quot;peer chaincode invoke -o orderer.example.com:7050 --tls true --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C $CHANNEL_NAME -n mymarble --peerAddresses peer0.org1.example.com:7051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt --peerAddresses peer0.org2.example.com:9051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt -c &#39;{&quot;Args&quot;:[&quot;initMarble&quot;,&quot;marble1&quot;,&quot;blue&quot;,&quot;35&quot;,&quot;tom&quot;]}&#39;</code></pre><p>此时打开浏览器 <a href="http://localhost:5984/_utils/" target="_blank" rel="noopener">http://localhost:5984/_utils/</a></p><p>进入 peer0.org1 （对外暴露端口为5984）的 couchdb，查看 marble1 变量：</p><pre><code>{  &quot;_id&quot;: &quot;marble1&quot;,  &quot;_rev&quot;: &quot;1-1d12a3e8f79f5c0e40cc73c43701a6ba&quot;,  &quot;color&quot;: &quot;blue&quot;,  &quot;docType&quot;: &quot;marble&quot;,  &quot;name&quot;: &quot;marble1&quot;,  &quot;owner&quot;: &quot;tom&quot;,  &quot;size&quot;: 35,  &quot;~version&quot;: &quot;\u0000CgMBBgA=&quot;}</code></pre><p>我们可以看到在 couchdb 中保存了 marble1 的各个字段的属性。</p><p>然后手动将其中的 35 改为25，并保存（试图通过修改peer本地的couchdb中的数据实现篡改数据的操作）。</p><p>此时在终端调用以下链码，即将 marble1 给 jerry</p><pre><code>peer chaincode invoke -o orderer.example.com:7050 --tls true --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C $CHANNEL_NAME -n mymarble --peerAddresses peer0.org1.example.com:7051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt --peerAddresses peer0.org2.example.com:9051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt -c &#39;{&quot;Args&quot;:[&quot;transferMarble&quot;,&quot;marble1&quot;,&quot;jerry&quot;]}&#39;</code></pre><h5 id="注意此时指定的背书节点为-peer0-org1-和-peer0-org2"><a href="#注意此时指定的背书节点为-peer0-org1-和-peer0-org2" class="headerlink" title="注意此时指定的背书节点为 peer0.org1 和 peer0.org2"></a>注意此时指定的背书节点为 peer0.org1 和 peer0.org2</h5><p><img src="https://note.youdao.com/yws/public/resource/bc554143fcca768f52bf1354ffef92eb/xmlnote/619D267654E5418CA1199D1E0060BEA7/3390" alt></p><p>发现调用失败，返回背书不满足<br>这主要是因为 peer0.org1 的 couchdb 的数据已经改变，和 peer0.org1 的数据不同，导致模拟执行失败</p><p>此时，将其中一个背书节点背书节点 peer0.org1 替换成 peer1.org1，此时再次调用链码</p><pre><code>peer chaincode invoke -o orderer.example.com:7050 --tls true --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C $CHANNEL_NAME -n mymarble --peerAddresses peer1.org1.example.com:8051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer1.org1.example.com/tls/ca.crt --peerAddresses peer0.org2.example.com:9051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt -c &#39;{&quot;Args&quot;:[&quot;transferMarble&quot;,&quot;marble1&quot;,&quot;jerry&quot;]}&#39;</code></pre><p>链码调用成功</p><p>再次进入peer0.org1的couchdb，对外暴露端口为5984</p><p><a href="http://localhost:5984/_utils/" target="_blank" rel="noopener">http://localhost:5984/_utils/</a></p><p>发现此时 marble1  的owner 已经变为jerry，并且仍然是35</p><pre><code>{  &quot;_id&quot;: &quot;marble1&quot;,  &quot;_rev&quot;: &quot;3-c2280ec7b75f7f5536b490acf10515a0&quot;,  &quot;color&quot;: &quot;blue&quot;,  &quot;docType&quot;: &quot;marble&quot;,  &quot;name&quot;: &quot;marble1&quot;,  &quot;owner&quot;: &quot;jerry&quot;,  &quot;size&quot;: 35,  &quot;~version&quot;: &quot;\u0000CgMBBwA=&quot;}</code></pre><p>说明试图篡改数据的操作失败，系统具有防篡改能力</p>]]></content>
      
      
      
        <tags>
            
            <tag> fabric </tag>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fabric 2.2 生命周期链码实战</title>
      <link href="/2020/08/08/fabric-chaincode-2-2/"/>
      <url>/2020/08/08/fabric-chaincode-2-2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>fabric 2.2和1.4的一个重要不同就是进一步完善了对链码的生命周期管理</p></blockquote><h1 id="打包（package）"><a href="#打包（package）" class="headerlink" title="打包（package）"></a>打包（package）</h1><p>必须先打包链码，然后才能将其安装在peer节点上。可以使用 peer lifecycle chaincode package 命令打包Go链码。</p><ul><li><p>使用 –path 标志指示链码的位置。该路径必须是标准路径或相对于您当前工作目录的路径。</p></li><li><p>使用 –label 标志指定 stupid 作为组织用于标识的被打包的链码的标签。</p></li></ul><pre><code>peer lifecycle chaincode package stupid.tar.gz --path github.com/chaincode/stupid --lang golang --label stupid</code></pre><h1 id="安装（install）"><a href="#安装（install）" class="headerlink" title="安装（install）"></a>安装（install）</h1><p>打包链码后，可以使用 peer chaincode install 命令在 peer 节点上安装链码。</p><ul><li>将stupid.tar.gz软件包安装在 peer0.org1.example.com 上。</li></ul><pre><code>peer lifecycle chaincode install stupid.tar.gz2020-08-07 03:29:49.473 UTC [cli.lifecycle.chaincode] submitInstallProposal -&gt; INFO 001 Installed remotely: response:&lt;status:200 payload:&quot;\nGstupid:27a22f86b653f2fd487a41af58404de8cdac47b4c09dddecc16fef2f7f60e2c2\022\006stupid&quot; &gt;2020-08-07 03:29:49.477 UTC [cli.lifecycle.chaincode] submitInstallProposal -&gt; INFO 002 Chaincode code package identifier: stupid:27a22f86b653f2fd487a41af58404de8cdac47b4c09dddecc16fef2f7f60e2c2</code></pre><ul><li>切换为 peer1.org1，并安装链码</li></ul><pre><code>export CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/mspexport CORE_PEER_ADDRESS=peer1.org1.example.com:8051export CORE_PEER_LOCALMSPID=&quot;Org1MSP&quot;export CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer1.org1.example.com/tls/ca.crtpeer lifecycle chaincode install stupid.tar.gz</code></pre><ul><li>切换为 peer0.org2，并安装链码</li></ul><pre><code>export CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/mspexport CORE_PEER_ADDRESS=peer0.org2.example.com:9051export CORE_PEER_LOCALMSPID=&quot;Org2MSP&quot;export CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crtpeer lifecycle chaincode install stupid.tar.gz</code></pre><ul><li>切换为 peer1.org2，并安装链码</li></ul><pre><code>export CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/mspexport CORE_PEER_ADDRESS=peer1.org2.example.com:10051export CORE_PEER_LOCALMSPID=&quot;Org2MSP&quot;export CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer1.org2.example.com/tls/ca.crtpeer lifecycle chaincode install stupid.tar.gz</code></pre><ul><li>检查是否安装成功</li></ul><pre><code>export CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/mspexport CORE_PEER_ADDRESS=peer1.org1.example.com:8051export CORE_PEER_LOCALMSPID=&quot;Org1MSP&quot;export CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer1.org1.example.com/tls/ca.crtpeer lifecycle chaincode queryinstalled --peerAddresses peer0.org1.example.com:7051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crtInstalled chaincodes on peer:Package ID: stupid:27a22f86b653f2fd487a41af58404de8cdac47b4c09dddecc16fef2f7f60e2c2, Label: stupid</code></pre><p>安装链码成功后会返回一个标识符，这个标识符与在下一步会用到。<br>链码标签和哈希值构成了标识符。</p><h1 id="批准（approve）"><a href="#批准（approve）" class="headerlink" title="批准（approve）"></a>批准（approve）</h1><p>在peer节点上安装了chaincode程序包后，可以批准组织的链码定义。链码定义包括链码管理的重要参数，包括链码名称，版本和认可策略等。</p><p>这是命令的示例，该命令批准在channel 版本上命名的链码的定义。</p><ul><li>使用 –package-id 标志传递链码包标识符。</li><li>使用 –signature-policy标志定义链码的背书策略。</li><li>使用 –init-required标志请求执行 Init 函数初始化链码。</li></ul><p>需要注意的是，每个组织都需要进行一次approveformyorg操作，具体需要由组织内的任意一个具有管理员权限的节点来进行即可：</p><p>切换 peer0.org1.example.com，进行approveformyorg 操作，批准链码定义：</p><pre><code>export CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/mspexport CORE_PEER_ADDRESS=peer0.org1.example.com:7051export CORE_PEER_LOCALMSPID=&quot;Org1MSP&quot;export CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crtpeer lifecycle chaincode approveformyorg  -o orderer.example.com:7050 --tls true --cafile $ORDERER_CA --channelID mychannel --name stupid --version 1.0 --init-required --package-id stupid:27a22f86b653f2fd487a41af58404de8cdac47b4c09dddecc16fef2f7f60e2c2 --sequence 1 --signature-policy &quot;AND (&#39;Org1MSP.peer&#39;,&#39;Org2MSP.peer&#39;)&quot; --waitForEvent</code></pre><p>结果输出以下内容：</p><pre><code>2020-08-07 03:47:33.708 UTC [chaincodeCmd] ClientWait -&gt; INFO 001 txid [5f92b2c3b14ddc80829c9c89bc602069a3fd868ec358c4d5d329ccb8dee0b530] committed with status (VALID) at</code></pre><p>然后我们再切换到 peer0.org2.example.com 进行一次 approveformyorg 操作</p><p>切换 peer0.org2.example.com，并批准链码定义</p><pre><code>export CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/mspexport CORE_PEER_ADDRESS=peer0.org2.example.com:9051export CORE_PEER_LOCALMSPID=&quot;Org2MSP&quot;export CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crtexport ORDERER_CA=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pempeer lifecycle chaincode approveformyorg  -o orderer.example.com:7050 --tls --cafile $ORDERER_CA --channelID mychannel --name stupid --version 1.0 --init-required --package-id stupid:27a22f86b653f2fd487a41af58404de8cdac47b4c09dddecc16fef2f7f60e2c2 --sequence 1 --signature-policy &quot;AND (&#39;Org1MSP.peer&#39;,&#39;Org2MSP.peer&#39;)&quot; --waitForEvent</code></pre><ul><li><p>检查是否批准成功</p><pre><code>peer lifecycle chaincode checkcommitreadiness -o orderer.example.com:7050 --channelID mychannel --tls --cafile $ORDERER_CA --name stupid --version 1.0 --init-required --sequence 1 --output json</code></pre></li><li><p>输出结果如下：</p><pre><code>{  &quot;approvals&quot;: {      &quot;Org1MSP&quot;: false,      &quot;Org2MSP&quot;: false  }}</code></pre></li></ul><p>这里显示都是 false，说明批准并未成功，此时可以再尝试进行一次approformyorg 操作，结果如下：</p><pre><code>Error: proposal failed with status: 500 - failed to invoke backing implementation of &#39;ApproveChaincodeDefinitionForMyOrg&#39;: attempted to redefine uncommitted sequence (1) for namespace stupid with unchanged content</code></pre><p>出现这种情况说明存在当前最新的合约没有commit，无法进行新的approve，换句话说就是对同一个链码在同一家组织进行了两次approve操作，而这是不被允许的，说明之前的 approve 操作是成功的，这就与“批准并未成功”的结论矛盾了，到底有没有成功呢？</p><p>请注意，这里是一个比较坑的地方，因为这可能是一个bug，实际上已经approve成功了，但是checkcommitreadiness却显示为false，此时，我们可以先往下走，直接进入commit阶段，如果没问题的话，就接着往下走。</p><p>目前尚不清楚这个是我操作的原因还是fabric 2.x 的一个bug，因为网上有其他人也跟我遇到了同样的问题。</p><h1 id="提交（commit）"><a href="#提交（commit）" class="headerlink" title="提交（commit）"></a>提交（commit）</h1><p>一旦足够多的组织批准了其组织的链代码定义（默认情况下为大多数），则一个组织可以使用 peer lifecycle chaincode commit 命令将该定义提交给渠道。</p><p>该命令需要针对通道上其他组织的peer节点，以收集其组织对定义的认可。</p><pre><code>export ORDERER_CA=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pempeer lifecycle chaincode commit -o orderer.example.com:7050 --channelID mychannel --name stupid --version 1.0 --sequence 1 --init-required --tls true --cafile $ORDERER_CA --peerAddresses peer0.org1.example.com:7051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt --peerAddresses peer0.org2.example.com:9051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt --signature-policy &quot;AND (&#39;Org1MSP.peer&#39;,&#39;Org2MSP.peer&#39;)&quot;</code></pre><p>此处是不是可以不指定 peerAddresses，还有待验证…</p><p>输出结果如下：</p><pre><code>2020-08-08 08:56:13.430 UTC [chaincodeCmd] ClientWait -&gt; INFO 001 txid [837c1b5e18ca5e8e2f2a0ec9f98bbdfcf74585e8c2c2e77047e3d11b44ad9344] committed with status (VALID) at peer0.org1.example.com:70512020-08-08 08:56:13.782 UTC [chaincodeCmd] ClientWait -&gt; INFO 002 txid [837c1b5e18ca5e8e2f2a0ec9f98bbdfcf74585e8c2c2e77047e3d11b44ad9344] committed with status (VALID) at peer0.org2.example.com:9051</code></pre><p>查询是否提交成功：</p><pre><code>peer lifecycle chaincode querycommitted -o orderer.example.com:7050 --channelID mychannel --name stupid --tls --cafile $ORDERER_CA</code></pre><p>结果如下，说明提交成功。</p><pre><code>Committed chaincode definition for chaincode &#39;stupid&#39; on channel &#39;mychannel&#39;:Version: 1.0, Sequence: 1, Endorsement Plugin: escc, Validation Plugin: vscc, Approvals: [Org1MSP: true, Org2MSP: true]</code></pre><p>也可以只指定通道名称，不指定链码名称，那样查询的就是该通道上所有链码的定义。</p><p> 注意commit需要指定签名背书策略，并且需要和链码 approveformyorg 阶段的背书策略一致。</p><pre><code> --signature-policy &quot;AND (&#39;Org1MSP.peer&#39;,&#39;Org2MSP.peer&#39;)&quot;</code></pre><p> 如果少了这个会报如下错误：</p><pre><code> Error: proposal failed with status: 500 - failed to invoke backing implementation of &#39;CommitChaincodeDefinition&#39;: chaincode definition not agreed to by this org (Org1MSP)</code></pre><p>查询链码和调用链码与 1.4 版本相同。</p><h1 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h1><pre><code>peer chaincode invoke -o orderer.example.com:7050 --tls true --cafile $ORDERER_CA -C mychannel -n stupid  -c &#39;{&quot;Args&quot;:[&quot;put&quot;,&quot;a&quot;,&quot;10&quot;]}&#39;</code></pre><p>结果如下：</p><pre><code>Error: endorsement failure during invoke. response: status:500 message:&quot;error in simulation: failed to execute transaction a1465e679dcd1559a7077ec13c45c4db72f8bd73b6aaa4af9fc1127797e96bb1: invalid invocation: chaincode &#39;stupid&#39; has not been initialized for this version, must call as init first&quot;</code></pre><p>说明这里需要执行的第一个函数是init，然后才能执行其他调用链码的操作，这里我们试图执行以下操作进行init：</p><pre><code>peer chaincode instantiate -o orderer.example.com:7050 --tls true --cafile $ORDERER_CA -C mychannel -n stupid -v 1.0 -c &#39;{&quot;Args&quot;:[&quot;init&quot;]}&#39;</code></pre><p>结果如下：</p><pre><code>2020-08-08 09:42:42.029 UTC [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 001 Using default escc2020-08-08 09:42:42.031 UTC [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 002 Using default vsccError: could not assemble transaction, err proposal response was not successful, error code 500, msg Channel &#39;mychannel&#39; has been migrated to the new lifecycle, LSCC is now read-only</code></pre><p>失败了，当前通道已经迁移到 lifecycle 了， 不能执行实例化操作。</p><p>此处需要增加 –isInit 参数，表面此处是初始化链码：</p><pre><code>peer chaincode invoke --isInit -o orderer.example.com:7050 --tls true --cafile $ORDERER_CA -C mychannel -n stupid  -c &#39;{&quot;Args&quot;:[&quot;put&quot;,&quot;a&quot;,&quot;10&quot;]}&#39;</code></pre><p>调用成功：</p><pre><code>2020-08-08 09:58:20.911 UTC [chaincodeCmd] chaincodeInvokeOrQuery -&gt; INFO 001 Chaincode invoke successful. result: status:200</code></pre><h1 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h1><pre><code>peer chaincode invoke -o orderer.example.com:7050 --tls ture --cafile $ORDERER_CA -C mychannel -n stupid  -c &#39;{&quot;Args&quot;:[&quot;get&quot;,&quot;a&quot;]}&#39;</code></pre><p>结果如下：</p><pre><code>2020-08-08 10:00:22.583 UTC [chaincodeCmd] chaincodeInvokeOrQuery -&gt; INFO 001 Chaincode invoke successful. result: status:200</code></pre><h1 id="踩坑指南"><a href="#踩坑指南" class="headerlink" title="踩坑指南"></a>踩坑指南</h1><p>在打包链码的时候遇到问题</p><pre><code>Error: error getting chaincode deployment spec for stupid: error getting chaincode package bytes: failed to calculate dependencies: incomplete package: github.com/hyperledger/fabric/core/chaincode/shim</code></pre><p>解决办法参考<br><a href="https://www.bcskill.com/index.php/archives/925.html" target="_blank" rel="noopener">https://www.bcskill.com/index.php/archives/925.html</a></p><ol><li><p>先下载依赖</p><pre><code> git clone github.com/hyperledger/fabric-chaincode-go/shim git clone github.com/hyperledger/fabric-protos-go/peer</code></pre></li><li><p>修改import包，将</p><pre><code> &quot;github.com/hyperledger/fabric/core/chaincode/shim&quot; pb &quot;github.com/hyperledger/fabric/protos/peer&quot;</code></pre><p> 改成</p><pre><code> &quot;github.com/hyperledger/fabric-chaincode-go/shim&quot; pb &quot;github.com/hyperledger/fabric-protos-go/peer&quot;</code></pre></li><li><p>并在链码文件的同级目录新建go.mod</p></li><li><p>更新依赖</p><pre><code> go mod vendor</code></pre></li><li><p>重启节点，执行打包链码的命令</p></li></ol><p>参考资料</p><p><a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/commands/peerlifecycle.html#example-usage" target="_blank" rel="noopener">Example Usage</a></p><p><a href="https://juejin.im/post/6844904070390480910" target="_blank" rel="noopener">Fabric2.0智能合约实践-设置背书策略</a></p><p><a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/chaincode_lifecycle.html#fabric-chaincode-lifecycle" target="_blank" rel="noopener">Fabric chaincode lifecycle</a></p>]]></content>
      
      
      <categories>
          
          <category> fabric </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fabric </tag>
            
            <tag> chaincode </tag>
            
            <tag> 2.2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fabric 2.2 的新特性</title>
      <link href="/2020/08/08/fabric-newfeature-2-2/"/>
      <url>/2020/08/08/fabric-newfeature-2-2/</url>
      
        <content type="html"><![CDATA[<h1 id="2-2-的新特性"><a href="#2-2-的新特性" class="headerlink" title="2.2 的新特性"></a>2.2 的新特性</h1><h2 id="1-分权的chaincode⽣命周期的管理"><a href="#1-分权的chaincode⽣命周期的管理" class="headerlink" title="1. 分权的chaincode⽣命周期的管理"></a>1. 分权的chaincode⽣命周期的管理</h2><p>详⻅ 2.0 beta版的chaincode⽣命周期管理</p><ul><li>多数组织需要同意chaincode的相关参数，⽐⽅说policy等。 </li><li>更慎重的chaincode升级过程（需要组织重新同意chaincode的相关参数）。 </li><li>更简便地升级policy或者私密数据配置（不⽤重新安装合约，可以直接从让多家组织同意新的参数开始，也就是升级参数的 话，chaincode的version可以不变） </li><li>可检查的chaincode包（需要先打包chaincode，再安装） </li><li>不同成员的同⼀个chaincode的源码可以不同（可以使⽤不同的语⾔编写，或者同⼀语⾔逻辑不同） </li></ul><h2 id="2-新的chaincode部署形式"><a href="#2-新的chaincode部署形式" class="headerlink" title="2. 新的chaincode部署形式"></a>2. 新的chaincode部署形式</h2><ul><li>删除对docker daemon的依赖。</li><li>增加了除了docker容器外的其他运⾏chaincode的选择。</li><li>提供了外部创建chaincode的接⼝，可以⾃⼰实现其他的chaincode的创建和部署过程。 </li><li>chaincode可以作为⼀个外部服务</li></ul><h2 id="3-私密数据的增强"><a href="#3-私密数据的增强" class="headerlink" title="3. 私密数据的增强"></a>3. 私密数据的增强</h2><p>详⻅2.0beta版私密数据新特性</p><ul><li>分享和验证私密数据。拥有私密数据的⼀⽅可以将私密数据分享给没有权限的⼀⽅，接收⽅可以通过调⽤GetPrivateDataHash<br>来验证私密数据的正确性。</li><li>新增collection级别的背书策略。</li><li>隐形的组织级别的collection。如果是单组织使⽤的私密数据，collection可以不⽤显性地去定义就可以直接使⽤。</li></ul><h2 id="4-CouchDB增加缓存来提升性能"><a href="#4-CouchDB增加缓存来提升性能" class="headerlink" title="4. CouchDB增加缓存来提升性能"></a>4. CouchDB增加缓存来提升性能</h2><h2 id="5-更轻量级的docker镜像"><a href="#5-更轻量级的docker镜像" class="headerlink" title="5. 更轻量级的docker镜像"></a>5. 更轻量级的docker镜像</h2><p>改⽤Apline Linux作为底层的操作系统。镜像⼤⼩变⼩了。</p><h2 id="其他变化"><a href="#其他变化" class="headerlink" title="其他变化"></a>其他变化</h2><ul><li>ccenv镜像不再包含shim</li><li>logger从chaincode shim中移除，chaincode的log⼯作交给chaincode开发者⾃⼰处理 </li><li>不再⽀持⽤户的chaincode调⽤系统chaincode </li><li>GetHistoryForKey排序⽅式更改为从新到旧 </li><li>对于orderer来说，之前⽀持的provisional启动⽅式被移除 </li><li>orderer配置的genesismethod和genesisfile改为bootstrapmethod和bootstrapfile</li><li>系统chaincode插件被移除，不可以通过go插件来添加系统chaincode了</li><li>新镜像⾥不⽀持bash</li><li>go版本升级到了1.13.4<font color="green"></font></li><li>添加了背书失败的背书节点的 metrics</li><li>可以在 core.yaml 中通过配置项对背书节点的并发请求数作出限制</li><li>可以在 core.yaml 中通过配置项覆盖私有数据集合分发策略</li><li>服务发现支持在链码私有数据集合级别指定背书策略</li><li>Discover CLI现在支持SEC 1格式的私钥</li><li>依赖更新<ul><li>docker镜像更新到 3.11</li><li>go 版本更新到 1.14.1</li><li>go grpc 更新到 1.28.0</li></ul></li><li>添加对 TLS 1.3 的支持</li><li>添加查询已批准的链码定义的详细信息的功能</li></ul><p><strong>注：标记为绿色的部分为 2.1.0 和 2.2.0 新增的特性，2.0.1 和 2.1.1 版本都是一些 bugfix，没有新的特性。</strong></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/whatsnew.html" target="_blank" rel="noopener">What’s new in Hyperledger Fabric v2.x</a></p>]]></content>
      
      
      <categories>
          
          <category> fabric </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fabric </tag>
            
            <tag> 2.2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fabric 1.4 升级到 2.2 的⽅案</title>
      <link href="/2020/08/08/fabric-upgrade-2-2/"/>
      <url>/2020/08/08/fabric-upgrade-2-2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>v2.2是Fabric v2.x的第一个长期支持（LTS）版本，Fabric的2.1和2.2版本是稳定版本，具有错误修复和其他形式的代码强化功能。从2.0升级到2.2不需要特别的考虑，也不需要特定的镜像版本或通道配置更新。</p></blockquote><h1 id="1-4-升级到-2-2-的主要过程包括（与升级到-2-0-基本一致）"><a href="#1-4-升级到-2-2-的主要过程包括（与升级到-2-0-基本一致）" class="headerlink" title="1.4 升级到 2.2 的主要过程包括（与升级到 2.0 基本一致）"></a>1.4 升级到 2.2 的主要过程包括（与升级到 2.0 基本一致）</h1><ol><li>升级镜像</li><li>升级兼容性配置</li><li>激活 chaincode 的新的⽣命周期管理 </li></ol><h1 id="1-升级镜像"><a href="#1-升级镜像" class="headerlink" title="1. 升级镜像"></a>1. 升级镜像</h1><p>升级镜像主要包括两个步骤： </p><ul><li>备份账本和 MSP 的相关⽂件</li><li>升级镜像⽂件到最新版本 </li></ul><h2 id="1-1-升级-orderer-节点"><a href="#1-1-升级-orderer-节点" class="headerlink" title="1.1 升级 orderer 节点"></a>1.1 升级 orderer 节点</h2><p>对每个 orderer 节点执行以下操作：</p><ol><li>停掉 orderer 节点 </li><li>备份 orderer 节点的账本和 MSP </li><li>移除掉 orderer 节点容器 </li><li>使⽤新镜像创建⼀个 orderer 容器</li></ol><h2 id="1-2-升级-peer-节点"><a href="#1-2-升级-peer-节点" class="headerlink" title="1.2 升级 peer 节点"></a>1.2 升级 peer 节点</h2><ol><li><p>停掉 peer 节点 </p></li><li><p>备份 peer 节点的账本和 MSP </p></li><li><p>移除掉 chaincode 容器（由于 2.0 版本中将 shim 从 fabric ⼯程中移出为单独的⼯程，所以是否删除镜像需要进⾏讨论） </p><ul><li>如果该 chaincode 已经做好了升级准备，那么原来的镜像可以直接删除掉。 </li><li>如果 chaincode 不打算升级，当环境从 1.4 升级到 2.0 后还需要继续使⽤。  <ul><li>不删除chaincode 镜像，那么当升级到2.0后会继续使⽤该镜像创建容器，原 chaincode 可以正常运⾏。</li><li>删除掉了 chaincode 镜像，那么需要对 peer 节点进⾏配置，让其使⽤ ccenv 1.4 版本的镜像来创建chaincode镜像。如 果没有专⻔配置，使⽤了 2.0 版本的 ccenv 的话，会出现错误。（ 因为 2.0 版本 ccenv ⾥没有 shim ），在 base/peer-base.yaml 增加如下内容：<pre><code> - CORE_CHAINCODE_BUILDER=hyperledger/fabric-ccenv:1.4.6</code></pre></li></ul></li></ul></li><li><p>移除掉 peer 节点容器</p></li><li><p>升级 peer 节点的数据库 </p><ul><li>由于 2.0 版本的状态数据库和历史数据库的数据格式与 1.4 有所不同，升级到2.0版本需要对数据库进⾏升级。<pre><code>docker run --rm -v /var/lib/docker/volumes/net_peer0.org1.example.com/_data/:/var/hyperledger/production/ -v /home/centos/gopath/src/github.com/hyperledger/fabric-samples/first-network/crypto-config/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/msp/:/etc/hyperledger/fabric/msp/ --name peer0.org1.example.com hyperledger/fabric-peer:2.0 peer node upgrade-dbs </code></pre></li></ul></li><li><p>使⽤新的镜像创建⼀个 peer 容器</p></li></ol><h3 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h3><ul><li>可以先 ./byfn.sh 起一个 byfn，然后停掉所有 orderer 节点和 peer 节点</li></ul><pre><code>docker-compose -f docker-compose-cli.yaml down</code></pre><ul><li>修改配置文件 base/peer-base.yaml 和 docker-compose-cli.yaml 中的镜像tag</li></ul><pre><code>image: hyperledger/fabric-peer:2.2image: hyperledger/fabric-orderer:2.2image: hyperledger/fabric-tools:2.2</code></pre><ul><li>升级所有 peer 节点的数据库（不升级会报错）</li></ul><pre><code>docker run --rm -v /var/lib/docker/volumes/net_peer0.org1.example.com/_data/:/var/hyperledger/production/ -v /Users/xiongweigang/go/src/github.com/hyperledger/fabric-samples/first-network/crypto-config/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/msp/:/etc/hyperledger/fabric/msp/ --name peer0.org1.example.com hyperledger/fabric-peer:2.2 peer node upgrade-dbsdocker run --rm -v /var/lib/docker/volumes/net_peer1.org1.example.com/_data/:/var/hyperledger/production/ -v /Users/xiongweigang/go/src/github.com/hyperledger/fabric-samples/first-network/crypto-config/peerOrganizations/org1.example.com/peers/peer1.org1.example.com/msp/:/etc/hyperledger/fabric/msp/ --name peer1.org1.example.com hyperledger/fabric-peer:2.2 peer node upgrade-dbsdocker run --rm -v /var/lib/docker/volumes/net_peer0.org2.example.com/_data/:/var/hyperledger/production/ -v /Users/xiongweigang/go/src/github.com/hyperledger/fabric-samples/first-network/crypto-config/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/msp/:/etc/hyperledger/fabric/msp/ --name peer0.org2.example.com hyperledger/fabric-peer:2.2 peer node upgrade-dbsdocker run --rm -v /var/lib/docker/volumes/net_peer1.org2.example.com/_data/:/var/hyperledger/production/ -v /Users/xiongweigang/go/src/github.com/hyperledger/fabric-samples/first-network/crypto-config/peerOrganizations/org2.example.com/peers/peer1.org2.example.com/msp/:/etc/hyperledger/fabric/msp/ --name peer1.org2.example.com hyperledger/fabric-peer:2.2 peer node upgrade-dbs</code></pre><p>最后再重启节点</p><pre><code>docker-compose -f docker-compose-cli.yaml up -d</code></pre><h1 id="2-升级兼容性配置"><a href="#2-升级兼容性配置" class="headerlink" title="2. 升级兼容性配置"></a>2. 升级兼容性配置</h1><p>升级兼容性配置主要包括，升级系统链配置以及升级应⽤链配置两个⽅⾯。 </p><p>在升级过程中可以使⽤ jq 命令来对配置进⾏修改，也可以使⽤其他编辑器对⽂件直接进⾏⼿动的修改。为了⽅便 jq 命令的使 ⽤，⾸先创建⼀个名为capabilities.json的⽂件。⽂件包括以下内容:</p><pre><code>{     &quot;channel&quot;: {         &quot;mod_policy&quot;: &quot;Admins&quot;,             &quot;value&quot;: {                 &quot;capabilities&quot;: {                    &quot;V2_0&quot;: {}                  }            },         &quot;version&quot;: &quot;0&quot;     },    &quot;orderer&quot;: {         &quot;mod_policy&quot;: &quot;Admins&quot;,             &quot;value&quot;: {                 &quot;capabilities&quot;: {                     &quot;V2_0&quot;: {}                 }             },         &quot;version&quot;: &quot;0&quot;     },    &quot;application&quot;: {         &quot;mod_policy&quot;: &quot;Admins&quot;,             &quot;value&quot;: {                 &quot;capabilities&quot;: {                    &quot;V2_0&quot;: {}                 }             },         &quot;version&quot;: &quot;0&quot;     } } </code></pre><h3 id="具体操作-1"><a href="#具体操作-1" class="headerlink" title="具体操作"></a>具体操作</h3><p>进入 cli 容器</p><pre><code>docker exec -it cli bash </code></pre><p>进入 script 文件夹</p><pre><code>cd scripts</code></pre><p>将 capabilities.json 复制到 此文件夹中即 fabric-samples/firstnetwork/scripts 文件夹</p><h2 id="2-1-升级系统链的兼容性配置"><a href="#2-1-升级系统链的兼容性配置" class="headerlink" title="2.1 升级系统链的兼容性配置"></a>2.1 升级系统链的兼容性配置</h2><p>参考脚本updating_capabilities_sys.sh</p><ul><li>⾸先需要对⼀些环境变量进⾏设置<ul><li>CH_NAME :系统链的名称，例如⽬前的 fabric-samples/first-network中的 CH_NAME=byfn-sys-channel </li><li>CORE_PEER_LOCALMSPID :Orderer组织的MSPID，例如⽬前的 fabric-samples/first-network 中的 CORE_PEER_LOCALMSPID=OrdererMSP</li><li>TLS_ROOT_CA : Orderer组织的TLS的CA证书，例如⽬前的 fabric-samples/first-network 中的 TLS_ROOT_CA=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/ orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem </li><li>CORE_PEER_MSPCONFIGPATH :Orderer组织的MSP的配置地址，例如⽬前的fabric-samples/first-network 中的 CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/users/Admin@example.com/msp </li><li>ORDERER_CONTAINER :Orderer组织的容器节点，例如⽬前的fabric-samples/first-network中的 ORDERER_CONTAINER=orderer.example.com:7050</li></ul></li><li>获取系统链原有的配置 <ul><li>获取原有配置<pre><code>peer channel fetch config config_block.pb -o $ORDERER_CONTAINER -c $CH_NAME --tls --cafile $TLS_ROOT_CA</code></pre></li><li>将配置转化为json格式 <pre><code>configtxlator proto_decode --input config_block.pb --type common.Block --output config_block.json</code></pre></li><li>从json中只提取出来配置的部分<pre><code>jq .data.data[0].payload.data.config config_block.json &gt; config.json</code></pre></li></ul></li><li>修改兼容性配置<ul><li>可以使⽤ jq 命令对配置进⾏修改<pre><code>jq -s &#39;.[0] * {&quot;channel_group&quot;:{&quot;groups&quot;:{&quot;Orderer&quot;: {&quot;values&quot;: {&quot;Capabilities&quot;: .[1].orderer}}}}}&#39; config.json ./capabilities.json &gt; modified_config1.jsonjq -s &#39;.[0] * {&quot;channel_group&quot;:{&quot;values&quot;: {&quot;Capabilities&quot;: .[1].channel}}}&#39; modified_config1.json ./capabilities.json &gt; modified_config.json</code></pre></li><li>也可以打开编辑器，将Capabilities相关的配置改为”V2_0”</li></ul></li><li>计算配置的deltaSet，⽣成pb⽂件<ul><li>计算deltaSet<pre><code>configtxlator proto_encode --input config.json --type common.Config --output config.pbconfigtxlator proto_encode --input modified_config.json --type common.Config --output modified_config.pb configtxlator compute_update --channel_id $CH_NAME --original config.pb --updated modified_config.pb --output config_update.pb</code></pre></li><li>⽣成通道更新的pb⽂件<pre><code>configtxlator proto_decode --input config_update.pb --type common.ConfigUpdate --output config_update.jsonecho &#39;{&quot;payload&quot;:{&quot;header&quot;:{&quot;channel_header&quot;:{&quot;channel_id&quot;:&quot;&#39;$CH_NAME&#39;&quot;, &quot;type&quot;:2}},&quot;data&quot;:{&quot;config_update&quot;:&#39;$(cat config_update.json)&#39;}}}&#39; | jq . &gt; config_update_in_envelope.jsonconfigtxlator proto_encode --input config_update_in_envelope.json --type common.Envelope --output config_update_in_envelope.pb</code></pre></li></ul></li><li>提交更新到通道<ul><li>这⾥假设orderer只有⼀家组织，如果有多家则需要每⼀家先对 config_update_in_envelope.pb 进⾏ signconfigtx 操作 <pre><code>peer channel update -f config_update_in_envelope.pb -c $CH_NAME -o $ORDERER_CONTAINER --tls true --cafile $TLS_ROOT_CA</code></pre><h3 id="具体操作-2"><a href="#具体操作-2" class="headerlink" title="具体操作"></a>具体操作</h3></li></ul></li></ul><p>进入 cli 容器</p><pre><code>docker exec -it cli bash </code></pre><p>进入 script 文件夹</p><pre><code>cd scripts</code></pre><p>将脚本 capabilities.json 复制到 此文件夹中即 fabric-sanples/firstnetwork/scripts 文件夹</p><p>然后给该脚本添加可执行权限并执行</p><pre><code>chmod +x updating_capabilities_sys.sh./updating_capabilities_sys.sh</code></pre><h2 id="2-2-升级已有应⽤链的系统配置"><a href="#2-2-升级已有应⽤链的系统配置" class="headerlink" title="2.2 升级已有应⽤链的系统配置"></a>2.2 升级已有应⽤链的系统配置</h2><p>参考脚本 updating_capabilities_mychannel.sh</p><ul><li><p>对环境变量进⾏配置，这⾥以 fabric-samples/first-network中的mychannel为例，mychannel 中包含了 Org1 和 Org2 两个组织</p><pre><code>CH_NAME=mychannelCORE_PEER_LOCALMSPID=Org1MSP TLS_ROOT_CA=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pemCORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp ORDERER_CONTAINER=orderer.example.com:7050 </code></pre></li><li><p>获取mychannel的原有配置</p><ul><li>获取原有配置<pre><code>peer channel fetch config config_block.pb -o $ORDERER_CONTAINER -c $CH_NAME --tls --cafile $TLS_ROOT_CA</code></pre></li><li>将配置转化为json格式<pre><code>configtxlator proto_decode --input config_block.pb --type common.Block --output config_block.json</code></pre></li><li>从json中只提取出来配置的部分 jq<pre><code>.data.data[0].payload.data.config config_block.json &gt; config.json</code></pre></li></ul></li><li><p>修改兼容性配置注意应⽤通道⽐系统通道多了⼀个Application的兼容性需要修改</p><pre><code>  jq -s &#39;.[0] * {&quot;channel_group&quot;:{&quot;groups&quot;:{&quot;Orderer&quot;: {&quot;values&quot;: {&quot;Capabilities&quot;: .[1].orderer}}}}}&#39; config.json ./capabilities.json &gt; modified_config1.json  jq -s &#39;.[0] * {&quot;channel_group&quot;:{&quot;values&quot;: {&quot;Capabilities&quot;: .[1].channel}}}&#39; modified_config1.json ./capabilities.json &gt; modified_config2.json  jq -s &#39;.[0] * {&quot;channel_group&quot;:{&quot;groups&quot;:{&quot;Application&quot;: {&quot;values&quot;: {&quot;Capabilities&quot;: .[1].application}}}}}&#39; modified_config2.json ./capabilities.json &gt; modified_config.json</code></pre></li><li><p>计算配置的deltaSet，⽣成pb⽂件</p><ul><li>计算deltaSet<pre><code>configtxlator proto_encode --input config.json --type common.Config --output config.pbconfigtxlator proto_encode --input modified_config.json --type common.Config --output modified_config.pbconfigtxlator compute_update --channel_id $CH_NAME --original config.pb --updated modified_config.pb --output config_update.pb</code></pre></li></ul></li><li><p>⽣成通道更新的pb⽂件</p><pre><code>  configtxlator proto_decode --input config_update.pb --type common.ConfigUpdate --output config_update.json   echo &#39;{&quot;payload&quot;:{&quot;header&quot;:{&quot;channel_header&quot;:{&quot;channel_id&quot;:&quot;&#39;$CH_NAME&#39;&quot;, &quot;type&quot;:2}},&quot;data&quot;:{&quot;config_update&quot;:&#39;$(cat config_update.json)&#39;}}}&#39; | jq . &gt; config_update_in_envelope.json   configtxlator proto_encode --input config_update_in_envelope.json --type common.Envelope --output config_update_in_envelope.pb</code></pre></li><li><p>提交更新到通道<br>  因为mychannel中有Org1和Org2两个组织（实际上还有Orderer的配置），对通道配置进⾏修改需要通道多数<br>  组织的签名，以及对Orderer配置修改需要Orderer组织的签名。 所以这⾥假设，先让Org1和Org2进⾏签名，再由Orderer进更新的提交。</p><ul><li>Org1签名<pre><code>peer channel signconfigtx -f config_update_in_envelope.pb</code></pre></li><li>切换为Org2<pre><code>CORE_PEER_LOCALMSPID=Org2MSPCORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp</code></pre></li><li>Org2签名<pre><code>peer channel signconfigtx -f config_update_in_envelope.pb</code></pre></li><li>切换为Orderer的组织<pre><code>CORE_PEER_LOCALMSPID=OrdererMSPCORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/users/Admin@example.com/msp</code></pre></li><li>Orderer组织提交变更<pre><code>peer channel update -f config_update_in_envelope.pb -c $CH_NAME -o $ORDERER_CONTAINER --tls true --cafile $TLS_ROOT_CA </code></pre></li></ul></li></ul><h3 id="具体操作-3"><a href="#具体操作-3" class="headerlink" title="具体操作"></a>具体操作</h3><p>进入 cli 容器</p><pre><code>docker exec -it cli bash </code></pre><p>进入 script 文件夹</p><pre><code>cd scripts</code></pre><p>将脚本 updating_capabilities_sys.sh 复制到 此文件夹中，即 fabric-sanples/firstnetwork/scripts 文件夹</p><p>然后给该脚本添加可执行权限并执行</p><pre><code>chmod +x updating_capabilities_sys.sh./updating_capabilities_sys.sh</code></pre><h1 id="3-激活chaincode的新的⽣命周期管理"><a href="#3-激活chaincode的新的⽣命周期管理" class="headerlink" title="3. 激活chaincode的新的⽣命周期管理"></a>3. 激活chaincode的新的⽣命周期管理</h1><p>只更改兼容性，通道若要使⽤chaincode的新的⽣命周期管理⽅案会出现错误，这是因为原有1.4的通道配置中，缺少通道<br>Endorsement和LifecycleEndorsement的配置。 为了⽅便使⽤ jq 命令来添加这两部分内容，⾸先准备包含以下内容的 enable_lifecycle.json⽂件，注意这⾥假设了通道内有两家组织，分别为Org1和Org2，他们的MSPID分别为Org1MSP,Org2MSP。 请根据需要进⾏修改。</p><pre><code>{     &quot;Org1MSPPolicies&quot;: {         &quot;Endorsement&quot;: {             &quot;mod_policy&quot;: &quot;Admins&quot;,             &quot;policy&quot;: {                 &quot;type&quot;: 1,                 &quot;value&quot;: {                 &quot;identities&quot;: [                     {                         &quot;principal&quot;: {                             &quot;msp_identifier&quot;: &quot;Org1MSP&quot;,                             &quot;role&quot;: &quot;PEER&quot;                         },                        &quot;principal_classification&quot;: &quot;ROLE&quot;                     }                 ],                &quot;rule&quot;: {                     &quot;n_out_of&quot;: {                         &quot;n&quot;: 1,                         &quot;rules&quot;: [                             {                              &quot;signed_by&quot;: 0                             }                        ]                     }                 },                &quot;version&quot;: 0             }         },        &quot;version&quot;: &quot;0&quot;         }     },     &quot;Org2MSPPolicies&quot;: {         &quot;Endorsement&quot;: {             &quot;mod_policy&quot;: &quot;Admins&quot;,             &quot;policy&quot;: {                 &quot;type&quot;: 1,                 &quot;value&quot;: {                 &quot;identities&quot;: [                 {                     &quot;principal&quot;: {                         &quot;msp_identifier&quot;: &quot;Org2MSP&quot;,                         &quot;role&quot;: &quot;PEER&quot;                 },                &quot;principal_classification&quot;: &quot;ROLE&quot;                }             ],            &quot;rule&quot;: {                 &quot;n_out_of&quot;: {                     &quot;n&quot;: 1,                     &quot;rules&quot;: [                     {                         &quot;signed_by&quot;: 0                     }                    ]                 }             },            &quot;version&quot;: 0             }         },        &quot;version&quot;: &quot;0&quot;      }     },    &quot;appPolicies&quot;: {         &quot;Endorsement&quot;: {             &quot;mod_policy&quot;: &quot;Admins&quot;,             &quot;policy&quot;: {                 &quot;type&quot;: 3,                 &quot;value&quot;: {                     &quot;rule&quot;: &quot;MAJORITY&quot;,                     &quot;sub_policy&quot;: &quot;Endorsement&quot;                 }             },            &quot;version&quot;: &quot;0&quot;         },        &quot;LifecycleEndorsement&quot;: {             &quot;mod_policy&quot;: &quot;Admins&quot;,             &quot;policy&quot;: {                 &quot;type&quot;: 3,                 &quot;value&quot;: {                     &quot;rule&quot;: &quot;MAJORITY&quot;,                     &quot;sub_policy&quot;: &quot;Endorsement&quot;                 }             },            &quot;version&quot;: &quot;0&quot;         }     } } </code></pre><h2 id="3-1-更改系统链配置"><a href="#3-1-更改系统链配置" class="headerlink" title="3.1 更改系统链配置"></a>3.1 更改系统链配置</h2><p>参考脚本enable_cc_lifecycle_sys.sh</p><ul><li><p>对环境变量进⾏配置</p><pre><code>CH_NAME=byfn-sys-channelCORE_PEER_LOCALMSPID=OrdererMSPTLS_ROOT_CA=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pemCORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/users/Admin@example.com/mspORDERER_CONTAINER=orderer.example.com:7050ORGNAME=Org1MSPCONSORTIUM_NAME=SampleConsortium</code></pre></li><li><p>获取原有的配置</p><pre><code>peer channel fetch config config_block.pb -o $ORDERER_CONTAINER -c $CH_NAME --tls --cafile $TLS_ROOT_CAconfigtxlator proto_decode --input config_block.pb --type common.Block --output config_block.jsonjq .data.data[0].payload.data.config config_block.json &gt; config.json</code></pre></li><li><p>修改相应配置</p><ul><li>修改Org1的配置，增加Org1的Endorsement的配置 <pre><code>jq -s &quot;.[0] * {\&quot;channel_group\&quot;:{\&quot;groups\&quot;:{\&quot;Consortiums\&quot;:{\&quot;groups\&quot;: {\&quot;$CONSORTIUM_NAME\&quot;: {\&quot;groups\&quot;: {\&quot;$ORGNAME\&quot;: {\&quot;policies\&quot;: .[1].${ORGNAME}Policies}}}}}}}}&quot; config.json ./enable_lifecycle.json &gt; modified_config1.json</code></pre></li><li>修改Org2的配置，增加Org2的Endorsement的配置<pre><code>ORGNAME=Org2MSPjq -s &quot;.[0] * jq -s &quot;.[0] * {\&quot;channel_group\&quot;:{\&quot;groups\&quot;:{\&quot;Consortiums\&quot;:{\&quot;groups\&quot;: {\&quot;$CONSORTIUM_NAME\&quot;: {\&quot;groups\&quot;: {\&quot;$ORGNAME\&quot;: {\&quot;policies\&quot;: .[1].${ORGNAME}Policies}}}}}}}}&quot; modified_config1.json ./enable_lifecycle.json &gt; modified_config.json</code></pre></li></ul></li><li><p>计算配置的deltaSet，⽣成pb⽂件</p><ul><li>计算deltaSet<pre><code>configtxlator proto_encode --input config.json --type common.Config --output config.pbconfigtxlator proto_encode --input modified_config.json --type common.Config --output modified_config.pbconfigtxlator compute_update --channel_id $CH_NAME --original config.pb --updated modified_config.pb --output config_update.pb</code></pre></li><li>⽣成通道更新的pb⽂件<pre><code>configtxlator proto_decode --input config_update.pb --type common.ConfigUpdate --output config_update.jsonecho &#39;{&quot;payload&quot;:{&quot;header&quot;:{&quot;channel_header&quot;:{&quot;channel_id&quot;:&quot;&#39;$CH_NAME&#39;&quot;, &quot;type&quot;:2}},&quot;data&quot;:{&quot;config_update&quot;:&#39;$(cat config_update.json)&#39;}}}&#39; | jq . &gt; config_update_in_envelope.jsonconfigtxlator proto_encode --input config_update_in_envelope.json --type common.Envelope --output config_update_in_envelope.pb</code></pre></li></ul></li><li><p>提交更新到通道<br>  因为Consortium中有Org1和Org2两个组织，对每个组织的内容修改都需要该组织的Admin的签名，然后对系 统通道配置进⾏修改需要Orderer组织的Admin签名。 </p><ul><li>Orderer签名<pre><code>peer channel signconfigtx -f config_update_in_envelope.pb </code></pre></li><li>切换为Org1，org1 签名<pre><code>CORE_PEER_LOCALMSPID=Org1MSPCORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msppeer channel signconfigtx -f config_update_in_envelope.pb</code></pre></li><li>切换为Org2 ，org2 签名<pre><code>CORE_PEER_LOCALMSPID=Org2MSPCORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msppeer channel signconfigtx -f config_update_in_envelope.pb</code></pre></li><li>切换回Orderer<pre><code>CORE_PEER_LOCALMSPID=OrdererMSPCORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/users/Admin@example.com/msp</code></pre></li><li>提交更新<pre><code>peer channel update -f config_update_in_envelope.pb -c $CH_NAME -o $ORDERER_CONTAINER --tls true --cafile $TLS_ROOT_CA</code></pre><h2 id="3-2-更改已有的应⽤通道配置"><a href="#3-2-更改已有的应⽤通道配置" class="headerlink" title="3.2 更改已有的应⽤通道配置"></a>3.2 更改已有的应⽤通道配置</h2></li></ul></li></ul><p>以fabric-samples/first-network中的mychannel为例。 参考脚本enable_cc_lifecycle_mychannel.sh</p><ul><li>对环境变量进⾏配置<pre><code>CH_NAME=mychannelCORE_PEER_LOCALMSPID=Org1MSPTLS_ROOT_CA=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pemCORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/mspORDERER_CONTAINER=orderer.example.com:7050ORGNAME=Org1MSPCONSORTIUM_NAME=SampleConsortium</code></pre></li><li>获取原有的配置<pre><code>peer channel fetch config config_block.pb -o $ORDERER_CONTAINER -c $CH_NAME --tls --cafile $TLS_ROOT_CAconfigtxlator proto_decode --input config_block.pb --type common.Block --output config_block.jsonjq .data.data[0].payload.data.config config_block.json &gt; config.json </code></pre></li><li>修改相应配置注意需要⽐系统通道多修改Application的Endorsement和LifeCycleEndorsement<ul><li>修改Org1的配置，增加Org1的Endorsement的配置<pre><code>jq -s &quot;.[0] * {\&quot;channel_group\&quot;:{\&quot;groups\&quot;:{\&quot;Application\&quot;:{\&quot;groups\&quot;: {\&quot;$ORGNAME\&quot;: {\&quot;policies\&quot;: .[1].${ORGNAME}Policies}}}}}}&quot; config.json ./enable_lifecycle.json &gt; modified_config1.json</code></pre></li><li>切换为Org2<pre><code>ORGNAME=Org2MSP</code></pre></li><li>修改Org2的配置，增加Org2的Endorsement的配置<pre><code>jq -s &quot;.[0] * {\&quot;channel_group\&quot;:{\&quot;groups\&quot;:{\&quot;Application\&quot;:{\&quot;groups\&quot;: {\&quot;$ORGNAME\&quot;: {\&quot;policies\&quot;: .[1].${ORGNAME}Policies}}}}}}&quot; modified_config1.json ./enable_lifecycle.json &gt; modified_config2.json</code></pre></li><li>修改通道配置，增加Endorsement和LifeCycleEndorsement配置<pre><code>jq -s &#39;.[0] * {&quot;channel_group&quot;:{&quot;groups&quot;:{&quot;Application&quot;: {&quot;policies&quot;: .[1].appPolicies}}}}&#39; modified_config2.json ./enable_lifecycle.json &gt; modified_config.json</code></pre></li></ul></li><li>计算配置的deltaSet，⽣成pb⽂件<ul><li>计算deltaSet<pre><code>configtxlator proto_encode --input config.json --type common.Config --output config.pbconfigtxlator proto_encode --input modified_config.json --type common.Config --output modified_config.pbconfigtxlator compute_update --channel_id $CH_NAME --original config.pb --updated modified_config.pb --output config_update.pb</code></pre></li><li>⽣成通道更新的pb⽂件<pre><code>configtxlator proto_decode --input config_update.pb --type common.ConfigUpdate --output config_update.jsonecho &#39;{&quot;payload&quot;:{&quot;header&quot;:{&quot;channel_header&quot;:{&quot;channel_id&quot;:&quot;&#39;$CH_NAME&#39;&quot;, &quot;type&quot;:2}},&quot;data&quot;:{&quot;config_update&quot;:&#39;$(cat config_update.json)&#39;}}}&#39; | jq . &gt; config_update_in_envelope.jsonconfigtxlator proto_encode --input config_update_in_envelope.json --type common.Envelope --output config_update_in_envelope.pb</code></pre></li></ul></li><li>提交更新到通道 因为Consortium中有Org1和Org2两个组织，对每个组织的内容修改都需要该组织的Admin的签名。<ul><li>Org1签名<pre><code>peer channel signconfigtx -f config_update_in_envelope.pb</code></pre></li><li>切换为Org2 <pre><code>CORE_PEER_LOCALMSPID=Org2MSPCORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp</code></pre></li><li>Org2来提交通道变更<pre><code>peer channel update -f config_update_in_envelope.pb -c $CH_NAME -o $ORDERER_CONTAINER --tls true --cafile $TLS_ROOT_CA</code></pre></li></ul></li></ul><h1 id="4-⼀些验证过的特殊场景"><a href="#4-⼀些验证过的特殊场景" class="headerlink" title="4. ⼀些验证过的特殊场景"></a>4. ⼀些验证过的特殊场景</h1><h3 id="4-1-是否可以升级镜像但不升级兼容性"><a href="#4-1-是否可以升级镜像但不升级兼容性" class="headerlink" title="4.1 是否可以升级镜像但不升级兼容性"></a>4.1 是否可以升级镜像但不升级兼容性</h3><p>可以的，只升级镜像不升级兼容性的话，还是按照1.4的功能来运⾏</p><h3 id="4-2-是否可以只升级某些通道的兼容性"><a href="#4-2-是否可以只升级某些通道的兼容性" class="headerlink" title="4.2 是否可以只升级某些通道的兼容性"></a>4.2 是否可以只升级某些通道的兼容性</h3><p>可以的，不过建议先升级系统通道，这样之后新⽣成的通道就可以是最新的兼容性配置了。</p><h3 id="4-3-通道中原有的链码是否还可以正常使⽤"><a href="#4-3-通道中原有的链码是否还可以正常使⽤" class="headerlink" title="4.3 通道中原有的链码是否还可以正常使⽤"></a>4.3 通道中原有的链码是否还可以正常使⽤</h3><p>升级镜像后，原有的链码可以正常使⽤，但是需要注意链码镜像的问题，如果保留了原链码的镜像则⽆需关⼼该问题，没有保留的 话，需要将ccenv配置为1.4的镜像版本。通道兼容性的升级也不会影响已有链码的使⽤。</p><h3 id="4-4-升级之后原有链码也有升级需求应该怎么操作"><a href="#4-4-升级之后原有链码也有升级需求应该怎么操作" class="headerlink" title="4.4 升级之后原有链码也有升级需求应该怎么操作"></a>4.4 升级之后原有链码也有升级需求应该怎么操作</h3><p>升级了镜像以及兼容性后，如果原有链码也需要升级，则需要⾛2.0的lifecycle的升级流程，即需要package-install- approveformyorg-commit那⼀套流程。</p><blockquote><p>Fabric的2.1和2.2版本是稳定版本，具有错误修复和其他形式的代码强化功能。升级的时候不需要特别的考虑，也不需要特定的镜像版本或通道配置更新。</p></blockquote><p>#下面是升级到 2.2 新增的一些内容</p><h2 id="从2-0-升级到-2-1"><a href="#从2-0-升级到-2-1" class="headerlink" title="从2.0 升级到 2.1"></a>从2.0 升级到 2.1</h2><p>之前 1.4 升级到 2.0 时，升级peer数据库需要先删除 peer 的数据库，也就是执行 peer node upgrade-dbs 命令</p><pre><code>docker run --rm -v /opt/backup/$PEER_CONTAINER/:/var/hyperledger/production/ \            -v /opt/msp/:/etc/hyperledger/fabric/msp/ \            --env-file ./env&lt;name of node&gt;.list \            --name $PEER_CONTAINER \            hyperledger/fabric-peer:2.0 peer node upgrade-dbs</code></pre><p>然后执行 peer node start 命令重建 peer 数据库</p><pre><code>docker run -d -v /opt/backup/$PEER_CONTAINER/:/var/hyperledger/production/ \            -v /opt/msp/:/etc/hyperledger/fabric/msp/ \            --env-file ./env&lt;name of node&gt;.list \            --name $PEER_CONTAINER \            hyperledger/fabric-peer:2.0 peer node start</code></pre><p>如果在升级过程中未删除 peer 数据库，则启动 peer 时将返回一条错误信息，提示需要先删除数据库。</p><p>如果升级到 2.1 的话，在上面的命令中将 2.0 换成 2.1 就行</p><h2 id="从-2-1-升级到-2-2"><a href="#从-2-1-升级到-2-2" class="headerlink" title="从 2.1 升级到 2.2"></a>从 2.1 升级到 2.2</h2><p>如果升级到 2.2 的话，删除数据库的命令都省了，如果是使用CouchDB作为状态数据库，则从v2.2 开始， peer 支持自动删除该数据库。为了利用这种支持，在运行 upgrade-dbs 命令之前，需要将 peer 的状态数据库配置为 CouchDB，并启动 CouchDB。在v2.0和v2.1中，peer 不会自动删除CouchDB状态数据库。需要手动好删除。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/upgrade_to_newest_version.html" target="_blank" rel="noopener">Considerations for getting to v2.x</a></p>]]></content>
      
      
      <categories>
          
          <category> fabric </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fabric </tag>
            
            <tag> 2.2 </tag>
            
            <tag> upgrade </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fabric 1.4源码分析2：Orderer 核心数据结构</title>
      <link href="/2020/08/02/orderer-data-structure/"/>
      <url>/2020/08/02/orderer-data-structure/</url>
      
        <content type="html"><![CDATA[<blockquote><p>回顾上一节中我们讲述了一笔交易在 orderer 中的处理流程，进入引出了 orderer 源码分析的知识图谱。这次我们就从知识图谱的第一块内容说起，也就是 orderer 核心数据结构。</p></blockquote><p><strong>友情提示：在Fabric中，通道和链在概念上都是一条区块链，所以本文中也可能会混用链和通道的说法，请读者不要过于纠结于这两个概念。</strong></p><h1 id="Registrar"><a href="#Registrar" class="headerlink" title="Registrar"></a>Registrar</h1><p>Registrar 对象是一个多通道注册管理器，负责管理系统通道与所有应用通道，封装了所有通道的 ChainSupport 的 map、共识组件 map、ledgerFactory 对象等组件，维护所有通道上的通道配置、区块账本对象、共识组件等核心资源，创建通道上的共识组件链对象提供Orderer共识排序服务，负责对交易消息排序，切割打包构造新区块并提交账本，同时负责创建新的应用通道与更新通道配置。</p><p>一言蔽之，<br>Registrar 就相当于 Orderer节点上的 “资源管理器”，包含了所有通道 资源的访问和控制点，也就是说，我们如果需要对 orderer 节点的任何一个通道进行操作，都得先从这里入手。</p><blockquote><p>Registrar 对象定义在<br>fabric/orderer/common/multichannel/registrar.go 文件中，具体如下：</p></blockquote><pre><code>// Registrar serves as a point of access and control for the individual channel resources.type Registrar struct {    lock               sync.RWMutex    chains             map[string]*ChainSupport    config             localconfig.TopLevel    consenters         map[string]consensus.Consenter    ledgerFactory      blockledger.Factory    signer             crypto.LocalSigner    blockcutterMetrics *blockcutter.Metrics    systemChannelID    string    systemChannel      *ChainSupport    templator          msgprocessor.ChannelConfigTemplator    callbacks          []channelconfig.BundleActor}</code></pre><ul><li>lock 是一把锁，当需要对于通道资源进行读和写操作时，会对通道加锁，操作完再解锁。</li><li>chains 保存了所有的链，每一条链在 Orderer 中都以 一个 Key - Value 键值对表述，其中键就是 channelID，值就是一条链，这里用 ChainSupport表示，具体下文还会介绍。</li><li>config 保存了从 orderer.yaml 中读取的配置</li><li>consenters 保存了所有的共识插件，每个共识插件都是一个 Consenter，Fabric 1.4 中共识插件有 Solo、Kafka、EtcdRaft 三种。</li><li>ledgerFactory 用来读取和创建链的账本。</li><li>signer用来对Orderer中的数据进行签名，以及创建 <a href="https://lessisbetter.site/2019/11/10/how-fabric-verify-signatures/#%E8%A7%A3%E5%AF%86SignatureHeader" target="_blank" rel="noopener">SignatureHeader</a>。</li><li>blockcutterMetrics 是用于对切块进行一些指标的监测</li><li>systemChannelID 和 systemChannel分别是系统通道ID、系通道实例。</li><li>systemChannel </li><li>templator 用于生成一个通道配置模版</li><li>callbacks 用于对通道配置执行一些回调的操作</li></ul><h1 id="ChainSupport"><a href="#ChainSupport" class="headerlink" title="ChainSupport"></a>ChainSupport</h1><p>ChainSupport 封装了关联通道上的账本资源对象、消息处理器、区 块写组件、共识组件链对象等核心组件与模块，用于过滤验证消息、切割打包消息出块、 提交区块写入账本、创建通道与更新通道配置等流程。</p><p>一言蔽之，ChainSupport 汇集了一条通道所需要的所有资源，一个 ChainSupport 就代表了一条链。</p><blockquote><p>ChainSupport 对象定义在<br>fabric/orderer/common/multichannel/chainsupport.go 文件中，具体如下：</p></blockquote><pre><code>// ChainSupport holds the resources for a particular channel.type ChainSupport struct {    *ledgerResources    msgprocessor.Processor    *BlockWriter    consensus.Chain    cutter blockcutter.Receiver    crypto.LocalSigner}</code></pre><p>ChainSupport 是一堆接口的集合，这些接口构成一条链所有的操作，接口可以分为4类：</p><ul><li>账本：ledgerResources、BlockWriter分别是账本读写和把区块写入到账本。</li><li>消息：msgprocessor.Processor、cutter分别是处理交易和把交易切块。</li><li>共识：consensus.Chain是Orderer的共识实例，比如每条链都有自己的Raft共识实例，它们互不干扰。</li><li>签名：crypto.LocalSigner，同Registrar中的介绍。</li></ul><h1 id="Chain"><a href="#Chain" class="headerlink" title="Chain"></a>Chain</h1><p>Chain 接口的实现是一个共识插件的实例，它利用不同的共识算法（Solo、Kafka 和 Etcdraft）对交易排序并 添加到本地的缓存交易消息列表中，按出块规则切割成批量交易集合，再打包出块提交到账本，同时负责创建新通道与更新通道配置。</p><p>一言蔽之，Chain 接口包含了一个共识插件所要实现的基本方法，它主要负责对交易/消息进行排序并调用 HandleChain 方法进行切块和写入账本，体现了共识算法的可插拔性。</p><blockquote><p>Chain 接口定义在<br>fabric/orderer/consensus/consensus.go 文件中，具体如下：</p></blockquote><pre><code>// Chain defines a way to inject messages for ordering.// Note, that in order to allow flexibility in the implementation, it is the responsibility of the implementer// to take the ordered messages, send them through the blockcutter.Receiver supplied via HandleChain to cut blocks,// and ultimately write the ledger also supplied via HandleChain.  This design allows for two primary flows// 1. Messages are ordered into a stream, the stream is cut into blocks, the blocks are committed (solo, kafka)// 2. Messages are cut into blocks, the blocks are ordered, then the blocks are committed (sbft)Chain定义了一种注入消息的方式来进行排序。// 注意，为了在实现中实现灵活性，实现者负责获取有序消息，并通过 blockcutter 发送它们。接收器通过 HandleChain 来切割块，并写入账本也通过 HandleChain方法。// 这种设计允许两个主要流程：// 1. 消息被排序到一个流中，流被切成块，块被提交(solo, kafka)// 2. 消息被切成块，对块进行排序，然后提交块(sbft)type Chain interface {    // 普通消息/交易排序    // Order accepts a message which has been processed at a given configSeq.    // If the configSeq advances, it is the responsibility of the consenter    // to revalidate and potentially discard the message    // The consenter may return an error, indicating the message was not accepted    Order(env *cb.Envelope, configSeq uint64) error    // 配置消息/交易排序    // Configure accepts a message which reconfigures the channel and will    // trigger an update to the configSeq if committed.  The configuration must have    // been triggered by a ConfigUpdate message. If the config sequence advances,    // it is the responsibility of the consenter to recompute the resulting config,    // discarding the message if the reconfiguration is no longer valid.    // The consenter may return an error, indicating the message was not accepted    Configure(config *cb.Envelope, configSeq uint64) error    // 等待排序集群可用    // WaitReady blocks waiting for consenter to be ready for accepting new messages.    // This is useful when consenter needs to temporarily block ingress messages so    // that in-flight messages can be consumed. It could return error if consenter is    // in erroneous states. If this blocking behavior is not desired, consenter could    // simply return nil.    WaitReady() error    // 当排序集群发送错误时，会关闭返回的通道    // Errored returns a channel which will close when an error has occurred.    // This is especially useful for the Deliver client, who must terminate waiting    // clients when the consenter is not up to date.    Errored() &lt;-chan struct{}    // 启动当前链    // Start should allocate whatever resources are needed for staying up to date with the chain.    // Typically, this involves creating a thread which reads from the ordering source, passes those    // messages to a block cutter, and writes the resulting blocks to the ledger.    Start()    // 停止当前链，并释放资源    // Halt frees the resources which were allocated for this Chain.    Halt()}</code></pre><h1 id="Consenter"><a href="#Consenter" class="headerlink" title="Consenter"></a>Consenter</h1><p>Consenter 也是接口，它只有1个功能用来创建 Chain。每种共识插件，都有自己单独的consenter实现，分别用来创建solo实例、kafka实例或etcdraft实例。</p><pre><code>// Consenter defines the backing ordering mechanism.type Consenter interface {    // HandleChain should create and return a reference to a Chain for the given set of resources.    // It will only be invoked for a given chain once per process.  In general, errors will be treated    // as irrecoverable and cause system shutdown.  See the description of Chain for more details    // The second argument to HandleChain is a pointer to the metadata stored on the `ORDERER` slot of    // the last block committed to the ledger of this Chain. For a new chain, or one which is migrated,    // this metadata will be nil (or contain a zero-length Value), as there is no prior metadata to report.    HandleChain(support ConsenterSupport, metadata *cb.Metadata) (Chain, error)}</code></pre><h1 id="ConsenterSupport"><a href="#ConsenterSupport" class="headerlink" title="ConsenterSupport"></a>ConsenterSupport</h1><p>ConsenterSupport 为 consenter 实现提供所需的资源，其实就是共识用来访问外部数据的接口。</p><pre><code>// ConsenterSupport provides the resources available to a Consenter implementation.type ConsenterSupport interface {    crypto.LocalSigner    msgprocessor.Processor    // 验证区块签名是否合法    // VerifyBlockSignature verifies a signature of a block with a given optional    // configuration (can be nil).    VerifyBlockSignature([]*cb.SignedData, *cb.ConfigEnvelope) error    // 提供把消息切成块的接口    // BlockCutter returns the block cutting helper for this channel.    BlockCutter() blockcutter.Receiver    // 当前链的orderer配置    // SharedConfig provides the shared config from the channel&#39;s current config block.    SharedConfig() channelconfig.Orderer    // 当前链的通道配置    // ChannelConfig provides the channel config from the channel&#39;s current config block.    ChannelConfig() channelconfig.Channel    // 生成区块    // CreateNextBlock takes a list of messages and creates the next block based on the block with highest block number committed to the ledger    // Note that either WriteBlock or WriteConfigBlock must be called before invoking this method a second time.    CreateNextBlock(messages []*cb.Envelope) *cb.Block    // 读区块    // Block returns a block with the given number,    // or nil if such a block doesn&#39;t exist.    Block(number uint64) *cb.Block    // 写区块    // WriteBlock commits a block to the ledger.    WriteBlock(block *cb.Block, encodedMetadataValue []byte)    // 写配置区块并更新配置    // WriteConfigBlock commits a block to the ledger, and applies the config update inside.    WriteConfigBlock(block *cb.Block, encodedMetadataValue []byte)    // 返回当前配置序列号    // Sequence returns the current config squence.    Sequence() uint64    // 返回 channel ID    // ChainID returns the channel ID this support is associated with.    ChainID() string    // 返回区块高度    // Height returns the number of blocks in the chain this channel is associated with.    Height() uint64    //以原始数据的格式追加区块，不像WriteBlock那样会修改元数据    // Append appends a new block to the ledger in its raw form,    // unlike WriteBlock that also mutates its metadata.    Append(block *cb.Block) error}</code></pre><h1 id="一图看懂-Orderer-核心数据结构"><a href="#一图看懂-Orderer-核心数据结构" class="headerlink" title="一图看懂 Orderer 核心数据结构"></a>一图看懂 Orderer 核心数据结构</h1><blockquote><p>建议点击图片查看大图</p></blockquote><p><img src="http://note.youdao.com/yws/res/296/WEBRESOURCE4045838a95b90333c47c17cc7a9bc01b" alt="orderer 核心数据结构"></p>]]></content>
      
      
      <categories>
          
          <category> fabric </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fabric </tag>
            
            <tag> orderer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fabric 1.4源码分析1：Orderer功能概述</title>
      <link href="/2020/07/25/orderer-functions-overview/"/>
      <url>/2020/07/25/orderer-functions-overview/</url>
      
        <content type="html"><![CDATA[<blockquote><p>从今天开始，正式启动Fabric 1.4 源码分析系列专题，本文是源码分析系列的第一篇，决定先从 Orderer 入手。由于Fabric源码涉及的模块、知识点的深度和广度非同一般，为了避免从一开始就落入细节，因此决定先采用模块分解 + 架构梳理 + 知识点细化的三步走战略进行。希望通过这样自顶向下，逐步细化的方式从整体上把握fabric的实现原理，涉及到具体开发工作时又能快速上手。</p></blockquote><h1 id="代码目录"><a href="#代码目录" class="headerlink" title="代码目录"></a>代码目录</h1><p>源码分析的宗旨是一切始于源码，终于源码。所以我们首先来看看orderer这块的代码目录。orderer相关的代码主要在 fabric/orderer文件夹中：</p><pre><code>➜  fabric git:(readCode) ✗ tree -L 2 ordererorderer├── README.md├── common│   ├── blockcutter 缓存待打包的交易，切块│   ├── bootstrap 启动时替换通道创世块│   ├── broadcast orderer的Broadcast接口│   ├── cluster （Raft）集群服务│   ├── localconfig 解析orderer配置文件orderer.yaml│   ├── metadata 区块元数据填写│   ├── msgprocessor 交易检查│   ├── multichannel 多通道支持：Registrar、chainSupport、写区块│   └── server Orderer节点的服务端程序├── consensus 共识插件│   ├── consensus.go 共识插件需要实现的接口等定义│   ├── etcdraft raft共识插件│   ├── inactive 未激活时的raft│   ├── kafka kafka共识插件│   ├── mocks 测试用的共识插件│   └── solo solo共识插件├── main.go orderer程序入口├── mocks│   ├── common│   └── util└── sample_clients orderer的客户端程序样例    ├── broadcast_config    ├── broadcast_msg    └── deliver_stdout23 directories, 3 files</code></pre><p>相信大家这样过了一遍心里有个大致印象，但还是一脸懵逼，不过没关系，我们接着往下看：</p><h1 id="功能概述"><a href="#功能概述" class="headerlink" title="功能概述"></a>功能概述</h1><p>Orderer排序节点管理着系统通道与所有应用通道，负责通道创建、通道配置更新等操作，并处理客户端提交的交易消息请求，对交易进行排序并按规则打包成新区块，提交账本并维护通道账本数据，为全网节点提供Broadcast交易广播服务、Orderer共识排序服务、Deliver区块分发服务等。</p><p><img src="http://note.youdao.com/yws/res/63/WEBRESOURCE0d039e7a4924db2b6d979c334fd14e9d" alt="orderer功能概述"></p><blockquote><p>图片源自《Hyperledger Fabric技术内幕 架构设计与实现原理》</p></blockquote><h2 id="一笔交易在Orderer中经历的过程"><a href="#一笔交易在Orderer中经历的过程" class="headerlink" title="一笔交易在Orderer中经历的过程"></a>一笔交易在Orderer中经历的过程</h2><p>还记得在上一篇中我们介绍了一笔交易在fabric中所经历的过程，那么这一节我们依旧以交易为切入点，聚焦于交易在orderer这部分到底经历了什么。</p><p><img src="http://note.youdao.com/yws/res/84/WEBRESOURCEb122473b5b7acef549a64630e6570d63" alt="一笔交易在 orderer 中的处理流程"></p><p>如图所示，orderer节点首先通过<strong>Broadcast广播交易服务</strong>从客户端获取经过背书的交易消息，然后将交易进行排序并打包成区块，最后通过<strong>Deliver区块分发服务</strong>向peer节点分发打包好的区块。</p><p>其中将交易进行排序和打包成区块的步骤又可以进一步分解为:</p><ol><li>对交易进行多项检查（<strong>MsgProcessor</strong>）</li><li>通过solo、kafka、raft等共识算法对交易进行排序（<strong>consensus共识插件</strong>）</li><li>根据切块策略进行切块（<strong>BlockCutter</strong>）</li><li>保存区块文件（<strong>BlockWriter</strong>）</li></ol><p>通过以上对一笔交易在orderer中所经历的过程进行分析，我们会发现其实orderer这块的源码可以拆分成以下几个主要模块：</p><ol><li>广播交易服务：Brodcast </li><li>交易检查：Msgprocessor</li><li>交易排序：Solo、Kafka、Etcdraft</li><li>切块：Blockcutter</li><li>写区块：BlockWriter</li><li>区块分发服务：Deliver 区块分发服务</li></ol><p>除此之外，在分析源码之前我们还需要了解 Ordrer 的核心数据结构以及 Orderer节点的启动流程。</p><p>综上所述，orderer源码解析的知识图谱就呼之欲出了。</p><p><img src="http://note.youdao.com/yws/res/70/WEBRESOURCE94ead357ff1974f130ca9b572e879016" alt="Orderer 知识图谱"></p><p>这张图描绘了 orderer 这块源码我们需要掌握的主要知识点，现在肯定还有很多地方看不懂，不过没关系，有个大致印象就好，等我们把所有的知识点都理一遍再回过头来看这张图，相信会有一种“一览众山小”的感觉。</p><p>接下来，我们就将以这种图为线索，正式开始我们的orderer源码分析之旅。</p>]]></content>
      
      
      <categories>
          
          <category> fabric </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fabric </tag>
            
            <tag> orderer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fabric交易处理流程</title>
      <link href="/2020/07/25/tx-flow/"/>
      <url>/2020/07/25/tx-flow/</url>
      
        <content type="html"><![CDATA[<blockquote><p>fabric 作为目前世界上最为知名的联盟链开源项目，所涉及的模块和概念很多，本文以交易作为一个切入点，通过分析一笔交易从发送到最终上链所经历的各个环节，将fabric的核心模块串联起来，为接下来更为深入的各个模块的源码分析奠定基础。</p></blockquote><p><img src="http://note.youdao.com/yws/res/57/WEBRESOURCE9b612bf71f717be93422441ce1cd1afb" alt="交易流程"></p><blockquote><p>此图来自《Hyperledger Fabric技术内幕 架构设计与实现原理》</p></blockquote><h3 id="1-发送签名提案消息到Endorser背书节点请求处理"><a href="#1-发送签名提案消息到Endorser背书节点请求处理" class="headerlink" title="1. 发送签名提案消息到Endorser背书节点请求处理"></a>1. 发送签名提案消息到Endorser背书节点请求处理</h3><p>Client节点构造签名提案消息<font color="blue">(SignedProposal类型)</font>，通过调用Endorser背书服务客户端的<font color="blue">ProcessProposal()接口</font>，提交该消息到Endorser背书节点，请求模拟执行交易提案并签名背书。</p><h3 id="2-Endorser背书节点模拟执行交易提案并签名背书Endorser背书"><a href="#2-Endorser背书节点模拟执行交易提案并签名背书Endorser背书" class="headerlink" title="2. Endorser背书节点模拟执行交易提案并签名背书Endorser背书"></a>2. Endorser背书节点模拟执行交易提案并签名背书Endorser背书</h3><p>节点收到签名提案消息之后，进行如下处理。</p><ol><li>检查签名提案消息的格式合法性与签名有效性，包括通道头部、签名头部、签名 域、交易ID、消息扩展域的Chaincodeld属性与PayloadVisibility可见性模式等；</li><li>检查提案消息的创建者是否满足指定通道上的通道访问权限，即/Channel/ Application/Writers 写权限；</li><li>检查并启动链码容器以模拟执行交易提案，并将模拟执行结果暂时保存在交易模拟器中，等待排序共识与交易验证，而不是直接更新到账本中。其中，<font color="blue">交易模拟执行结果釆用状态数据读写集（读数据的键和版本、写数据的键值）记录交易造成的状态变更结果；</font></li><li><font color="blue">调用ESCC系统链码对该提案消息的模拟结果读写集等进行签名背书</font>。</li></ol><h3 id="3-Endorser背书节点向客户端返回提案响应消息，并分发隐私数据明文"><a href="#3-Endorser背书节点向客户端返回提案响应消息，并分发隐私数据明文" class="headerlink" title="3. Endorser背书节点向客户端返回提案响应消息，并分发隐私数据明文"></a>3. Endorser背书节点向客户端返回提案响应消息，并分发隐私数据明文</h3><p>Endorser背书节点基于背书信息、模拟执行结果等构造提案响应消息（ProposalResponse 类型），并回复给请求客户端。</p><p>目前，模拟执行结果读写集包含公有数据（包括公共数据与隐私数据哈希值）与私有数据（或隐私数据）。</p><p>其中，公有数据交由0rderer节点进行排序出块，再提交到账本区块 数据文件，并广播到该通道上的所有节点。</p><p>如果模拟执行结果中还存在有效的隐私数据明文，则<font color="blue">Endorser背书节点通过Gossip消息协议将隐私数据发送给通道内授权的其他节点（由隐私数据集合配置的签名策略决定），交由transient隐私数据存储对象暂时保存到本地的transient隐私数据库（LevelDB）,并在提交账本时存储到隐私数据库（LevelDB）,同时清理transient隐私数据库中的过期数据</font>。</p><h3 id="4-处理提案响应消息"><a href="#4-处理提案响应消息" class="headerlink" title="4. 处理提案响应消息"></a>4. 处理提案响应消息</h3><p>Client节点解析Endorser背书节点回复的提案响应消息，获取背书结果并检查提案响应消息状态的合法性，以判断是否收集到了<font color="blue">足够多的符合要求的背书签名信息</font>。</p><h3 id="5-发送交易数据给Orderer服务节点请求排序"><a href="#5-发送交易数据给Orderer服务节点请求排序" class="headerlink" title="5. 发送交易数据给Orderer服务节点请求排序"></a>5. 发送交易数据给Orderer服务节点请求排序</h3><p>当收集到足够多数量的符合要求的Endorser背书签名之后（由背书策略决定），<font color="blue">Client节点基于模拟执行结果、背书签名等构造合法的签名交易消息（Envelope类型），通过Broadcast（）服务接口将该消息提交给Orderer节点</font>，请求交易排序处理。其中，配置交易消 息不需要经过Endorser节点处理。</p><h3 id="6-Orderer服务节点对交易进行排序并构造新区块"><a href="#6-Orderer服务节点对交易进行排序并构造新区块" class="headerlink" title="6. Orderer服务节点对交易进行排序并构造新区块"></a>6. Orderer服务节点对交易进行排序并构造新区块</h3><p>Orderer排序节点<font color="blue">提供Solo类型（用于单节点测试）、Kafka类型（支持CFT容错）等共识组件</font>，对符合通道处理要求的合法交易消息（普通交易消息、配置交易消息等）进行排序并达成一致观点，并对一段时间内接收的一批交易消息按照打包交易的岀块规则（出块周期 时间、区块字节数限制、配置交易单独出块等）构造新区块，创建应用通道或更新通道配置同时提交账本。</p><h3 id="7-Leader主节点请求Orderer服务节点发送通道账本区块"><a href="#7-Leader主节点请求Orderer服务节点发送通道账本区块" class="headerlink" title="7. Leader主节点请求Orderer服务节点发送通道账本区块"></a>7. Leader主节点请求Orderer服务节点发送通道账本区块</h3><p><font color="blue">Leader主节点通过Deliver()服务接口代表组织从Orderer节点请求通道账本上所有的区块数据，并通过Gossip消息协议分发到组织内的其他Peer节点</font>。如果请求的区块数据不 存在，则Orderer节点默认阻塞等待，直到指定区块创建完成并提交账本，再将该区块发送 给Leader主节点。</p><h3 id="8-Committer记账节点验证交易并提交账本"><a href="#8-Committer记账节点验证交易并提交账本" class="headerlink" title="8. Committer记账节点验证交易并提交账本"></a>8. Committer记账节点验证交易并提交账本</h3><p>Committer记账节点对区块与隐私数据（明文）执行如下检查，并提交至本地账本。如果不存在隐私数据明文，则跳过隐私数据的相关检查与提交账本的步骤。</p><ol><li>检查交易消息格式的正确性、签名合法性、交易内容是否篡改、消息头部的合法性等。</li><li><font color="blue">调用VSCC系统链码</font>，验证收集的签名背书结果是否符合指定的背书策略。</li><li>对模拟结果中公有数据（即区块数据，含有公共数据与隐私数据哈希值）的<font color="blue">读写集执行MVCC检查</font>，针对单个键查询、键范围查询、隐私数据哈希值三种情况，检查读数据版本与交易时的账本是否一致，即是否存在读写冲突，并将存在冲突的交易标记为无效交易。</li><li>验证模拟结果中隐私数据的正确性，遍历区块中有效交易的隐私数据读写集哈希值，取岀对应交易的原始隐私数据读写集明文，重新计算其哈希值并对两者进行比较。如果两者完全相同，则说明该交易的隐私数据是真实有效的。</li><li>保存所有的区块数据（即公有数据）到<font color="blue">区块数据文件</font>中，保存所有的私有数据（即隐私数据）读写集到<font color="blue">隐私数据库（LevelDB）</font>中，建立区块索引信息到<font color="blue">区块索引数据库</font>，将最新的有效交易数据（包含公共数据读写集、隐私数据读写集、隐私数据读写集哈希值）更新到<font color="blue">状态数据库</font>，最后将区块数据中经过Endorser背书的有效交易数据同步到<font color="blue">历史数据库</font>。同时，清理<font color="blue">transient隐私数据库中</font>的过期数据。</li></ol><h3 id="9-Leader主节点分发数据与状态同步"><a href="#9-Leader主节点分发数据与状态同步" class="headerlink" title="9. Leader主节点分发数据与状态同步"></a>9. Leader主节点分发数据与状态同步</h3><p>Leader主节点基于<font color="blue">Gossip消息协议</font>将区块数据分发到组织内的其他节点上。同时，<font color="blue">节点之间通过反嫡算法等机制主动拉取缺失的数据</font>（区块数据与隐私数据）、节点身份信息等,以确保组织内所有节点上的账本数据等信息保持同步。</p><h3 id="10-Committer记账节点验证交易并提交账本（同步骤8）"><a href="#10-Committer记账节点验证交易并提交账本（同步骤8）" class="headerlink" title="10. Committer记账节点验证交易并提交账本（同步骤8）"></a>10. Committer记账节点验证交易并提交账本（同步骤8）</h3><p>至此，Hyperledger Fabric系统上的一次完整交易处理流程即告结束。</p><h2 id="预告"><a href="#预告" class="headerlink" title="预告"></a>预告</h2><blockquote><p>从下一篇开始，我们就要正式开启fabric源码分析的专题了，本篇文章其实是一个知识准备。这里多说一句，就是我为什么要开启这个fabric源码分析的专题，其实这件事一直在我心中酝酿，但是由于前一段时间较忙，而且内心总是有一些否定的声音让我陷入自我怀疑，到底要不要做，因为现在网上已经有很多关于fabric源码分析的资料，而且质量也很高，为什么不直接抄“学霸”的作业呢，一定要自己搞一遍，不累吗？其实我是这样想的，“一千个读者就有一千个哈姆雷特”。那么我可不可以这么理解，“一千个开发者就有一千个fabric”。别人关于源码解读的文章都是基于其本人的知识架构下的，而如果我们一定要去灌输到自己的大脑中，可能会有些消化不良。而且我们也不能一味的迷信“权威”，学霸的作业也可能有疏漏的地方，别人的分析都是经过二次加工的产物，带有强烈的主观主义色彩，我们还是应该忠于源码，探索“属于我自己的fabric”。好了，废话有点多，接下来就进入正题吧。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> fabric </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fabric </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go vendor 使用</title>
      <link href="/2020/07/18/govendor/"/>
      <url>/2020/07/18/govendor/</url>
      
        <content type="html"><![CDATA[<blockquote><p>由于最近遇到个项目需要使用 go vendor 进行依赖管理，所以就简单学习了一下</p></blockquote><p>三步走</p><h4 id="第一步："><a href="#第一步：" class="headerlink" title="第一步："></a>第一步：</h4><p>进入项目</p><pre><code>cd [project name]</code></pre><p>执行 </p><pre><code>govendor init</code></pre><p>项目根目录下即会自动生成 vendor 目录和 vendor.json 文件</p><h4 id="第二步："><a href="#第二步：" class="headerlink" title="第二步："></a>第二步：</h4><p>将已被引用且在 $GOPATH 下的所有包复制到 vendor 目录</p><pre><code>govendor add +external</code></pre><h4 id="第三步："><a href="#第三步：" class="headerlink" title="第三步："></a>第三步：</h4><p>拉取所有依赖的包到 vendor 目录(包括 $GOPATH 存在或不存在的包)</p><pre><code>govendor fetch +out</code></pre><h4 id="其他常用命令"><a href="#其他常用命令" class="headerlink" title="其他常用命令"></a>其他常用命令</h4><p>从远程仓库添加或更新某个包(不会在 $GOPATH 也存一份)</p><pre><code>govendor fetch golang.org/x/net/context</code></pre><p>安装指定版本的包</p><pre><code>govendor fetch golang.org/x/net/context@a4bbce9fcae005b22ae5443f6af064d80a6f5a55</code></pre><p>包已在 vendor 目录，但想从 $GOPATH 更新</p><pre><code>govendor update +vendor</code></pre><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://lessisbetter.site/2018/11/17/An-introduction-to-Govendor/" target="_blank" rel="noopener">https://lessisbetter.site/2018/11/17/An-introduction-to-Govendor/</a></p><p><a href="https://shockerli.net/post/go-package-manage-tool-govendor/" target="_blank" rel="noopener">https://shockerli.net/post/go-package-manage-tool-govendor/</a></p>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>向 fabric 贡献代码</title>
      <link href="/2020/07/14/fabric-contribute/"/>
      <url>/2020/07/14/fabric-contribute/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文主要记录了向fabric开源社区贡献代码的过程</p></blockquote><h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><p>进入 fabric目录</p><p>cd fabric</p><h2 id="1-先获取对应分支"><a href="#1-先获取对应分支" class="headerlink" title="1. 先获取对应分支"></a>1. 先获取对应分支</h2><p>git fetch origin [目标分支]</p><h2 id="2-切到对应分支"><a href="#2-切到对应分支" class="headerlink" title="2. 切到对应分支"></a>2. 切到对应分支</h2><p>git checkout -b [目标分支]</p><h2 id="3-更新最新代码（此步骤可省略）"><a href="#3-更新最新代码（此步骤可省略）" class="headerlink" title="3. 更新最新代码（此步骤可省略）"></a>3. 更新最新代码（此步骤可省略）</h2><p>goland -&gt; vcs -&gt; git -&gt; Rebase my Github fork -&gt; 选择原代码仓库</p><p>参考：<a href="https://www.zhihu.com/question/28676261" target="_blank" rel="noopener">https://www.zhihu.com/question/28676261</a></p><p>或者：</p><pre><code>git remote add upstream https://github.com/hyperledger/fabricgit fetch upstreamgit checkout [目标分支]git rebase upstream/[目标分支]git push -f origin [目标分支]</code></pre><h2 id="4-新建一个用于开发的分支"><a href="#4-新建一个用于开发的分支" class="headerlink" title="4. 新建一个用于开发的分支"></a>4. 新建一个用于开发的分支</h2><p>名字格式为 FAB-XXXX （issue序号）</p><p>git checkout -b FAB-XXX</p><h2 id="5-正式干活"><a href="#5-正式干活" class="headerlink" title="5. 正式干活"></a>5. 正式干活</h2><p>愉快滴开发（此处省略一万字）</p><h2 id="6-提交-：-git-commit-a-s"><a href="#6-提交-：-git-commit-a-s" class="headerlink" title="6. 提交 ：$ git commit -a -s"></a>6. 提交 ：$ git commit -a -s</h2><p>-s 选项是用于在commit message中自动生成sign off签名的</p><h2 id="7-编辑commit信息"><a href="#7-编辑commit信息" class="headerlink" title="7. 编辑commit信息"></a>7. 编辑commit信息</h2><pre><code>[FAB-XXXX] &lt;标题,官方文档说本行不能超过72个字符，实测不能超过55个字符&gt;&lt;空行&gt;This fixes #FAB-XXXX&lt;内容：每行不超过80字符，其中应该包括- 你的提交做了什么？- 为何选用这种方式去进行改动- 为何这种改动能够成功，比如提交你成功的代码测试结果&gt;</code></pre><h2 id="8-推送代码"><a href="#8-推送代码" class="headerlink" title="8. 推送代码"></a>8. 推送代码</h2><p>vcs -&gt; git -&gt; push</p><h2 id="9-pull-request"><a href="#9-pull-request" class="headerlink" title="9. pull request"></a>9. pull request</h2><p>登录 github,找到刚刚push的分支，点击 compare and pull request</p><p>注意要推送的目标分支，一般默认是master，这里需要修改为要推送的分支</p><p>确认commit信息没问题后点击右下角 create pull request</p><h2 id="9-等待合并"><a href="#9-等待合并" class="headerlink" title="9.等待合并"></a>9.等待合并</h2><p>会跑一堆测试，所有测试都过了以后经过两个以上的人approve则会被merge</p><h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><h3 id="git-push-ERROR-You-must-verify-your-email-address"><a href="#git-push-ERROR-You-must-verify-your-email-address" class="headerlink" title="git push ERROR: You must verify your email address"></a>git push ERROR: You must verify your email address</h3><p>解决方法：<a href="https://www.jianshu.com/p/30ee5daf1327" target="_blank" rel="noopener">https://www.jianshu.com/p/30ee5daf1327</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://davidkhala.github.io/2017/08/30/fabric-contribute/" target="_blank" rel="noopener">https://davidkhala.github.io/2017/08/30/fabric-contribute/</a></p>]]></content>
      
      
      <categories>
          
          <category> fabric </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fabric </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitLab CICD 自动化部署</title>
      <link href="/2020/07/14/cicd/"/>
      <url>/2020/07/14/cicd/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文简单记录了自学使用GitLab CI进行自动化部署的过程</p></blockquote><h1 id="什么是-CI-CD-流水线？"><a href="#什么是-CI-CD-流水线？" class="headerlink" title="什么是 CI/CD 流水线？"></a>什么是 CI/CD 流水线？</h1><p>CI 代表持续集成（Continuous Integration），CD 代表持续交付（Continuous Delivery）和持续部署（Continuous Deployment）。也可以将它们看作是类似于软件开发生命周期的过程。</p><h4 id="持续集成"><a href="#持续集成" class="headerlink" title="持续集成"></a>持续集成</h4><p>持续集成指在和向远程仓库 push 代码后，在这次提交合并入主分支前进行一系列测试，构建等流程。假设现在有个应用的代码存储在 gitlab 上，每天开发者都 push 很多次提交，针对每次 push，你可以创建一系列脚本进行自动测试，降低往应用里引入错误的概率。这就是持续集成，它可应用在包括开发分支在内的多个分支上。</p><h4 id="持续部署"><a href="#持续部署" class="headerlink" title="持续部署"></a>持续部署</h4><p>持续部署在持续集成的基础上更进一步，指将推送指仓库默认分支的部署至产品环境。如果这部分需要手动触发，这就是一个持续交付（Continuous Delivery）环节</p><p><img src="https://static.geekbang.org/infoq/5cac03c74862e.png?imageView2/0/w/800" alt></p><p>如上图所示，该流水线展示了一个软件在其最终交付给客户或者投入上线之前，它在其生命周期内各个阶段中的移动过程。</p><p>我们可以看到软件从代码完成到最终交付先后会经历构建(build)、单元测试(unit test)、部署(deploy)、自动测试(auto test)、部署到生产环境(deploy to production)以及度量和验证(measure &amp; validate)等多个阶段。</p><p>具体阶段说明请参考 <a href="https://www.infoq.cn/article/WHt0wFMDRrBU-dtkh1Xp" target="_blank" rel="noopener">如何从零开始搭建 CI/CD 流水线</a></p><h1 id="部署方案"><a href="#部署方案" class="headerlink" title="部署方案"></a>部署方案</h1><p>目前与gitlab持续集成的比较流行的自动化部署解决方案主要有jenkins和GitLab CI/CD两种。</p><h2 id="Jenkins"><a href="#Jenkins" class="headerlink" title="Jenkins"></a>Jenkins</h2><p>Jenkins 是一款比较流行的持续化集成自动化工具，为我们提供了各种接口和工具，用以实现软件开发整个过程的自动化。</p><p>如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/20190110163723744.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NkYmRxbjAwMQ==,size_16,color_FFFFFF,t_70" alt></p><p>由客户端将代码push推送到git仓库，gitlab上配置了一个webHook的东西可以触发Jenkins的构建。</p><p>进入到Jenkins虚线范围内，它所做的事情非常多，从mvn构建代码，对代码进行静态分析，做单元测试，测试通过之后就可以build镜像，镜像构建成功后就把镜像push推送到Harbor镜像仓库中。</p><p>镜像push推送到镜像仓库后，我们就可以调用kubernetes集群的restAPI更新服务，而后kubernetes接收到了更新的指令，从Harbor镜像仓库pull拉取镜像，从而完成服务的更新与重启，最后我们从客户端来访问kubernetes集群的服务</p><p><big><strong>优点:</strong> </big> 编译服务和代码仓库分离，而且编译配置文件不需要在工程中配置，如果团队有开发、测试、配置管理员、运维、实施等完整的人员配置，那就采用jenkins，这样职责分明。jenkins依靠它丰富的插件，可以配置很多gitlab-ci不存在的功能，比如说看编译状况统计等。</p><p><big><strong>缺点:</strong> </big> 配置相对复杂，维护成本较高等</p><h2 id="GitLab-CI-CD"><a href="#GitLab-CI-CD" class="headerlink" title="GitLab CI/CD"></a>GitLab CI/CD</h2><p>GitLab CI/CD 是GitLab Continuous Integration（Gitlab持续集成）的简称。GitLab 自GitLab 8.0开始提供了持续集成的功能，且对所有项目默认开启。只要在项目仓库的根目录添加.gitlab-ci.yml文件，并且配置了Runner（运行器），那么每一次push或者合并请求（Merge Request）都会触发CI Pipeline。</p><p>如图所示，可以理解为GitLab CI/CD是Gitlab给开发者提供的一项功能，它在代码提交后自动触发一段开发者自定义的脚本，以此来完成诸如但不限于构建部署的工作。</p><p><img src="https://pic1.zhimg.com/80/v2-a91bb21049a0a797d4092789aa16b808_720w.jpg" alt></p><h3 id="关键概念"><a href="#关键概念" class="headerlink" title="关键概念"></a>关键概念</h3><h4 id="Pipelines"><a href="#Pipelines" class="headerlink" title="Pipelines"></a>Pipelines</h4><p>Pipelines 中文称为流水线，是分阶段执行的构建任务。如：安装依赖、运行测试、打包、部署开发服务器、部署生产服务器等流程。每一次push或者Merge Request都会触发生成一条新的Pipeline</p><h4 id="Stages"><a href="#Stages" class="headerlink" title="Stages"></a>Stages</h4><p>Stages 表示构建阶段，可以理解为上面所说“安装依赖”、“运行测试”等环节的流程。我们可以在一次 Pipeline 中定义多个 Stages，这些 Stages 会有以下特点：</p><ol><li>所有 Stages 会按照顺序运行，即当一个 Stage 完成后，下一个 Stage 才会开始（当然可以在.gitlab-ci.yml文件中配置上一阶段失败时下一阶段也执行）</li><li>只有当所有 Stages 完成后，该构建任务 (Pipeline) 才会成功</li><li>如果任何一个 Stage 失败，那么后面的 Stages 不会执行，该构建任务 (Pipeline) 失败</li></ol><h4 id="Jobs"><a href="#Jobs" class="headerlink" title="Jobs"></a>Jobs</h4><p>Jobs 表示构建的作业（或称之为任务），表示某个 Stage 里面执行的具体任务。我们可以在 Stages 里面定义多个 Jobs，这些 Jobs 会有以下特点：</p><ol><li>相同 Stage 中的 Jobs 无执行顺序要求，会并行执行</li><li>相同 Stage 中的 Jobs 都执行成功时，该 Stage 才会成功</li><li>如果任何一个 Job 失败，那么该 Stage 失败，即该构建任务 (Pipeline) 也失败（可以在.gitlab-ci.yml文件中配置允许某 Job 可以失败，也算该 Stage 成功）</li></ol><p><big> <strong>优点:</strong> </big>完美和gitlab进行集成，gitlab-ci已经集成进gitlab服务器中，在使用的时候只需要安装配置gitlab-runner即可。 gitlab-runner基本上提供了一个可以进行编译的环境，负责从gitlab中拉取代码，根据工程中配置的gitlab-ci.yml，执行相应的命令进行编译。</p><p><big> <strong>缺点:</strong> </big>功能相对少一些，没有web页面查看等</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>由于采用Jenkins进行自动化集成部署较为复杂，GitLab完美和GitLab集成，更为简单和方便，且对于我来说，GitLab CI/CD所提供等功能已足够使用，所以我更偏向于“小而精”的GitLab CI/CD而不是“大而全”的Jenkins。</p><h1 id="GitLab-CI-CD实战"><a href="#GitLab-CI-CD实战" class="headerlink" title="GitLab CI/CD实战"></a>GitLab CI/CD实战</h1><p>说了这么多，相信大家已经迫不及待地跃跃欲试了，下面就介绍一下GitLab CI/CD的使用步骤。</p><p>参考： <a href="http://192.168.9.251/help/ci/quick_start/README" target="_blank" rel="noopener">GitLab CI / CD入门</a></p><p>其实大体来说就两步：</p><ol><li>在项目的根目录下添加一个配置文件 .gitlab-ci.yaml</li><li>配置一个 GitLab Runner</li></ol><h2 id="配置-gitlab-ci-yml"><a href="#配置-gitlab-ci-yml" class="headerlink" title="配置 .gitlab-ci.yml"></a>配置 .gitlab-ci.yml</h2><p>GitLab 中默认开启了 Gitlab CI/CD 的支持，且使用YAML文件.gitlab-ci.yml来管理项目构建配置。该文件需要存放于项目仓库的根目录（默认路径，可在 GitLab 中修改），它定义该项目的 CI/CD 如何配置。所以，我们只需要在.gitlab-ci.yml配置文件中定义流水线的各个阶段，以及各个阶段中的若干作业（任务）即可。</p><p>下面是.gitlab-ci.yml文件的一个简单的Hello World示例：</p><pre><code># 定义 build 和 test 两个 Stages    stages:  - build  - test# 定义 build 阶段的一个 jobbuild_job:  stage: build  script:    - echo &quot;the project is being built&quot;# 定义 test 阶段的一个 jobtest_job:  stage: test  script:    - echo &quot;the project is being built&quot;</code></pre><p>以上配置中，用 stages 关键字来定义 Pipeline 中的各个构建阶段，然后用一些非关键字来定义 jobs。每个 job 中可以可以再用 stage 关键字来指定该 job 对应哪个 stage。job 里面的script关键字是每个 job 中必须要包含的，它表示每个 job 要执行的命令。</p><p>关于.gitlab-ci.yml的详细配置规则可参考官方文档 <a href="https://docs.gitlab.com/ce/ci/yaml/README.html" target="_blank" rel="noopener">GitLab CI/CD pipeline configuration reference</a></p><p>配置完就可以直接 commit &amp; push 这个配置文件了<br>一旦提交了这个 .gitlab-ci.yaml文件，那么下次在任何一次push到gitlab的操作，GitLab都会查找该.gitlab-ci.yml<br>文件并根据该文件的内容在 gitlab Runners上执行jobs。</p><p>此时再查看 CI/CD -&gt; popeline 可以发现会有一条pipeline 处于挂起阶段，这是因为我们没有注册gitlab runner的原因</p><p>导致无法运行 .gitlab-ci.yaml中的jobs，那么下面我们就来安装一下 gitlab runner</p><h2 id="安装GitLab-Runner"><a href="#安装GitLab-Runner" class="headerlink" title="安装GitLab Runner"></a>安装GitLab Runner</h2><p>gitlab runner 用于与git服务器进行通信，当有新的任务发布到当前runner时，runner会执行.gitlab-ci.yml所定义的CI指令。</p><p>如果你的操作系统和我一样是macOS，那么可以采用以下方式进行安装：</p><p>方式一：用homebrew进行安装，在命令行中直接执行</p><pre><code>brew install gitlab-runner</code></pre><p>方式二（官方）：Gitlab runner 10以上安装方式，若安装旧版本前往官网查看<br>（1）下载</p><pre><code>sudo curl --output /usr/local/bin/gitlab-runner https://gitlab-runner-downloads.s3.amazonaws.com/latest/binaries/gitlab-runner-darwin-amd64</code></pre><p>(2)设置权限</p><pre><code>sudo chmod +x /usr/local/bin/gitlab-runner</code></pre><p>其他安装方式可参考 <a href="https://docs.gitlab.com/runner/install/" target="_blank" rel="noopener">Install GitLab Runner</a></p><h2 id="注册-gitlab-runner"><a href="#注册-gitlab-runner" class="headerlink" title="注册 gitlab runner"></a>注册 gitlab runner</h2><p>命令的交互式的过程如下：</p><pre><code>➜  ~ git:(master) ✗ sudo gitlab-runner registerRuntime platform                                    arch=amd64 os=linux pid=17 revision=6fbc7474 version=13.1.1Running in system-mode.# 输入公司的 GitLab 网站地址，可以在 Settings -&gt; CI/CD -&gt; Runner 中找到Please enter the gitlab-ci coordinator URL (e.g. https://gitlab.com/):http://192.168.9.251/# 你项目仓库的token，token可以在 Settings -&gt; CI/CD -&gt; Runner 中找到Please enter the gitlab-ci token for this runner:ienceCevg-sdxqQhBaGZ# 输入描述这个 runner 的名称，这个字段没有特殊的作用，只是为了区分不同的runner，这里可设置为runner-serverPlease enter the gitlab-ci description for this runner:[1b6095f8f875]: runner-server# tags这个属性，job和runner都有，用来匹配任务和执行任务的runner。runner的tag可以有多个，注册时用逗号（comma）分隔即可。当某个job的tag是当前runner tags的一个子集时，这个job就可以被分配到当前runner上执行Please enter the gitlab-ci tags for this runner (comma separated):testRegistering runner... succeeded                     runner=ienceCev# executor就是执行job的环境，通常我们都会选择Shell，如果有其他需要的也可以自行查阅文档。需要注意的是，runner执行的环境是非常干净的，像类似ANDROID_HOME的变量都需要通过shell指令export xxx=xxx在执行时输入，而不是使用设备上的环境。Please enter the executor: docker, shell, ssh, docker+machine, docker-ssh+machine, custom, docker-ssh, parallels, virtualbox, kubernetes:shellRunner registered successfully. Feel free to start it, but if it&#39;s running already the config should be automatically reloaded!</code></pre><p>以上流程注册成功之后，就可以在你的项目仓库中 Settings -&gt; CI/CD -&gt; Runner看到这个 Runner 了。</p><p><img src="https://note.youdao.com/yws/public/resource/bc554143fcca768f52bf1354ffef92eb/xmlnote/EE6BA5A809BA4D5E8DE7A943D7A8EB14/2579?ynotemdtimestamp=1595666133983" alt></p><h2 id="安装共享runner"><a href="#安装共享runner" class="headerlink" title="安装共享runner"></a>安装共享runner</h2><p>安装共享runner与安装专有runner类似，主要区别在于共享runner需要gitlab的管理员权限，进入管理员界面，overview-&gt;runner，将runner的token和URL复制下来，在注册的时候添加进去就可以，此处不再赘述，详细步骤请参考<a href="https://cloud.tencent.com/developer/article/1411267" target="_blank" rel="noopener">此处</a></p><h1 id="GitLab-runner-常用命令"><a href="#GitLab-runner-常用命令" class="headerlink" title="GitLab runner 常用命令"></a>GitLab runner 常用命令</h1><p>下面表格列出了 Gitlab runner 的常用命令：</p><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>gitlab-runner run</td><td>运行一个runner服务</td></tr><tr><td>gitlab-runner register</td><td>注册一个新的runner</td></tr><tr><td>gitlab-runner start</td><td>启动服务</td></tr><tr><td>gitlab-runner stop</td><td>关闭服务</td></tr><tr><td>gitlab-runner restart</td><td>重启服务</td></tr><tr><td>gitlab-runner status</td><td>查看各个runner的状态</td></tr><tr><td>gitlab-runner unregister</td><td>注销掉某个runner</td></tr><tr><td>gitlab-runner list</td><td>显示所有运行着的runner</td></tr><tr><td>gitlab-runner verify</td><td>检查已注册的运行程序是否可以连接到GitLab，但它不验证GitLab Runner服务是否正在使用运行程序。</td></tr></tbody></table><p>更多命令请参考 <a href="https://docs.gitlab.com/runner/commands/README.html" target="_blank" rel="noopener">GitLab Runner commands</a></p><p>此时，再回 gitlab 仓库查看并重新运行之前刮起的pipeline，等待一会儿会发现运行通过了</p><p><img src="https://note.youdao.com/yws/public/resource/bc554143fcca768f52bf1354ffef92eb/xmlnote/6E07FADE32774BABB8735C787120F04B/2601?ynotemdtimestamp=1595666133983" alt="pipeline"></p><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ol><li><p>每次向 gitlab 推送完代码后，会自动触发一条 pipeline，可点击 gitlab 左侧边栏的 CI/ID 进行查看 pipeline 的运行情况。</p><p><img src="https://note.youdao.com/yws/public/resource/bc554143fcca768f52bf1354ffef92eb/xmlnote/221CC727BF154DC8B47E53D732299ED3/3030" alt></p></li><li><p>某些 job 运行失败可能是由于网络问题，比如 gcc 安装和更新失败，此时可点击重试。</p></li><li><p>目前跑完一条完整的 pipeline 需要时间较长， 为了保证开发效率，建议每次完成开发，推送代码前先在本地进行以下检查。</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">go</span> buildgolangci<span class="token operator">-</span>lint run<span class="token keyword">go</span> test <span class="token punctuation">.</span><span class="token operator">/</span><span class="token operator">...</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果存在问题先解决问题，确保没问题之后再向 gitlab 推送代码。</p></li><li><p>目前静态代码检查采用的 golangci-lint 为1.18.0版本，可从<a href="http://192.168.9.251:9000/software" target="_blank" rel="noopener">此处</a>下载。</p></li><li><p>编译镜像成功后会自动将镜像推送到 harbor 镜像仓库，如果有需要可直接从镜像仓库进行<a href="http://192.168.9.8/harbor/projects/17/repositories/crosschain%2Fcrossnet" target="_blank" rel="noopener">拉取</a>。</p></li><li><p>关于 GitLab CI/CD 的更多详细内容请参考<a href="ttps://docs.gitlab.com/ee/ci/" target="_blank" rel="noopener">官方文档</a>。</p></li></ol><h1 id="踩坑指南"><a href="#踩坑指南" class="headerlink" title="踩坑指南"></a>踩坑指南</h1><h2 id="安装-gitlab-runner-失败"><a href="#安装-gitlab-runner-失败" class="headerlink" title="安装 gitlab runner 失败"></a>安装 gitlab runner 失败</h2><p>在实际安装 gitlab runner 的过程中发现采用上面的方式二会特别慢，而采用方式一则在下一步注册 Gitlab Runner的时候会出现如下问题：</p><pre><code>➜  ~ git:(master) ✗ sudo gitlab-runner registerPassword:[1]    37431 killed     sudo gitlab-runner register</code></pre><p>在网上搜寻解决方案未果，于是决定采用docker进行安装，步骤如下：</p><p>执行以下命令创建容器并启动</p><pre><code>docker run -d --name gitlab-runner --restart always -v ~/gitlab-runner/config:/etc/gitlab-runner -v /var/run/docker.sock:/var/run/docker.sock  gitlab/gitlab-runner:latest</code></pre><p>执行完成后可以 docker ps 一下进行查看</p><pre><code>➜  ~ git:(master) ✗ docker psCONTAINER ID        IMAGE                         COMMAND                  CREATED             STATUS              PORTS               NAMES1b6095f8f875        gitlab/gitlab-runner:latest   &quot;/usr/bin/dumb-init …&quot;   5 seconds ago       Up 3 seconds                            gitlab-runner</code></pre><p>然后注册 gitlab runner，只需执行</p><pre><code>docker exec -it 1b6095f8f875 gitlab-runner register</code></pre><p>其中 1b6095f8f875 是上一步执行的返回的 ID</p><h2 id="安装完-gitlab-runner-显示-pipeline-stuck"><a href="#安装完-gitlab-runner-显示-pipeline-stuck" class="headerlink" title="安装完 gitlab runner 显示 pipeline stuck"></a>安装完 gitlab runner 显示 pipeline stuck</h2><ol><li><p>可能是没有设置为忽略tag的原因, 去设置-&gt; CICD界面下将 tag 那个选项打勾就行</p></li><li><p>可能是 gitlab-runner 容器挂掉了, 可以登录gitlab-runner所在服务器执行</p><pre><code>docker restart gitlab-runner</code></pre></li></ol><h2 id="pipeline-运行时报错【Permission-denied】"><a href="#pipeline-运行时报错【Permission-denied】" class="headerlink" title="pipeline 运行时报错【Permission denied】"></a>pipeline 运行时报错【Permission denied】</h2><p><img src="https://note.youdao.com/yws/public/resource/bc554143fcca768f52bf1354ffef92eb/xmlnote/C512459EDB3A41A7938D5DB227C26E61/2630?ynotemdtimestamp=1595666133983" alt></p><p>在跑 CICD的时候发现以上错误，一开始以为是权限的问题，但是加了dudo依然未能解决，后来通过复盘 gitlab runner安装、注册等全过程，发现在安装gitlab是采用的docker模式，但是注册gitlab时指定的运行环境是shell，于是换成了docker，重新跑了一下，原来的错误消失了</p><p>PS: 指定执行环境是docker后，还需指定 docker image 为 stable, 如下：</p><pre><code>Please enter the executor: virtualbox, docker+machine, docker-ssh, shell, parallels, ssh, docker-ssh+machine, kubernetes, custom, docker:dockerPlease enter the default Docker image (e.g. ruby:2.6):docker:stable</code></pre><h2 id="运行-docker-命令报错"><a href="#运行-docker-命令报错" class="headerlink" title="运行 docker 命令报错"></a>运行 docker 命令报错</h2><p>运行docker info命令时报错</p><p><img src="https://note.youdao.com/yws/public/resource/bc554143fcca768f52bf1354ffef92eb/xmlnote/5308331A5FF94826A5BFB66F128CF7CF/2644?ynotemdtimestamp=1595666133983" alt></p><p>查找资料<br><a href="https://gitlab.com/gitlab-org/gitlab-runner/-/issues/4566" target="_blank" rel="noopener">https://gitlab.com/gitlab-org/gitlab-runner/-/issues/4566</a></p><p>修改配置文件</p><pre><code>vim gitlab-runner/config/config.toml</code></pre><p>volumes 配置项</p><pre><code>volumes = [&quot;/cache&quot;, &quot;/var/run/docker.sock:/var/run/docker.sock&quot;]</code></pre><p>重新启动 gitlab runner </p><pre><code>docker restart 99451b349e7f</code></pre><p>其中 99451b349e7f 为容器ID</p><p>再重新跑pipeline，发现原来的错误消失了</p><h2 id="执行shell脚本报错"><a href="#执行shell脚本报错" class="headerlink" title="执行shell脚本报错"></a>执行shell脚本报错</h2><p><img src="https://note.youdao.com/yws/public/resource/bc554143fcca768f52bf1354ffef92eb/xmlnote/3B9F8F27F2A049CD92C6C92BB1A35B19/2664?ynotemdtimestamp=1595666133983" alt></p><p>通过搜寻资料发现</p><p>请注意，docker镜像是基于alpine的，默认不提供bash。<br>所以脚本应该使用sh，以便更加通用。</p><p>改成如下格式后经过测试通过</p><pre><code>sh scripts/fmt.sh</code></pre><h2 id="curl命令未找到-【curl-not-found】"><a href="#curl命令未找到-【curl-not-found】" class="headerlink" title="curl命令未找到 【curl: not found】"></a>curl命令未找到 【curl: not found】</h2><p><img src="https://note.youdao.com/yws/public/resource/bc554143fcca768f52bf1354ffef92eb/xmlnote/24C3D0434AB147BC80AE067140047D01/2671?ynotemdtimestamp=1595666133983" alt></p><p>搜寻资料<a href="https://stackoverflow.com/questions/46031069/curl-command-not-found-on-gitlab-ci-yml" target="_blank" rel="noopener">curl command not found on .gitlab-ci.yml</a></p><p>使用apk命令下载 curl 命令，而不是 apt-get</p><pre><code>services:  - name: docker:dind  before_script:    - apk add --update curl &amp;&amp; rm -rf /var/cache/apk/*</code></pre><h2 id="编译报错-not-found"><a href="#编译报错-not-found" class="headerlink" title="编译报错 not found"></a>编译报错 not found</h2><p>参考<br><a href="https://www.dyxmq.cn/uncategorized/installed-go-binary-not-found-in-path-on-alpine-linux-docker.html" target="_blank" rel="noopener">https://www.dyxmq.cn/uncategorized/installed-go-binary-not-found-in-path-on-alpine-linux-docker.html</a></p><p>编译时添加参数CGO_ENABLED=0</p><pre><code>CGO_ENABLED=0 go build</code></pre><h2 id="安装-go-环境失败"><a href="#安装-go-环境失败" class="headerlink" title="安装 go 环境失败"></a>安装 go 环境失败</h2><p>下载了 go 的安装包且配置好了 GOROOT 和 GOPATH 等，但执行 go version 依旧报错</p><p><img src="https://note.youdao.com/yws/public/resource/bc554143fcca768f52bf1354ffef92eb/xmlnote/F3FF604F026B45F38A44D48691D10B37/2694?ynotemdtimestamp=1595666133983" alt></p><p>查找资料<br><a href="https://stackoverflow.com/questions/34729748/installed-go-binary-not-found-in-path-on-alpine-linux-docker" target="_blank" rel="noopener">https://stackoverflow.com/questions/34729748/installed-go-binary-not-found-in-path-on-alpine-linux-docker</a></p><p>执行以下命令修复丢失的依赖项，解决</p><pre><code>mkdir /lib64 &amp;&amp; ln -s /lib/libc.musl-x86_64.so.1 /lib64/ld-linux-x86-64.so.2</code></pre><h2 id="执行-golangci-lint-run-报错：DecodeRuneInString-not-declared-by-package-utf8-typecheck"><a href="#执行-golangci-lint-run-报错：DecodeRuneInString-not-declared-by-package-utf8-typecheck" class="headerlink" title="执行 golangci-lint run 报错：DecodeRuneInString not declared by package utf8 (typecheck)"></a>执行 golangci-lint run 报错：DecodeRuneInString not declared by package utf8 (typecheck)</h2><p><a href="https://github.com/golangci/golangci-lint/issues/658" target="_blank" rel="noopener">https://github.com/golangci/golangci-lint/issues/658</a></p><p>替换 golangci-lint 版本由 v1.16.0 为 v1.18.0 解决问题</p><h2 id="跑-golangci-lint-报错【could-not-import-C-no-metadata-for-C-typecheck-】"><a href="#跑-golangci-lint-报错【could-not-import-C-no-metadata-for-C-typecheck-】" class="headerlink" title="跑 golangci-lint 报错【could not import C (no metadata for C) (typecheck)】"></a>跑 golangci-lint 报错【could not import C (no metadata for C) (typecheck)】</h2><p><img src="https://note.youdao.com/yws/public/resource/bc554143fcca768f52bf1354ffef92eb/xmlnote/7617F64AB4A84C01813E6514C27128CB/2882?ynotemdtimestamp=1595666133983" alt></p><p>搜索资料</p><p><a href="https://github.com/golangci/golangci-lint/issues/602" target="_blank" rel="noopener">https://github.com/golangci/golangci-lint/issues/602</a></p><p>需要安装 gcc，但由于 alpine-linux 环境不支持 apt-get 命令，只能用 apk 安装 gcc </p><p><a href="https://www.jianshu.com/p/30fa6448bb63" target="_blank" rel="noopener">https://www.jianshu.com/p/30fa6448bb63</a></p><p>alpine默认的安装源慢得要命</p><p>通过修改源加快安装速度</p><pre><code>echo &quot;https://mirror.tuna.tsinghua.edu.cn/alpine/v3.8/main&quot; &gt; /etc/apk/repositoriesecho &quot;https://mirror.tuna.tsinghua.edu.cn/alpine/v3.8/community&quot; &gt;&gt; /etc/apk/repositories</code></pre><p>然后再安装 gcc</p><pre><code>apk add build-base</code></pre><h2 id="跑-golangci-lint-遇到-【no-go-files-to-analyze】问题"><a href="#跑-golangci-lint-遇到-【no-go-files-to-analyze】问题" class="headerlink" title="跑 golangci-lint 遇到 【no go files to analyze】问题"></a>跑 golangci-lint 遇到 【no go files to analyze】问题</h2><p><img src="https://note.youdao.com/yws/public/resource/bc554143fcca768f52bf1354ffef92eb/xmlnote/B8CDA49BABF54CC093121CC9C0E92F51/2897?ynotemdtimestamp=1595666133983" alt></p><p>说明少了对应的包，需要去导入包</p><h1 id="gitlab-ci-yaml-样例"><a href="#gitlab-ci-yaml-样例" class="headerlink" title=".gitlab-ci.yaml 样例"></a>.gitlab-ci.yaml 样例</h1><pre><code>variables:  REGISTRY_USER: admin  REGISTRY_PASSWORD: yunphant  REGISTRY_ADDR: 192.168.9.8:80  TARGET_IMAGE: $REGISTRY_ADDR/$ORG_DIR/$PROJECT_DIR:latest  GOROOT: /home/centos/go  GOPATH: /home/centos/gopath  ORG_DIR: crosschain  PROJECT_DIR: crossnetbefore_script:#  - echo &quot;更换源&quot;  - echo &quot;https://mirror.tuna.tsinghua.edu.cn/alpine/v3.8/main&quot; &gt; /etc/apk/repositories  - echo &quot;https://mirror.tuna.tsinghua.edu.cn/alpine/v3.8/community&quot; &gt;&gt; /etc/apk/repositories#  - echo &quot;安装go环境&quot;  - mkdir -p $GOROOT  - mkdir -p $GOPATH  - tar -C /home/centos -zxvf ./util/go1.13.4.linux-amd64.tar.gz  - touch .bash_profile  - echo &#39;export GOROOT=/home/centos/go&#39;&gt;&gt;.bash_profile  - echo &#39;export GOPATH=/home/centos/gopath&#39;&gt;&gt;.bash_profile  - echo &#39;export PATH=$PATH:$GOPATH:$GOROOT/bin&#39;&gt;&gt;.bash_profile  - source .bash_profile#  - echo &quot;修复丢失的依赖项&quot;  - mkdir /lib64 &amp;&amp; ln -s /lib/libc.musl-x86_64.so.1 /lib64/ld-linux-x86-64.so.2  - go version#  - echo &quot;go环境安装完成&quot;#  - echo &quot;安装beego环境&quot;  - mkdir -p $GOPATH/src/github.com  - tar -xvf ./util/astaxie.tar.gz -C $GOPATH/src/github.com  - tar -xvf ./util/bee_1.10.0_linux_amd64.tar.gz#  - echo &quot;beego环境安装完成&quot;#  - echo &quot;设置工作目录&quot;  - WORK_DIR=&quot;$GOPATH/src/$ORG_DIR&quot;  - mkdir -p $WORK_DIR#  - echo &quot;将工作目录链接到当前目录&quot;  - ln -sfv &quot;$(pwd -P)&quot; &quot;$WORK_DIR&quot;#  - echo &quot;进入工作目录&quot;  - cd &quot;$WORK_DIR/$PROJECT_DIR&quot;stages:  - build  - lint  - test  - build_image  - push_image  - deploybuild:  stage: build  script:#    - echo &quot;构建项目&quot;    - CGO_ENABLED=0 go build#    - echo &quot;构建完成&quot;  allow_failure: truelint:  stage: lint  script:    #安装gcc    - apk update &amp;&amp; apk add gcc g++#    - echo &quot;安装 goalangci-lint 工具&quot;    - tar zxvf ./util/golangci-lint-1.18.0-linux-amd64.tar.gz -C /tmp/ &amp;&amp; cp  /tmp/golangci-lint-1.18.0-linux-amd64/golangci-lint $GOPATH/golangci-lint    - rm -rf /tmp/golangci-lint-1.18.0-linux-amd64 &amp;&amp; rm -rf /tmo/golangci-lint-1.18.0-linux-amd64.tar.gz#    - echo &quot;执行 golangci-lint 代码检查&quot;    - GL_DEBUG=linters_output GOPACKAGESPRINTGOLISTERRORS=1 golangci-lint run#    - echo &quot;golangci-lint 代码检查完成&quot;  allow_failure: truetest:  stage: test  script:    #安装gcc    - apk update &amp;&amp; apk add gcc g++#    - echo &quot;运行单元测试&quot;    - CGO_LDFLAGS_ALLOW=.* CGO_CFLAGS_ALLOW=.* go test ./... -v#    - echo &quot;单元测试通过&quot;  allow_failure: truebuild_image:  stage: build_image  script:#    - echo &quot;构建镜像&quot;    - docker build -t $TARGET_IMAGE .#    - echo &quot;镜像构建完成&quot;  allow_failure: truepush_image:  stage: push_image  script:#    - echo &quot;推送镜像到镜像仓库&quot;    - docker login -u $REGISTRY_USER -p $REGISTRY_PASSWORD $REGISTRY_ADDR    - docker push $TARGET_IMAGE#    - echo &quot;镜像推送完成&quot;  allow_failure: truedeploy:  stage: deploy  script:#    - echo &quot;开始部署&quot;#    - echo &quot;删除原有容器&quot;    - docker stop $CI_PROJECT_NAME    - docker rm $CI_PROJECT_NAME#    - echo &quot;启动容器&quot;    - docker run --name $CI_PROJECT_NAME -p 8080:8080  -v /home/centos/gopath/src/$ORG_DIR/$CI_PROJECT_NAME:/var/ $TARGET_IMAGE#    - echo &quot;部署成功&quot;  allow_failure: true</code></pre><h1 id="Dockerfile-样例"><a href="#Dockerfile-样例" class="headerlink" title="Dockerfile 样例"></a>Dockerfile 样例</h1><pre><code># 使用Go的官方镜像作为基础镜像FROM golang:1.12-alpineMAINTAINER xiongweigang xiongwg@yunphant.com# 设置环境变量ENV GOROOT=/usr/local/goENV GOPATH $HOME/goENV PATH $PATH:$GOPATH/binENV GOPROXY https://goproxy.cn,direct# 设置工作目录RUN mkdir -p /go/src/crosschain/crossnetRUN mkdir -p /go/src/github.comWORKDIR /go/src/crosschain/crossnet# 拷贝Dockerfile同级目录的所有文件到docker中的指定位置ADD ./ /go/src/crosschain/crossnet# 拷贝bee可执行命令到docker中的指定位置COPY ./bee_1.10.0_linux_amd64/bee /usr/local/go/bin/COPY ./bee_1.10.0_linux_amd64/bee $GOPATH/bin/# 安装beego源码RUN tar -xvf ./util/astaxie.tar.gz -C /go/src/github.com# 通过开放容器的8080端口暴露该应用程序EXPOSE 8080# 使用bee命令开始对应用程序进行实时重载CMD [&quot;bee&quot;, &quot;run&quot;]</code></pre><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://www.infoq.cn/article/WHt0wFMDRrBU-dtkh1Xp" target="_blank" rel="noopener">如何从零开始搭建 CI/CD 流水线</a></li><li><a href="https://docs.gitlab.com/ee/ci/" target="_blank" rel="noopener">GitLab CI/CD官方文档</a></li><li><a href="https://developer.aliyun.com/article/754508" target="_blank" rel="noopener">GitLab+Docker搭建CI/CD自动化部署</a></li><li><a href="https://www.cnblogs.com/jingtyu/p/9604317.html" target="_blank" rel="noopener">自动化部署方案CICD</a></li><li><a href="https://zhuanlan.zhihu.com/p/51163261" target="_blank" rel="noopener">Gitlab CI&amp;CD 实战经验分享</a></li><li><a href="https://blinkfox.github.io/2018/11/22/ruan-jian-gong-ju/devops/gitlab-ci-jie-shao-he-shi-yong/#alipay" target="_blank" rel="noopener">GitLab CI/CD 介绍和使用</a></li><li><a href="https://blog.csdn.net/qq_33591903/article/details/102460774" target="_blank" rel="noopener">浅谈CICD持续集成、持续部署的流程</a></li><li><a href="https://www.jianshu.com/p/30e3f2940078" target="_blank" rel="noopener">gitlab-ci的简易入门——runners</a></li><li><a href="https://juejin.im/post/5e741a5a518825490e4582b7" target="_blank" rel="noopener">GitLab CI/CD 自动部署构建</a></li><li><a href="https://cloud.tencent.com/developer/article/1411267" target="_blank" rel="noopener">Gitlab的第一个shared Runners配置(shared类型)</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> GitLab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GitLab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fabric国密改造全记录</title>
      <link href="/2020/06/29/fabric-gm/"/>
      <url>/2020/06/29/fabric-gm/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><blockquote><p>最近应公司项目需求，需要对fabric中的加密相关模块进行改造，主要目的是使fabric底层加密服务支持国密算法sm2、sm3以及sm4等。借这次机会，顺便熟悉一下fabric加密模块的源码实现，故此处简单记录了国密改造的整个过程。</p></blockquote><p>fabric tag: 1.4.1</p><h1 id="国密改造整体方案"><a href="#国密改造整体方案" class="headerlink" title="国密改造整体方案"></a>国密改造整体方案</h1><p>msp是基于数字证书的成员身份管理，会调用bccsp即证书服务完成签名验签等功能。Fabric提供国密算法服务，需要同时使用基于国密的数字证书服务，以便使用数字证书时，能验证国密的数字签名，辨别用户身份。</p><p>bccsp模块对上层抽象出了区块链密码服务，包含非对称加密、对称加密、数字签名算法、摘要计算，以及各种算法对于的密钥生成和导入。不同的加密算法需要实现bccsp中定义的接口，以向上层提供加密服务。目前，bccsp中支持标准加密的软实现和标准加密的硬实现。提供国密算法服务，就需要国密算法实现，实现bccsp模块中定义的接口。</p><p>设计gm接口实现国密库的可插拔，实现使用不同的国密库的目的，利用gm接口实现bccsp中的国密插件，在底层国密库更换时，国密插件和Fabric上层模块无需修改。</p><p>为每一个国密实现都进行一次封装，形成各自的gm adapter，满足gm接口。国密实现可以是C语言的动态链接库，可以是Go语言模块，甚至可以是基于加密机提供的RPC加密服务接口。</p><p>设计证书接口实现证书库的可插拔，实现使用不同证书库的目的。利用证书接口实现证书操作函数，fabric中所有证书操作，都调用封装的证书函数，在使用不同证书库时，fabric上层模块无需再适配证书库。</p><p>为每一个证书库都进行一次封装，形成各自的x509 cert adapter，为了让Fabric同时支持国密和标准加密，需要封装Go标准库中的证书操作，以及国密证书库，形成2个不同的插件。</p><h2 id="准备工作："><a href="#准备工作：" class="headerlink" title="准备工作："></a>准备工作：</h2><p>确定 base 分支</p><p>熟悉底层加密实现库</p><ol><li>C 语言的动态链接库</li><li>Go 语言实现</li><li>加密机提供的RPC加密服务接口</li></ol><h2 id="模块拆分"><a href="#模块拆分" class="headerlink" title="模块拆分"></a>模块拆分</h2><p>先来总体看一下fabric进行国密改造会涉及到的主要模块</p><p><img src="https://note.youdao.com/yws/public/resource/bc554143fcca768f52bf1354ffef92eb/xmlnote/3E3D017CD00644C7996D647489EEC663/2789" alt></p><p>如图所示，从上往下，首先是上层调用模块，这一块主要是msp等模块，为fabric提供成员加密服务，它的实现依赖于BCCSP模块和X509模块。</p><p>我们先看右边，BCCSP模块主要是实现四套接口，分别是BCCSP接口、opts接口、key接口以及keystore接口，其中以BCCSP接口为主，它包含了加解密、签名验签等主要方法，其他三套接口为辅，主要包含了用于密钥管理和存储的一些方法。</p><p>接着往下，BCCSP模块有两套实现，一套是标准加密，它直接依赖于Go SDK原生的加密库，另一套是国密实现，需要依赖于第三方的提供的底层加密库，分为硬实现和软实现，其中硬实现就是加密机，软实现现在主要有G语言实现和C语言动态链接库实现两种。</p><p>考虑到fabric定义的BCCSP接口并不直接兼容于第三方提供的加密接口，因此需要做一个国密适配器，主要用于适配上层的BCCSP模块和底层的第三方加密库，这个国密适配器主要包含了SM2、SM3以及SM4三种国密算法的适配。</p><p>然后我们看一下左边，X509模块主要提供的是有关证书的一系列方法。在这里fabric原先默认是使用标准X509的，底层直接调用的是Go SDK 原生的加密库。为了让X509支持国密的同时也兼容标准加密，这里我们就把证书相关的接口抽象出来，定义为X509接口。然后底层采用两套实现，标准加密和非国密实现，标准加密依旧是直接调用原生Go SDK标准加密库，而国密则是调用第三方的国密库。</p><p>需要说明的是，在调用BCCSP模块的加密服务时，如果选择国密算法，需要加载一个国密的插件，而如果是标准加密，则不需要加密国密插件；在调用X509模块的证书服务时，不管是国密X509证书还是标准X509证书均需要加密X509插件。具体选择国密还是标准加密算法可通在orderer、peer和cli的配置文件中的配置项进行指定。</p><h2 id="方法和接口一览"><a href="#方法和接口一览" class="headerlink" title="方法和接口一览"></a>方法和接口一览</h2><p>上面已经把fabirc国密改造整体涉及到的模块简单介绍了一下，下面我通过们一张图来看一下这些模块具体涉及到的接口和方法以及代码的调用逻辑等。</p><p><img src="https://note.youdao.com/yws/public/resource/bc554143fcca768f52bf1354ffef92eb/xmlnote/B8EC91CB622344C489F0A422E3EDA655/2835?ynotemdtimestamp=1595668120966" alt></p><h5 id="高清大图请戳这里"><a href="#高清大图请戳这里" class="headerlink" title="高清大图请戳这里"></a>高清大图请戳<a href="http://www.xmind.net/m/AimcSi" target="_blank" rel="noopener">这里</a></h5><h1 id="fabric-ca-国密改造"><a href="#fabric-ca-国密改造" class="headerlink" title="fabric ca 国密改造"></a>fabric ca 国密改造</h1><p>Fabric-ca国密支持改造，主要是指Fabric-ca端通过改造使其可以用以生成国密公私钥对、签发、吊销、查询国密类型的证书。证书申请和签发的流程如下图所示，所有改造工作都围绕证书申请和签发的流程展开的：</p><p><img src="https://note.youdao.com/yws/public/resource/bc554143fcca768f52bf1354ffef92eb/xmlnote/E0AD1345011E4AA194EDAB95D1A4DAE3/2719?ynotemdtimestamp=1595668120966" alt></p><p>Fabric-ca主要是调用Fabric的bccsp(blockchain cryptographic service provider,区块链加密服务提供者)模块来完成加解密及签名验签的工作。</p><p>Fabric-ca client端主要负责国密证书的请求签发以及存储国密证书链的工作。对于请求国密证书，client端首先生成国密的公私钥对，并把公钥编码到生成证书的请求中，发送生成国密证书的请求给Fabric-ca的server端。存储国密的证书链则需要使用支持国密适配的x509来解析证书，并写入到client端本地路径中。</p><p>Fabric-ca server端主要负责国密证书的签发、吊销、查询等功能。启动时加载自身的国密证书。在接收到签发请求时，调用国密的签名方法来对证书请求进行签名，并返回国密证书给client端。</p><h2 id="改造要点："><a href="#改造要点：" class="headerlink" title="改造要点："></a>改造要点：</h2><ol><li>Fabric-ca/lib：主要是接口的实现，主要在解析申请证书请求以及签发证书流程要替换为国密算法；</li><li>Fabric-ca/util：该包数据工具类，主要在证书的编解码等操作中扩展国密算法；</li><li>Fabric-ca/vendor：因为CA沿用Fabric中的BCCSP套件，所以需要替换对Fabric的包的引用，提供对国密算法的支持。</li></ol><h2 id="具体接口和方法一览"><a href="#具体接口和方法一览" class="headerlink" title="具体接口和方法一览"></a>具体接口和方法一览</h2><p><img src="https://note.youdao.com/yws/public/resource/bc554143fcca768f52bf1354ffef92eb/xmlnote/CD117F2C191D48BBB9C23028B1CAE41F/2875?ynotemdtimestamp=1595668120966" alt></p><h5 id="高清大图请戳这里-1"><a href="#高清大图请戳这里-1" class="headerlink" title="高清大图请戳这里"></a>高清大图请戳<a href="http://www.xmind.net/m/DpWJni" target="_blank" rel="noopener">这里</a></h5><h1 id="fabric-sdk-国密改造"><a href="#fabric-sdk-国密改造" class="headerlink" title="fabric sdk 国密改造"></a>fabric sdk 国密改造</h1><p>未完待续……</p>]]></content>
      
      
      <categories>
          
          <category> fabric </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fabric </tag>
            
            <tag> 密码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GoLand 类图生成工具 plantuml</title>
      <link href="/2020/06/29/plantuml/"/>
      <url>/2020/06/29/plantuml/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文介绍了如何使用 plantuml 工具自动生成Go项目的类图</p></blockquote><h2 id="克隆项目"><a href="#克隆项目" class="headerlink" title="克隆项目"></a>克隆项目</h2><p>在gopath路径下</p><pre><code>git clone git.oschina.net/jscode/go-package-plantuml</code></pre><h2 id="进入项目"><a href="#进入项目" class="headerlink" title="进入项目"></a>进入项目</h2><pre><code>go build</code></pre><p>在 GOPATH/bin 生成一个 二进制文件 plantuml</p><h2 id="用GoLand打开项目，终端输入生成类图命令"><a href="#用GoLand打开项目，终端输入生成类图命令" class="headerlink" title="用GoLand打开项目，终端输入生成类图命令"></a>用GoLand打开项目，终端输入生成类图命令</h2><pre><code>~/go/bin/go-package-plantuml --codedir /Users/xiongweigang/go/src/github.com/wasabi/backEnd --gopath /Users/xiongweigang/go --outputfile /tmp/uml.txt --ignoredir /Users/xiongweigang/go/src/github.com/wasabi/backEnd/vendor</code></pre><h2 id="生成png图片"><a href="#生成png图片" class="headerlink" title="生成png图片"></a>生成png图片</h2><pre><code>java -jar ～/plantuml.jar -verbose -graphvizdot /usr/local/bin/dot /tmp/uml.txt</code></pre><h2 id="生成svg图片-后边加上-tsvg"><a href="#生成svg图片-后边加上-tsvg" class="headerlink" title="生成svg图片 后边加上 -tsvg"></a>生成svg图片 后边加上 -tsvg</h2><pre><code>java -jar ～/plantuml.jar -verbose -graphvizdot /usr/local/bin/dot /tmp/uml.txt -tsvg</code></pre><p>生成后用浏览器打开</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/dwjpeng2/article/details/81667214" target="_blank" rel="noopener">https://blog.csdn.net/dwjpeng2/article/details/81667214</a></p><p><a href="https://yougg.github.io/2017/11/25/goland%E4%B8%AD%E4%BD%BF%E7%94%A8plantuml%E7%94%9F%E6%88%90go-uml%E5%9B%BE/" target="_blank" rel="noopener">https://yougg.github.io/2017/11/25/goland%E4%B8%AD%E4%BD%BF%E7%94%A8plantuml%E7%94%9F%E6%88%90go-uml%E5%9B%BE/</a></p><p><a href="https://juejin.im/post/5da9c00de51d4524cd3b3942" target="_blank" rel="noopener">https://juejin.im/post/5da9c00de51d4524cd3b3942</a></p><p><a href="https://studygolang.com/articles/9719" target="_blank" rel="noopener">https://studygolang.com/articles/9719</a></p>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fabric多机部署（raft共识）</title>
      <link href="/2020/06/21/fabric-deploy-raft/"/>
      <url>/2020/06/21/fabric-deploy-raft/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文介绍了如何搭建一个多机多节点的fabric区块链网络的过程，希望能为小伙伴提供帮助。</p></blockquote><h1 id="fabric多机部署-（raft共识）"><a href="#fabric多机部署-（raft共识）" class="headerlink" title="fabric多机部署 （raft共识）"></a>fabric多机部署 （raft共识）</h1><h2 id="0-准备工作"><a href="#0-准备工作" class="headerlink" title="0. 准备工作"></a>0. 准备工作</h2><h4 id="克隆项目"><a href="#克隆项目" class="headerlink" title="克隆项目"></a>克隆项目</h4><pre><code>git clone git@192.168.9.251:jilg/deployFabric_Raft.git</code></pre><h4 id="节点分配"><a href="#节点分配" class="headerlink" title="节点分配"></a>节点分配</h4><table><thead><tr><th>主机1</th><th>主机 2</th></tr></thead><tbody><tr><td>Org1 peer0 1</td><td>Org2 peer 0 1</td></tr><tr><td>Orderer 0 1 2</td><td>Orderer 0 1</td></tr></tbody></table><br>下面的步骤先在一台主机上操作<h2 id="1-修改证书，创始区块配置文件"><a href="#1-修改证书，创始区块配置文件" class="headerlink" title="1. 修改证书，创始区块配置文件"></a>1. 修改证书，创始区块配置文件</h2><p>先删除原有配置</p><pre><code>rm -rf crypto-configrm -rf channel-artifacts</code></pre><h4 id="crypto-config-yaml"><a href="#crypto-config-yaml" class="headerlink" title="crypto-config.yaml"></a>crypto-config.yaml</h4><pre><code>PeerOrgs:  - Name: Org1    Domain: org1.example.com    EnableNodeOUs: true    Template:      Count: 2    Users:      Count: 1    Specs:      - Hostname: orderer0      - Hostname: orderer1      - Hostname: orderer2  - Name: Org2    Domain: org2.example.com    EnableNodeOUs: true    Template:      Count: 2    Users:      Count: 1    Specs:      - Hostname: orderer0      - Hostname: orderer1</code></pre><h4 id="configtx-yaml"><a href="#configtx-yaml" class="headerlink" title="configtx.yaml"></a>configtx.yaml</h4><pre><code>SampleMultiNodeEtcdRaft:        &lt;&lt;: *ChannelDefaults        Capabilities:            &lt;&lt;: *ChannelCapabilities        Orderer:            &lt;&lt;: *OrdererDefaults            OrdererType: etcdraft            EtcdRaft:                Consenters:                - Host: orderer0.org1.example.com                  Port: 7050                  ClientTLSCert: crypto-config/peerOrganizations/org1.example.com/peers/orderer0.org1.example.com/tls/server.crt                  ServerTLSCert: crypto-config/peerOrganizations/org1.example.com/peers/orderer0.org1.example.com/tls/server.crt                - Host: orderer1.org1.example.com                  Port: 8050                  ClientTLSCert: crypto-config/peerOrganizations/org1.example.com/peers/orderer1.org1.example.com/tls/server.crt                  ServerTLSCert: crypto-config/peerOrganizations/org1.example.com/peers/orderer1.org1.example.com/tls/server.crt                - Host: orderer2.org1.example.com                  Port: 9050                  ClientTLSCert: crypto-config/peerOrganizations/org1.example.com/peers/orderer2.org1.example.com/tls/server.crt                  ServerTLSCert: crypto-config/peerOrganizations/org1.example.com/peers/orderer2.org1.example.com/tls/server.crt                - Host: orderer0.org2.example.com                  Port: 7050                  ClientTLSCert: crypto-config/peerOrganizations/org2.example.com/peers/orderer0.org2.example.com/tls/server.crt                  ServerTLSCert: crypto-config/peerOrganizations/org2.example.com/peers/orderer0.org2.example.com/tls/server.crt                - Host: orderer1.org2.example.com                  Port: 8050                  ClientTLSCert: crypto-config/peerOrganizations/org2.example.com/peers/orderer1.org2.example.com/tls/server.crt                  ServerTLSCert: crypto-config/peerOrganizations/org2.example.com/peers/orderer1.org2.example.com/tls/server.crt            Addresses:                - orderer0.org1.example.com:7050                - orderer1.org1.example.com:8050                - orderer2.org1.example.com:9050                - orderer0.org2.example.com:7050                - orderer1.org2.example.com:8050            Organizations:            - *Org1            - *Org2            Capabilities:                &lt;&lt;: *OrdererCapabilities        Application:            &lt;&lt;: *ApplicationDefaults            Organizations:            - &lt;&lt;: *Org1            - &lt;&lt;: *Org2        Consortiums:            SampleConsortium:                Organizations:                - *Org1                - *Org2</code></pre><p>1、生成公私钥和证书</p><pre><code>../bin/cryptogen generate --config=./crypto-config.yaml </code></pre><p>2、生成创世区块</p><pre><code>../bin/configtxgen -profile SampleMultiNodeEtcdRaft -outputBlock ./channel-artifacts/genesis.block</code></pre><p>3、生成Channel配置区块</p><pre><code>../bin/configtxgen -profile TwoOrgsChannel -outputCreateChannelTx ./channel-artifacts/channel.tx -channelID mychannel </code></pre><p>4、更新锚节点</p><pre><code>../bin/configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org1MSPanchors.tx -channelID mychannel -asOrg Org1MSP../bin/configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org2MSPanchors.tx -channelID mychannel -asOrg Org2MSP</code></pre><h2 id="3-修改peer配置"><a href="#3-修改peer配置" class="headerlink" title="3. 修改peer配置"></a>3. 修改peer配置</h2><h4 id="docker-compose-base-yaml"><a href="#docker-compose-base-yaml" class="headerlink" title="docker-compose-base.yaml"></a>docker-compose-base.yaml</h4><pre><code># Copyright IBM Corp. All Rights Reserved.## SPDX-License-Identifier: Apache-2.0#version: &#39;2&#39;services:  orderer.example.com:    container_name: orderer.example.com    extends:      file: peer-base.yaml      service: orderer-base    volumes:        - ../channel-artifacts/genesis.block:/var/hyperledger/orderer/orderer.genesis.block        - ../crypto-config/ordererOrganizations/example.com/orderers/orderer.example.com/msp:/var/hyperledger/orderer/msp        - ../crypto-config/ordererOrganizations/example.com/orderers/orderer.example.com/tls/:/var/hyperledger/orderer/tls    ports:      - 7050:7050  peer0.org1.example.com:    container_name: peer0.org1.example.com    extends:      file: peer-base.yaml      service: peer-base    environment:      - CORE_PEER_ID=peer0.org1.example.com      - CORE_PEER_ADDRESS=peer0.org1.example.com:7051      - CORE_PEER_LISTENADDRESS=0.0.0.0:7051      - CORE_PEER_CHAINCODEADDRESS=peer0.org1.example.com:7052      - CORE_PEER_CHAINCODELISTENADDRESS=0.0.0.0:7052      - CORE_PEER_GOSSIP_BOOTSTRAP=peer1.org1.example.com:8051      - CORE_PEER_GOSSIP_EXTERNALENDPOINT=peer0.org1.example.com:7051      - CORE_PEER_LOCALMSPID=Org1MSP      - CORE_PEER_ENBLKROUTER=true    volumes:        - /var/run/:/host/var/run/        - ../crypto-config/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/msp:/etc/hyperledger/fabric/msp        - ../crypto-config/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls:/etc/hyperledger/fabric/tls        - peer0.org1.example.com:/var/hyperledger/production    ports:      - 7051:7051      - 9099:9099  peer1.org1.example.com:    container_name: peer1.org1.example.com    extends:      file: peer-base.yaml      service: peer-base    environment:      - CORE_PEER_ID=peer1.org1.example.com      - CORE_PEER_ADDRESS=peer1.org1.example.com:8051      - CORE_PEER_LISTENADDRESS=0.0.0.0:8051      - CORE_PEER_CHAINCODEADDRESS=peer1.org1.example.com:8052      - CORE_PEER_CHAINCODELISTENADDRESS=0.0.0.0:8052      - CORE_PEER_GOSSIP_EXTERNALENDPOINT=peer1.org1.example.com:8051      - CORE_PEER_GOSSIP_BOOTSTRAP=peer0.org1.example.com:7051      - CORE_PEER_LOCALMSPID=Org1MSP      - CORE_PEER_ENBLKROUTER=true    volumes:        - /var/run/:/host/var/run/        - ../crypto-config/peerOrganizations/org1.example.com/peers/peer1.org1.example.com/msp:/etc/hyperledger/fabric/msp        - ../crypto-config/peerOrganizations/org1.example.com/peers/peer1.org1.example.com/tls:/etc/hyperledger/fabric/tls        - peer1.org1.example.com:/var/hyperledger/production    ports:      - 8051:8051      - 10099:9099  peer0.org2.example.com:    container_name: peer0.org2.example.com    extends:      file: peer-base.yaml      service: peer-base    environment:      - CORE_PEER_ID=peer0.org2.example.com      - CORE_PEER_ADDRESS=peer0.org2.example.com:9051      - CORE_PEER_LISTENADDRESS=0.0.0.0:9051      - CORE_PEER_CHAINCODEADDRESS=peer0.org2.example.com:9052      - CORE_PEER_CHAINCODELISTENADDRESS=0.0.0.0:9052      - CORE_PEER_GOSSIP_EXTERNALENDPOINT=peer0.org2.example.com:9051      - CORE_PEER_GOSSIP_BOOTSTRAP=peer1.org2.example.com:10051      - CORE_PEER_LOCALMSPID=Org2MSP      - CORE_PEER_ENBLKROUTER=true    volumes:        - /var/run/:/host/var/run/        - ../crypto-config/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/msp:/etc/hyperledger/fabric/msp        - ../crypto-config/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls:/etc/hyperledger/fabric/tls        - peer0.org2.example.com:/var/hyperledger/production    ports:      - 9051:9051      - 9099:9099  peer1.org2.example.com:    container_name: peer1.org2.example.com    extends:      file: peer-base.yaml      service: peer-base    environment:      - CORE_PEER_ID=peer1.org2.example.com      - CORE_PEER_ADDRESS=peer1.org2.example.com:10051      - CORE_PEER_LISTENADDRESS=0.0.0.0:10051      - CORE_PEER_CHAINCODEADDRESS=peer1.org2.example.com:10052      - CORE_PEER_CHAINCODELISTENADDRESS=0.0.0.0:10052      - CORE_PEER_GOSSIP_EXTERNALENDPOINT=peer1.org2.example.com:10051      - CORE_PEER_GOSSIP_BOOTSTRAP=peer0.org2.example.com:9051      - CORE_PEER_LOCALMSPID=Org2MSP      - CORE_PEER_ENBLKROUTER=true    volumes:        - /var/run/:/host/var/run/        - ../crypto-config/peerOrganizations/org2.example.com/peers/peer1.org2.example.com/msp:/etc/hyperledger/fabric/msp        - ../crypto-config/peerOrganizations/org2.example.com/peers/peer1.org2.example.com/tls:/etc/hyperledger/fabric/tls        - peer1.org2.example.com:/var/hyperledger/production    ports:      - 10051:10051      - 10099:9099</code></pre><h2 id="4-修改组织1配置"><a href="#4-修改组织1配置" class="headerlink" title="4. 修改组织1配置"></a>4. 修改组织1配置</h2><h4 id="docker-compose-org1-35-yaml"><a href="#docker-compose-org1-35-yaml" class="headerlink" title="docker-compose-org1-35.yaml"></a>docker-compose-org1-35.yaml</h4><pre><code>version: &#39;2&#39;volumes:  orderer0.org1.example.com:  orderer1.org1.example.com:  orderer2.org1.example.com:  peer0.org1.example.com:  peer1.org1.example.com:networks:  byfn:services:  orderer0.org1.example.com:    environment:      - ORDERER_GENERAL_LOCALMSPID=Org1MSP    extends:      file: base/peer-base.yaml      service: orderer-base    container_name: orderer0.org1.example.com    networks:      - byfn    volumes:      - ./channel-artifacts/genesis.block:/var/hyperledger/orderer/orderer.genesis.block      - ./crypto-config/peerOrganizations/org1.example.com/peers/orderer0.org1.example.com/msp:/var/hyperledger/orderer/msp      - ./crypto-config/peerOrganizations/org1.example.com/peers/orderer0.org1.example.com/tls/:/var/hyperledger/orderer/tls      - orderer0.org1.example.com:/var/hyperledger/production/orderer    ports:      - 7050:7050    extra_hosts:      - orderer0.org1.example.com:192.168.9.35      - orderer1.org1.example.com:192.168.9.35      - orderer2.org1.example.com:192.168.9.35      - orderer0.org2.example.com:192.168.9.28      - orderer1.org2.example.com:192.168.9.28  orderer1.org1.example.com:    environment:      - ORDERER_GENERAL_LOCALMSPID=Org1MSP    extends:      file: base/peer-base.yaml      service: orderer-base    container_name: orderer1.org1.example.com    networks:      - byfn    volumes:      - ./channel-artifacts/genesis.block:/var/hyperledger/orderer/orderer.genesis.block      - ./crypto-config/peerOrganizations/org1.example.com/peers/orderer1.org1.example.com/msp:/var/hyperledger/orderer/msp      - ./crypto-config/peerOrganizations/org1.example.com/peers/orderer1.org1.example.com/tls/:/var/hyperledger/orderer/tls      - orderer1.org1.example.com:/var/hyperledger/production/orderer    ports:      - 8050:7050    extra_hosts:      - orderer0.org1.example.com:192.168.9.35      - orderer1.org1.example.com:192.168.9.35      - orderer2.org1.example.com:192.168.9.35      - orderer0.org2.example.com:192.168.9.28      - orderer1.org2.example.com:192.168.9.28  orderer2.org1.example.com:    environment:      - ORDERER_GENERAL_LOCALMSPID=Org1MSP    extends:      file: base/peer-base.yaml      service: orderer-base    container_name: orderer2.org1.example.com    networks:      - byfn    volumes:      - ./channel-artifacts/genesis.block:/var/hyperledger/orderer/orderer.genesis.block      - ./crypto-config/peerOrganizations/org1.example.com/peers/orderer2.org1.example.com/msp:/var/hyperledger/orderer/msp      - ./crypto-config/peerOrganizations/org1.example.com/peers/orderer2.org1.example.com/tls/:/var/hyperledger/orderer/tls      - orderer2.org1.example.com:/var/hyperledger/production/orderer    ports:      - 9050:7050    extra_hosts:      - orderer0.org1.example.com:192.168.9.35      - orderer1.org1.example.com:192.168.9.35      - orderer2.org1.example.com:192.168.9.35      - orderer0.org2.example.com:192.168.9.28      - orderer1.org2.example.com:192.168.9.28  peer0.org1.example.com:    container_name: peer0.org1.example.com    extends:      file:  base/docker-compose-base.yaml      service: peer0.org1.example.com    networks:      - byfn    extra_hosts:      - orderer0.org1.example.com:192.168.9.35      - orderer1.org1.example.com:192.168.9.35      - orderer2.org1.example.com:192.168.9.35      - orderer0.org2.example.com:192.168.9.28      - orderer1.org2.example.com:192.168.9.28  peer1.org1.example.com:    container_name: peer1.org1.example.com    extends:      file:  base/docker-compose-base.yaml      service: peer1.org1.example.com    networks:      - byfn    extra_hosts:      - orderer0.org1.example.com:192.168.9.35      - orderer1.org1.example.com:192.168.9.35      - orderer2.org1.example.com:192.168.9.35      - orderer0.org2.example.com:192.168.9.28      - orderer1.org2.example.com:192.168.9.28  cli:    container_name: cli    image: 192.168.9.8:80/fabric1.4performance/hyperledger/fabric-tools:sles12sp3-latest    tty: true    stdin_open: true    environment:      - GOPATH=/opt/gopath      - CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock      #- FABRIC_LOGGING_SPEC=DEBUG      - FABRIC_LOGGING_SPEC=INFO      - CORE_PEER_BCCSP_DEFAULT=GM      - CORE_PEER_ID=cli      - CORE_PEER_ADDRESS=peer0.org1.example.com:7051      - CORE_PEER_LOCALMSPID=Org1MSP      - CORE_PEER_TLS_ENABLED=true      - CORE_PEER_TLS_CERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/server.crt      - CORE_PEER_TLS_KEY_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/server.key      - CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt      - CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp    working_dir: /opt/gopath/src/github.com/hyperledger/fabric/peer    command: /bin/bash    volumes:      - /var/run/:/host/var/run/      - ./../chaincode/:/opt/gopath/src/github.com/chaincode      - ./../unionbank/:/opt/gopath/src/unionbank      - ./crypto-config:/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/      - ./scripts:/opt/gopath/src/github.com/hyperledger/fabric/peer/scripts/      - ./channel-artifacts:/opt/gopath/src/github.com/hyperledger/fabric/peer/channel-artifacts    extra_hosts:      - orderer0.org1.example.com:192.168.9.35      - orderer1.org1.example.com:192.168.9.35      - orderer2.org1.example.com:192.168.9.35      - orderer0.org2.example.com:192.168.9.28      - orderer1.org2.example.com:192.168.9.28      - peer0.org1.example.com:192.168.9.35      - peer1.org1.example.com:192.168.9.35      - peer0.org2.example.com:192.168.9.28      - peer1.org2.example.com:192.168.9.28    networks:      - byfn</code></pre><h2 id="5-修改组织2配置"><a href="#5-修改组织2配置" class="headerlink" title="5. 修改组织2配置"></a>5. 修改组织2配置</h2><h4 id="docker-compose-org2-28-yaml"><a href="#docker-compose-org2-28-yaml" class="headerlink" title="docker-compose-org2-28.yaml"></a>docker-compose-org2-28.yaml</h4><pre><code>version: &#39;2&#39;volumes:  orderer0.org2.example.com:  orderer1.org2.example.com:  peer0.org2.example.com:  peer1.org2.example.com:networks:  byfn:services:  orderer0.org2.example.com:    environment:      - ORDERER_GENERAL_LOCALMSPID=Org2MSP    extends:      file: base/peer-base.yaml      service: orderer-base    container_name: orderer0.org2.example.com    networks:      - byfn    volumes:      - ./channel-artifacts/genesis.block:/var/hyperledger/orderer/orderer.genesis.block      - ./crypto-config/peerOrganizations/org2.example.com/peers/orderer0.org2.example.com/msp:/var/hyperledger/orderer/msp      - ./crypto-config/peerOrganizations/org2.example.com/peers/orderer0.org2.example.com/tls/:/var/hyperledger/orderer/tls      - orderer0.org2.example.com:/var/hyperledger/production/orderer    ports:      - 7050:7050    extra_hosts:      - orderer0.org1.example.com:192.168.9.35      - orderer1.org1.example.com:192.168.9.35      - orderer2.org1.example.com:192.168.9.35      - orderer0.org2.example.com:192.168.9.28      - orderer1.org2.example.com:192.168.9.28  orderer1.org2.example.com:    environment:      - ORDERER_GENERAL_LOCALMSPID=Org2MSP    extends:      file: base/peer-base.yaml      service: orderer-base    container_name: orderer1.org2.example.com    networks:      - byfn    volumes:      - ./channel-artifacts/genesis.block:/var/hyperledger/orderer/orderer.genesis.block      - ./crypto-config/peerOrganizations/org2.example.com/peers/orderer1.org2.example.com/msp:/var/hyperledger/orderer/msp      - ./crypto-config/peerOrganizations/org2.example.com/peers/orderer1.org2.example.com/tls/:/var/hyperledger/orderer/tls      - orderer1.org2.example.com:/var/hyperledger/production/orderer    ports:      - 8050:7050    extra_hosts:      - orderer0.org1.example.com:192.168.9.35      - orderer1.org1.example.com:192.168.9.35      - orderer2.org1.example.com:192.168.9.35      - orderer0.org2.example.com:192.168.9.28      - orderer1.org2.example.com:192.168.9.28  peer0.org2.example.com:    container_name: peer0.org2.example.com    extends:      file:  base/docker-compose-base.yaml      service: peer0.org2.example.com    networks:      - byfn    extra_hosts:      - orderer0.org1.example.com:192.168.9.35      - orderer1.org1.example.com:192.168.9.35      - orderer2.org1.example.com:192.168.9.35      - orderer0.org2.example.com:192.168.9.28      - orderer1.org2.example.com:192.168.9.28  peer1.org2.example.com:    container_name: peer1.org2.example.com    extends:      file:  base/docker-compose-base.yaml      service: peer1.org2.example.com    networks:      - byfn    extra_hosts:      - orderer0.org1.example.com:192.168.9.35      - orderer1.org1.example.com:192.168.9.35      - orderer2.org1.example.com:192.168.9.35      - orderer0.org2.example.com:192.168.9.28      - orderer1.org2.example.com:192.168.9.28</code></pre><p>以上步骤完成后，将项目拷贝到其他的主机上</p><h2 id="6-启动fabric网络"><a href="#6-启动fabric网络" class="headerlink" title="6. 启动fabric网络"></a>6. 启动fabric网络</h2><p>启动主机1</p><pre><code>docker-compose -f docker-compose-org1-35.yaml up -d</code></pre><p>启动主机2</p><pre><code>docker-compose -f docker-compose-org2-28.yaml up -d</code></pre><p>启动脚本</p><pre><code>#!/bin/bashexport CHANNEL_NAME=mychannelexport ORDERER_CA=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/orderer0.org1.example.com/msp/tlscacerts/tlsca.org1.example.com-cert.pem## Create channelpeer channel create -o orderer0.org1.example.com:7050 -c $CHANNEL_NAME -f ./channel-artifacts/channel.tx --tls $CORE_PEER_TLS_ENABLED --cafile $ORDERER_CA## Join all the peers to the channelpeer channel join -b $CHANNEL_NAME.block## Set the anchor peers for each org in the channelpeer channel update -o orderer0.org1.example.com:7050 -c $CHANNEL_NAME -f ./channel-artifacts/Org1MSPanchors.tx --tls $CORE_PEER_TLS_ENABLED --cafile $ORDERER_CA## Install chaincode on peer0.org1peer chaincode install -n mycc -v 1.0 -p github.com/chaincode/chaincode_example02peer chaincode install -n public -v 1.0 -p unionbank/chaincode/publicpeer chaincode install -n forfeiting -v 1.0 -p unionbank/chaincode/forfeitingsleep 5## pee1.org1export CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/mspexport CORE_PEER_ADDRESS=peer1.org1.example.com:8051export CORE_PEER_LOCALMSPID=&quot;Org1MSP&quot;export CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer1.org1.example.com/tls/ca.crtpeer channel join -b $CHANNEL_NAME.blockpeer chaincode install -n mycc -v 1.0 -p github.com/chaincode/chaincode_example02peer chaincode install -n public -v 1.0 -p unionbank/chaincode/publicpeer chaincode install -n forfeiting -v 1.0 -p unionbank/chaincode/forfeitingsleep 5## peer0.org2export CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/mspexport CORE_PEER_ADDRESS=peer0.org2.example.com:9051export CORE_PEER_LOCALMSPID=&quot;Org2MSP&quot;export CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crtpeer channel join -b $CHANNEL_NAME.blockpeer channel update -o orderer0.org1.example.com:7050 -c $CHANNEL_NAME -f ./channel-artifacts/Org2MSPanchors.tx --tls $CORE_PEER_TLS_ENABLED --cafile $ORDERER_CApeer chaincode install -n mycc -v 1.0 -p github.com/chaincode/chaincode_example02peer chaincode install -n public -v 1.0 -p unionbank/chaincode/publicpeer chaincode install -n forfeiting -v 1.0 -p unionbank/chaincode/forfeitingsleep 5## peer1.org2export CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/mspexport CORE_PEER_ADDRESS=peer1.org2.example.com:10051export CORE_PEER_LOCALMSPID=&quot;Org2MSP&quot;export CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer1.org2.example.com/tls/ca.crtpeer channel join -b $CHANNEL_NAME.blockpeer chaincode install -n mycc -v 1.0 -p github.com/chaincode/chaincode_example02peer chaincode install -n public -v 1.0 -p unionbank/chaincode/publicpeer chaincode install -n forfeiting -v 1.0 -p unionbank/chaincode/forfeitingsleep 5# Instantiate chaincode on peer0.org1echo &quot;Instantiating chaincode on peer0.org1...&quot;export CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/mspexport CORE_PEER_ADDRESS=peer0.org1.example.com:7051export CORE_PEER_LOCALMSPID=&quot;Org1MSP&quot;export CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crtsleep 5peer chaincode instantiate -o orderer0.org1.example.com:7050 --tls $CORE_PEER_TLS_ENABLED --cafile $ORDERER_CA -C $CHANNEL_NAME -n mycc -v 1.0 -c &#39;{&quot;Args&quot;:[&quot;init&quot;,&quot;a&quot;, &quot;100&quot;, &quot;b&quot;,&quot;200&quot;]}&#39;sleep 5peer chaincode instantiate -o orderer0.org1.example.com:7050 --tls $CORE_PEER_TLS_ENABLED --cafile $ORDERER_CA -C $CHANNEL_NAME -n public -v 1.0 -c &#39;{&quot;Args&quot;:[]}&#39;sleep 5peer chaincode instantiate -o orderer0.org1.example.com:7050 --tls $CORE_PEER_TLS_ENABLED --cafile $ORDERER_CA -C $CHANNEL_NAME -n forfeiting -v 1.0 -c &#39;{&quot;Args&quot;:[]}&#39;sleep 5# Query chaincode on peer0.org1peer chaincode query -C $CHANNEL_NAME -n mycc -c &#39;{&quot;Args&quot;:[&quot;query&quot;,&quot;a&quot;]}&#39;# Invoke chaincode on peer0.org1peer chaincode invoke -o orderer0.org1.example.com:7050 --tls $CORE_PEER_TLS_ENABLED --cafile $ORDERER_CA -C $CHANNEL_NAME -n mycc  -c &#39;{&quot;Args&quot;:[&quot;invoke&quot;,&quot;a&quot;,&quot;b&quot;,&quot;10&quot;]}&#39;sleep 5# Query chaincode on peer0.org1peer chaincode query -C $CHANNEL_NAME -n mycc -c &#39;{&quot;Args&quot;:[&quot;query&quot;,&quot;a&quot;]}&#39;</code></pre><p>注意清除原有不需要的容器和镜像，否则可能会用老的镜像，就比如某些链码的镜像</p><pre><code>docker rm -f $(docker ps -a|grep  dev|awk &#39;{print $1}&#39;)docker rmi -f $(docker images|grep  dev|awk &#39;{print $1}&#39;)docker volume rm -f $(docker volume ls -q)</code></pre><pre><code>version: &#39;2&#39;volumes:  orderer0.example.com:  orderer1.example.com:  orderer2.example.com:  peer0.org1.example.com:  peer1.org1.example.com:  peer0.org2.example.com:  peer1.org2.example.com:networks:  byfn:services:  orderer0.example.com:    environment:      - ORDERER_GENERAL_LOCALMSPID=OrdererMSP    extends:      file: base/peer-base.yaml      service: orderer-base    container_name: orderer0.example.com    networks:      - byfn    volumes:      - ./channel-artifacts/genesis.block:/var/hyperledger/orderer/orderer.genesis.block      - ./crypto-config/ordererOrganizations/example.com/orderers/orderer0.example.com/msp:/var/hyperledger/orderer/msp      - ./crypto-config/ordererOrganizations/example.com/orderers/orderer0.example.com/tls/:/var/hyperledger/orderer/tls      - orderer0.example.com:/var/hyperledger/production/orderer    ports:      - 7050:7050    extra_hosts:      - orderer0.example.com:192.168.9.108      - orderer1.example.com:192.168.9.17      - orderer2.example.com:192.168.9.117      - peer0.org1.example.com:192.168.9.105      - peer1.org1.example.com:192.168.9.13      - peer0.org2.example.com:192.168.9.55      - peer1.org2.example.com:192.168.9.88  orderer1.example.com:    environment:      - ORDERER_GENERAL_LOCALMSPID=OrdererMSP    extends:      file: base/peer-base.yaml      service: orderer-base    container_name: orderer1.example.com    networks:      - byfn    volumes:      - ./channel-artifacts/genesis.block:/var/hyperledger/orderer/orderer.genesis.block      - ./crypto-config/ordererOrganizations/example.com/orderers/orderer1.example.com/msp:/var/hyperledger/orderer/msp      - ./crypto-config/ordererOrganizations/example.com/orderers/orderer1.example.com/tls/:/var/hyperledger/orderer/tls      - orderer1.example.com:/var/hyperledger/production/orderer    ports:      - 8050:7050    extra_hosts:      - orderer0.example.com:192.168.9.108      - orderer1.example.com:192.168.9.17      - orderer2.example.com:192.168.9.117      - peer0.org1.example.com:192.168.9.105      - peer1.org1.example.com:192.168.9.13      - peer0.org2.example.com:192.168.9.55      - peer1.org2.example.com:192.168.9.88  orderer2.example.com:    environment:      - ORDERER_GENERAL_LOCALMSPID=OrdererMSP    extends:      file: base/peer-base.yaml      service: orderer-base    container_name: orderer2.example.com    networks:      - byfn    volumes:      - ./channel-artifacts/genesis.block:/var/hyperledger/orderer/orderer.genesis.block      - ./crypto-config/ordererOrganizations/example.com/orderers/orderer2.example.com/msp:/var/hyperledger/orderer/msp      - ./crypto-config/ordererOrganizations/example.com/orderers/orderer2.example.com/tls/:/var/hyperledger/orderer/tls      - orderer2.example.com:/var/hyperledger/production/orderer    ports:      - 9050:7050    extra_hosts:      - orderer0.example.com:192.168.9.108      - orderer1.example.com:192.168.9.17      - orderer2.example.com:192.168.9.117      - peer0.org1.example.com:192.168.9.105      - peer1.org1.example.com:192.168.9.13      - peer0.org2.example.com:192.168.9.55      - peer1.org2.example.com:192.168.9.88  peer0.org1.example.com:    container_name: peer0.org1.example.com    extends:      file:  base/docker-compose-base.yaml      service: peer0.org1.example.com    networks:      - byfn    extra_hosts:      - orderer0.example.com:192.168.9.108      - orderer1.example.com:192.168.9.17      - orderer2.example.com:192.168.9.117      - peer0.org1.example.com:192.168.9.105      - peer1.org1.example.com:192.168.9.13      - peer0.org2.example.com:192.168.9.55      - peer1.org2.example.com:192.168.9.88  peer1.org1.example.com:    container_name: peer1.org1.example.com    extends:      file:  base/docker-compose-base.yaml      service: peer1.org1.example.com    networks:      - byfn    extra_hosts:      - orderer0.example.com:192.168.9.108      - orderer1.example.com:192.168.9.17      - orderer2.example.com:192.168.9.117      - peer0.org1.example.com:192.168.9.105      - peer1.org1.example.com:192.168.9.13      - peer0.org2.example.com:192.168.9.55      - peer1.org2.example.com:192.168.9.88peer0.org2.example.com:    container_name: peer0.org2.example.com    extends:      file:  base/docker-compose-base.yaml      service: peer0.org2.example.com    networks:      - byfn    extra_hosts:      - orderer0.example.com:192.168.9.108      - orderer1.example.com:192.168.9.17      - orderer2.example.com:192.168.9.117      - peer0.org1.example.com:192.168.9.105      - peer1.org1.example.com:192.168.9.13      - peer0.org2.example.com:192.168.9.55      - peer1.org2.example.com:192.168.9.88peer1.org2.example.com:    container_name: peer1.org2.example.com    extends:      file:  base/docker-compose-base.yaml      service: peer1.org2.example.com    networks:      - byfn    extra_hosts:      - orderer0.example.com:192.168.9.108      - orderer1.example.com:192.168.9.17      - orderer2.example.com:192.168.9.117      - peer0.org1.example.com:192.168.9.105      - peer1.org1.example.com:192.168.9.13      - peer0.org2.example.com:192.168.9.55      - peer1.org2.example.com:192.168.9.88  cli:    container_name: cli    image: 192.168.9.8:80/fabric1.4performance/hyperledger/fabric-tools:sles12sp3-latest    tty: true    stdin_open: true    environment:      - GOPATH=/opt/gopath      - CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock      #- FABRIC_LOGGING_SPEC=DEBUG      - FABRIC_LOGGING_SPEC=INFO      #- CORE_PEER_BCCSP_DEFAULT=GM      - CORE_PEER_BCCSP_DEFAULT=SW      - CORE_PEER_ID=cli      - CORE_PEER_ADDRESS=peer0.org1.example.com:7051      - CORE_PEER_LOCALMSPID=Org1MSP      - CORE_PEER_TLS_ENABLED=true      - CORE_PEER_TLS_CERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/server.crt      - CORE_PEER_TLS_KEY_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/server.key      - CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt      - CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp    working_dir: /opt/gopath/src/github.com/hyperledger/fabric/peer    command: /bin/bash    volumes:      - /var/run/:/host/var/run/      - ./../chaincode/:/opt/gopath/src/github.com/chaincode      - ./../unionbank/:/opt/gopath/src/unionbank      - ./crypto-config:/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/      - ./scripts:/opt/gopath/src/github.com/hyperledger/fabric/peer/scripts/      - ./channel-artifacts:/opt/gopath/src/github.com/hyperledger/fabric/peer/channel-artifacts    extra_hosts:      - orderer0.example.com:192.168.9.108      - orderer1.example.com:192.168.9.17      - orderer2.example.com:192.168.9.117      - peer0.org1.example.com:192.168.9.105      - peer1.org1.example.com:192.168.9.13      - peer0.org2.example.com:192.168.9.55      - peer1.org2.example.com:192.168.9.88    networks:      - byfn</code></pre>]]></content>
      
      
      <categories>
          
          <category> fabric </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fabric部署 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
