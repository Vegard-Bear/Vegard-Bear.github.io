<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【leetcode-300】最长递增子序列</title>
      <link href="/2021/01/08/leetcode-300/"/>
      <url>/2021/01/08/leetcode-300/</url>
      
        <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p><p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p><p>示例 1：</p><pre><code>输入：nums = [10,9,2,5,3,7,101,18]输出：4解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</code></pre><p>示例 2：</p><pre><code>输入：nums = [0,1,0,3,2,3]输出：4</code></pre><p>示例 3：</p><pre><code>输入：nums = [7,7,7,7,7,7,7]输出：1</code></pre><p>提示：</p><ul><li>1 &lt;= nums.length &lt;= 2500</li><li>-104 &lt;= nums[i] &lt;= 104</li></ul><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>这道题是一道非常经典的动态规划算法题，而对于动态规划算法，最重要的就是列出状态转移方程。这里我们先要定义一个dp数组，这个dp数组的含义非常重要。</p><h5 id="dp-i-表示以-nums-i-结尾的最长递增子序列的长度"><a href="#dp-i-表示以-nums-i-结尾的最长递增子序列的长度" class="headerlink" title="dp[i] 表示以 nums[i] 结尾的最长递增子序列的长度"></a><center><font color="blue">dp[i] 表示以 nums[i] 结尾的最长递增子序列的长度</font></center></h5><p>那么根据这个定义。我们可以先确定 base case，就是</p><h5 id="dp-i-1"><a href="#dp-i-1" class="headerlink" title="dp[i] = 1"></a><center><font color="blue">dp[i] = 1</font></center></h5><p>因为在初始状态下，以nums[i]结尾的最长递增子序列至少存在一个包含自身的子序列。<br>然后就可以列我们的状态转移方程了。</p><blockquote><p>注意：“子序列”和“子串”这两个名词的区别，子串一定是连续的，而子序列不一定是连续的。</p></blockquote><p>现在假设我们要求dp[5]，也就是以第6个数字结尾的字符串的最长递增子序列。那么我们只需要遍历以它前面数字结尾的所有最长子序列，找到那个结尾数字小于当前数字的子序列，然后长度+1即可。即遍历 dp[0] 到 dp[4]，如果nums[j] &lt; nums[5]，那么就可以更新 dp[5] = dp[j] + 1，当然，最后需要保留大的那个数字作为dp[5]的最终值。</p><h4 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h4><h4 id="dp-i-max-dp-i-dp-j-1-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-当-j-lt-i-时"><a href="#dp-i-max-dp-i-dp-j-1-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-当-j-lt-i-时" class="headerlink" title=" dp[i] = max ( dp[i] , dp[j] + 1 )  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  当 j &lt; i 时 "></a><center><font color="blue"> dp[i] = max ( dp[i] , dp[j] + 1 )  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  当 j &lt; i 时 </font></center></h4><p>代码如下：</p><pre><code>for j := 0; j &lt; i ; j++ {    // 核心代码，状态转移方程    // 以当前数字结尾的最长子序列长度等于【之前比他小的数字的结尾的最长子序列长度+1】    if nums[j] &lt; nums[i] {        dp[i] = max(dp[i], dp[j] + 1)    }}</code></pre><p>既然得到了dp[5]，那么dp[i]都能求出来，只需要依次遍历一遍即可，最终代码如下。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code>func lengthOfLIS(nums []int) int {    // 定义一个dp数组    // dp[i]表示以第i+1个元素结尾的字符串最长子递增子序列    dp := make([]int, len(nums))    // 初始化数组，初始最长递增子序列为1    for k := range dp {        dp[k] = 1    }    // 遍历数组，依次计算以每个数为结尾的最长子序列    for i := 0; i &lt; len(nums) ; i++ {        // 遍历之前已经计算完成的子序列        for j := 0; j &lt; i ; j++ {            // 核心代码，状态转移方程            // 以当前数字结尾的最长子序列长度等于【之前比他小的数字的结尾的最长子序列长度+1】            if nums[j] &lt; nums[i] {                dp[i] = max(dp[i], dp[j] + 1)            }        }    }    // 最后遍历一遍dp数组，留下最大值    maxLen := 0    for k := range dp {        if maxLen &lt; dp[k] {            maxLen = dp[k]        }    }    return maxLen}func max(a, b int) int {    if a &gt; b {        return a    }    return b}</code></pre><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><h3 id="时间复杂度：O-n-2"><a href="#时间复杂度：O-n-2" class="headerlink" title="时间复杂度：O((n^2))"></a>时间复杂度：O((n^2))</h3><p>其中 n 为数组 nums 的长度。动态规划的状态数为 n，计算状态 dp[i] 时，需要 O(n) 的时间遍历 dp[0…i−1] 的所有状态，所以总时间复杂度为 O(n^2)</p><h3 id="空间复杂度：O-n"><a href="#空间复杂度：O-n" class="headerlink" title="空间复杂度：O((n))"></a>空间复杂度：O((n))</h3><p>需要额外使用长度为 n 的 dp 数组。</p><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><p>动态规划的题最重要的是如何定义dp数组，确定base case以及状态转移方程。</p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Go源码解析4】字符串</title>
      <link href="/2021/01/07/go-sourcecode-string/"/>
      <url>/2021/01/07/go-sourcecode-string/</url>
      
        <content type="html"><![CDATA[<blockquote><p>字符串是 Go 语言中的基础数据类型，虽然字符串往往被看做一个整体，但是它实际上是一片连续的内存空间，我们也可以将它理解成一个由字符组成的数组，本节会详细介绍字符串的实现原理、转换过程以及常见操作的实现。</p></blockquote><p><img src="https://vegard-bear.github.io/images/%E5%AD%97%E7%AC%A6%E4%B8%B2.png" alt></p><blockquote><p>点击图片查看高清大图</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> 源码解析 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Go源码解析3】哈希表</title>
      <link href="/2021/01/07/go-sourcecode-map/"/>
      <url>/2021/01/07/go-sourcecode-map/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本节会介绍 Go 语言的哈希的实现原理，哈希是除了数组之外，最常见的数据结构。几乎所有的语言都会有数组和哈希表两种集合元素，有的语言将数组实现成列表，而有的语言将哈希称作字典或者映射。无论如何命名或者如何实现，数组和哈希是两种设计集合元素的思路，数组用于表示元素的序列，而哈希表示的是键值对之间映射关系。</p></blockquote><p><img src="https://vegard-bear.github.io/images/%E5%93%88%E5%B8%8C%E8%A1%A8.png" alt></p><blockquote><p>点击图片查看高清大图</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> 源码解析 </tag>
            
            <tag> map </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Go源码解析2】切片</title>
      <link href="/2021/01/06/go-sourcecode-slice/"/>
      <url>/2021/01/06/go-sourcecode-slice/</url>
      
        <content type="html"><![CDATA[<p>上一节介绍的数组在 Go 语言中没那么常用，更常用的数据结构是切片，即动态数组，其长度并不固定，我们可以向切片中追加元素，它会在容量不足时自动扩容。</p><p>这一节我们就来看看Go语言中切片的底层实现逻辑。</p><p><img src="https://vegard-bear.github.io/images/%E5%88%87%E7%89%87%E5%AE%9E%E7%8E%B0.png" alt></p><blockquote><p>点击图片查看高清大图</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> 源码解析 </tag>
            
            <tag> 切片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Go源码解析1】数组</title>
      <link href="/2021/01/04/go-sourcecode-array/"/>
      <url>/2021/01/04/go-sourcecode-array/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>数组是由相同类型元素的集合组成的数据结构，<font color="blue">计算机会为数组分配一块连续的内存来保存其中的元素</font>，我们可以利用数组中元素的索引快速访问特定元素。</p><p>在Go语言中我们常常采用如下的方式定义数组：</p><pre><code>[10]int[200]interface{}</code></pre><p>Go 语言数组在初始化之后大小就无法改变，<font color="red">存储元素类型相同、但是大小不同的数组类型在 Go 语言看来也是完全不同的，只有两个条件都相同才是同一类型</font>。</p><pre><code>func NewArray(elem *Type, bound int64) *Type {    if bound &lt; 0 {        Fatalf(&quot;NewArray: invalid bound %v&quot;, bound)    }    t := New(TARRAY)    t.Extra = &amp;Array{Elem: elem, Bound: bound}    t.SetNotInHeap(elem.NotInHeap())    return t}</code></pre><p>编译期间的数组类型是由上述的 cmd/compile/internal/types.NewArray 函数生成的，该类型包含两个字段，分别是<font color="red">元素类型 Elem 和数组的大小 Bound，这两个字段共同构成了数组类型</font>，而当前数组是否应该在堆栈中初始化也在编译期就确定了。</p><h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><p>Go 语言的数组有两种不同的创建方式</p><ul><li>显式的指定数组大小</li><li>使用 […]T 声明数组，Go 语言会在编译期间通过源代码推导数组的大小</li></ul><pre><code>arr1 := [3]int{1, 2, 3}arr2 := [...]int{1, 2, 3}</code></pre><p>上述两种声明方式在运行期间得到的结果是完全相同的，后一种声明方式在编译期间就会被转换成前一种，这也就是编译器对数组大小的推导</p><h2 id="上限推导"><a href="#上限推导" class="headerlink" title="上限推导"></a>上限推导</h2><p>两种不同的声明方式会导致编译器做出完全不同的处理，如果我们使用第一种方式 [10]T，那么<font color="red">变量的类型在编译进行到类型检查阶段就会被提取出来</font>，随后使用 cmd/compile/internal/types.NewArray创建包含数组大小的 cmd/compile/internal/types.Array 结构体。</p><p>当我们使用 […]T 的方式声明数组时，编译器会在 cmd/compile/internal/gc.typecheckcomplit 函数中<font color="red">对该数组的大小进行推导</font>：</p><pre><code>func typecheckcomplit(n *Node) (res *Node) {    ...    if n.Right.Op == OTARRAY &amp;&amp; n.Right.Left != nil &amp;&amp; n.Right.Left.Op == ODDD {        n.Right.Right = typecheck(n.Right.Right, ctxType)        if n.Right.Right.Type == nil {            n.Type = nil            return n        }        elemType := n.Right.Right.Type        // 通过遍历元素的方式来计算数组中元素的数量        length := typecheckarraylit(elemType, -1, n.List.Slice(), &quot;array literal&quot;)        n.Op = OARRAYLIT        n.Type = types.NewArray(elemType, length)        n.Right = nil        return n    }    ...    switch t.Etype {    case TARRAY:        typecheckarraylit(t.Elem(), t.NumElem(), n.List.Slice(), &quot;array literal&quot;)        n.Op = OARRAYLIT        n.Right = nil    }}</code></pre><p>所以我们可以看出 […]T{1, 2, 3} 和 [3]T{1, 2, 3} 在运行时是完全等价的，[…]T 这种初始化方式也只是 Go 语言为我们提供的一种语法糖，当我们不想计算数组中的元素个数时可以通过这种方法减少一些工作量。</p><h2 id="语句转换"><a href="#语句转换" class="headerlink" title="语句转换"></a>语句转换</h2><p>对于一个由字面量组成的数组，根据数组元素数量的不同，编译器会在负责初始化字面量的 cmd/compile/internal/gc.anylit 函数中做两种不同的优化：</p><ul><li><font color="red">当元素数量小于或者等于 4 个时，会直接将数组中的元素放置在栈上；</font></li><li>当元素数量大于 4 个时，会将数组中的元素放置到静态区并在运行时取出；</li></ul><pre><code>func anylit(n *Node, var_ *Node, init *Nodes) {    t := n.Type    switch n.Op {    case OSTRUCTLIT, OARRAYLIT:        if n.List.Len() &gt; 4 {            ...        }        // 注意这里传入的是 initKindLocalCode        fixedlit(inInitFunction, initKindLocalCode, n, var_, init)    ...    }}</code></pre><p>当数组的元素小于或者等于四个时，cmd/compile/internal/gc.fixedlit 会负责在函数编译之前将 [3]{1, 2, 3} 转换成更加原始的语句：</p><pre><code>func fixedlit(ctxt initContext, kind initKind, n *Node, var_ *Node, init *Nodes) {    var splitnode func(*Node) (a *Node, value *Node)    ...    for _, r := range n.List.Slice() {        a, value := splitnode(r)        a = nod(OAS, a, value)        a = typecheck(a, ctxStmt)        switch kind {        case initKindStatic:            genAsStatic(a)            // 元素个数小于等于4时走的是这个分支        case initKindLocalCode:            a = orderStmtInPlace(a, map[string][]*Node{})            a = walkstmt(a)            init.Append(a)        }    }}</code></pre><p>当数组中元素的个数小于或者等于四个并且 cmd/compile/internal/gc.fixedlit 函数接收的 kind 是 initKindLocalCode 时，上述代码会将原有的初始化语句 [3]int{1, 2, 3} 拆分成一个声明变量的表达式和几个赋值表达式，这些表达式会完成对数组的初始化：</p><pre><code>var arr [3]intarr[0] = 1arr[1] = 2arr[2] = 3</code></pre><p>但是如果当前数组的元素大于四个，cmd/compile/internal/gc.anylit 会先获取一个唯一的 staticname，然后调用 cmd/compile/internal/gc.fixedlit 函数在静态存储区初始化数组中的元素并将临时变量赋值给数组：</p><pre><code>func anylit(n *Node, var_ *Node, init *Nodes) {    t := n.Type    switch n.Op {    case OSTRUCTLIT, OARRAYLIT:        if n.List.Len() &gt; 4 {            // 这里先获取一个staticname            vstat := staticname(t)            vstat.Name.SetReadonly(true)            // 然后再调用fixedlit完成语句转化，注意这里传入的是initKindStatic            fixedlit(inNonInitFunction, initKindStatic, n, vstat, init)            a := nod(OAS, var_, vstat)            a = typecheck(a, ctxStmt)            a = walkexpr(a, init)            init.Append(a)            break        }        ...    }}</code></pre><p>假设代码需要初始化 [5]int{1, 2, 3, 4, 5}，那么我们可以将上述过程理解成以下的伪代码：</p><pre><code>var arr [5]intstatictmp_0[0] = 1statictmp_0[1] = 2statictmp_0[2] = 3statictmp_0[3] = 4statictmp_0[4] = 5arr = statictmp_0</code></pre><p>总结起来，在不考虑逃逸分析的情况下，<font color="red">如果数组中元素的个数小于或者等于 4 个，那么所有的变量会直接在栈上初始化，如果数组元素大于 4 个，变量就会在静态存储区初始化然后拷贝到栈上</font>，这些转换后的代码才会继续进入中间代码生成和机器码生成两个阶段，最后生成可以执行的二进制文件。</p><h1 id="访问和赋值"><a href="#访问和赋值" class="headerlink" title="访问和赋值"></a>访问和赋值</h1><p>无论是在栈上还是静态存储区，数组在内存中都是一连串的内存空间，我们<font color="blue">通过指向数组开头的指针、元素的数量以及元素类型占的空间大小表示数组。如果我们不知道数组中元素的数量，访问时可能发生越界；而如果不知道数组中元素类型的大小，就没有办法知道应该一次取出多少字节的数据</font>，无论丢失了那个信息，我们都无法知道这片连续的内存空间到底存储了什么数据：</p><p>数组访问越界是非常严重的错误，Go 语言中可以<font color="blue">在编译期间的静态类型检查判断数组越界</font>，cmd/compile/internal/gc.typecheck1 会验证访问数组的索引：</p><pre><code>func typecheck1(n *Node, top int) (res *Node) {    switch n.Op {    case OINDEX:        ok |= ctxExpr        l := n.Left  // array        r := n.Right // index        switch n.Left.Type.Etype {        case TSTRING, TARRAY, TSLICE:            ...            // 访问数组的索引是非整数时，报错            if n.Right.Type != nil &amp;&amp; !n.Right.Type.IsInteger() {                yyerror(&quot;non-integer array index %v&quot;, n.Right)                break            }            if !n.Bounded() &amp;&amp; Isconst(n.Right, CTINT) {                x := n.Right.Int64()                // 访问数组的索引是负数时，报错                if x &lt; 0 {                    yyerror(&quot;invalid array index %v (index must be non-negative)&quot;, n.Right)                  // 访问数组的索引越界时，报错                } else if n.Left.Type.IsArray() &amp;&amp; x &gt;= n.Left.Type.NumElem() {                    yyerror(&quot;invalid array index %v (out of bounds for %d-element array)&quot;, n.Right, n.Left.Type.NumElem())                }            }        }    ...    }}</code></pre><p>数组和字符串的一些简单越界错误都会在编译期间发现，例如：直接使用整数或者常量访问数组；但是<font color="blue">如果使用变量去访问数组或者字符串时，编译器就无法提前发现错误，我们需要 Go 语言运行时阻止不合法的访问</font>：</p><pre><code>arr[4]: invalid array index 4 (out of bounds for 3-element array)arr[i]: panic: runtime error: index out of range [4] with length 3</code></pre><p>Go 语言运行时在发现数组、切片和字符串的越界操作会由运行时的 <strong>runtime.panicIndex</strong> 和 <strong>runtime.goPanicIndex</strong> 触发程序的运行时错误并导致崩溃退出：</p><pre><code>TEXT runtime·panicIndex(SB),NOSPLIT,$0-8    MOVL    AX, x+0(FP)    MOVL    CX, y+4(FP)    JMP    runtime·goPanicIndex(SB)func goPanicIndex(x int, y int) {    panicCheck1(getcallerpc(), &quot;index out of range&quot;)    panic(boundsError{x: int64(x), signed: true, y: y, code: boundsIndex})}</code></pre><p>当数组的访问操作 OINDEX 成功通过编译器的检查后，会被转换成几个 SSA 指令，假设我们有如下所示的 Go 语言代码，通过如下的方式进行编译会得到 ssa.html 文件：</p><pre><code>package checkfunc outOfRange() int {    arr := [3]int{1, 2, 3}    i := 4    elem := arr[i]    return elem}$ GOSSAFUNC=outOfRange go build array.godumped SSA to ./ssa.html</code></pre><p>start 阶段生成的 SSA 代码就是优化之前的第一版中间代码，下面展示的部分是 elem := arr[i] 对应的中间代码，在这段中间代码中我们发现 Go 语言为数组的访问操作生成了判断数组上限的指令 IsInBounds 以及当条件不满足时触发程序崩溃的 PanicBounds 指令：</p><pre><code>b1:    ...    v22 (6) = LocalAddr &lt;*[3]int&gt; {arr} v2 v20    v23 (6) = IsInBounds &lt;bool&gt; v21 v11If v23 → b2 b3 (likely) (6)b2: ← b1-    v26 (6) = PtrIndex &lt;*int&gt; v22 v21    v27 (6) = Copy &lt;mem&gt; v20    v28 (6) = Load &lt;int&gt; v26 v27 (elem[int])    ...Ret v30 (+7)b3: ← b1-    v24 (6) = Copy &lt;mem&gt; v20    v25 (6) = PanicBounds &lt;mem&gt; [0] v21 v11 v24Exit v25 (6)</code></pre><p><font color="red">编译器会将 PanicBounds 指令转换成上面提到的 runtime.panicIndex 函数，当数组下标没有越界时，编译器会先获取数组的内存地址和访问的下标、利用 PtrIndex 计算出目标元素的地址，最后使用 Load 操作将指针中的元素加载到内存中</font>。</p><p>当然只有当编译器无法对数组下标是否越界无法做出判断时才会加入 PanicBounds 指令交给运行时进行判断，在使用字面量整数访问数组下标时会生成非常简单的中间代码，当我们将上述代码中的 arr[i] 改成 arr[2] 时，就会得到如下所示的代码：</p><pre><code>b1:    ...    v21 (5) = LocalAddr &lt;*[3]int&gt; {arr} v2 v20    v22 (5) = PtrIndex &lt;*int&gt; v21 v14    v23 (5) = Load &lt;int&gt; v22 v20 (elem[int])    ...</code></pre><p>Go 语言对于数组的访问还是有着比较多的检查的，<font color="blue">它不仅会在编译期间提前发现一些简单的越界错误并插入用于检测数组上限的函数调用，还会在运行期间通过插入的函数保证不会发生越界</font>。</p><p>数组的赋值和更新操作 a[i] = 2 也会生成 SSA 生成期间计算出数组当前元素的内存地址，然后修改当前内存地址的内容，这些赋值语句会被转换成如下所示的 SSA 代码：</p><pre><code>b1:    ...    v21 (5) = LocalAddr &lt;*[3]int&gt; {arr} v2 v19    v22 (5) = PtrIndex &lt;*int&gt; v21 v13    v23 (5) = Store &lt;mem&gt; {int} v22 v20 v19    ...</code></pre><p>赋值的过程中会先确定目标数组的地址，再通过 PtrIndex 获取目标元素的地址，最后使用 Store 指令将数据存入地址中，从上面的这些 SSA 代码中我们可以看出<font color="blue">无论是数组的寻址还是赋值都是在编译阶段完成的，没有运行时的参与</font>。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>数组是 Go 语言中重要的数据结构，了解它的实现能够帮助我们更好地理解这门语言，通过对其实现的分析，我们知道了<font color="red">对数组的访问和赋值需要同时依赖编译器和运行时，它的大多数操作在编译期间都会转换成直接读写内存，在中间代码生成期间，编译器还会插入运行时方法 runtime.panicIndex 调用防止发生越界错误</font>。</p><p><img src="http://qlkvpxmsx.hd-bkt.clouddn.com/%E6%95%B0%E7%BB%84%E5%B0%8F%E7%BB%93.png" alt></p><h4 id="遗留问题："><a href="#遗留问题：" class="headerlink" title="遗留问题："></a>遗留问题：</h4><p>如果数组元素大于 4 个，变量就会在静态存储区初始化然后拷贝到栈上”， 请问go为什么要这样实现，既然最终都要到栈上，即使400个元素，直接在栈上初始化，会如何呢？</p>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> 源码解析 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Go源码解析0】预备知识</title>
      <link href="/2021/01/03/go-sourcecode-prepare/"/>
      <url>/2021/01/03/go-sourcecode-prepare/</url>
      
        <content type="html"><![CDATA[<blockquote><p>学习Go语言的内部实现，主要依靠对源代码的分析，所以阅读源代码是很好的方式。大名鼎鼎的Linux之父linus谈到如何学习Linux内核时也说过”Read the F**ing Source code”。所以现在就开启我们的Go语言源码阅读之旅行吧～</p></blockquote><p>本节主要介绍Go源码解析的预备知识。</p><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h3 id="抽象语法树"><a href="#抽象语法树" class="headerlink" title="抽象语法树"></a>抽象语法树</h3><p>抽象语法树（Abstract Syntax Tree、AST），是源代码语法的结构的一种抽象表示，它用树状的方式表示编程语言的语法结构1。抽象语法树中的每一个节点都表示源代码中的一个元素，每一棵子树都表示一个语法元素，以表达式 2 * 3 + 7 为例，编译器的语法分析阶段会生成如下图所示的抽象语法树。</p><p><img src="http://qlkvpxmsx.hd-bkt.clouddn.com/%E6%8A%BD%E8%B1%A1%E8%AF%AD%E6%B3%95%E6%A0%91.png" alt></p><blockquote><p>图片来源于<a href="https://draveness.me/golang/docs/part1-prerequisite/ch02-compile/golang-compile-intro/" target="_blank" rel="noopener">draveness</a></p></blockquote><p>作为编译器常用的数据结构，抽象语法树抹去了源代码中不重要的一些字符 - 空格、分号或者括号等等。编译器在执行完语法分析之后会输出一个抽象语法树，这个抽象语法树会辅助编译器进行语义分析，我们可以用它来确定语法正确的程序是否存在一些类型不匹配的问题。</p><h3 id="静态单赋值"><a href="#静态单赋值" class="headerlink" title="静态单赋值"></a>静态单赋值</h3><p>静态单赋值（Static Single Assignment、SSA）是中间代码的特性，如果中间代码具有静态单赋值的特性，那么每个变量就只会被赋值一次。在实践中，我们通常会用下标实现静态单赋值，这里以下面的代码举个例子：</p><pre><code>x := 1x := 2y := x</code></pre><p>经过简单的分析，我们就能够发现上述的代码第一行的赋值语句 x := 1 不会起到任何作用。下面是具有 SSA 特性的中间代码，我们可以清晰地发现变量 y_1 和 x_1 是没有任何关系的，所以在机器码生成时就可以省去 x := 1 的复制，通过减少需要执行的指令优化这段代码。</p><pre><code>x_1 := 1x_2 := 2y_1 := x_2</code></pre><p>因为 SSA 的主要作用是对代码进行优化，所以它是编译器后端3的一部分；当然代码编译领域除了 SSA 还有很多中间代码的优化方法，编译器生成代码的优化也是一个古老并且复杂的领域，这里就不会展开介绍了。</p><h3 id="指令集"><a href="#指令集" class="headerlink" title="指令集"></a>指令集</h3><p>最后要介绍的一个预备知识就是指令集4了，很多开发者在都会遇到在本地开发环境编译和运行正常的代码，在生产环境却无法正常工作，这种问题背后会有多种原因，而不同机器使用的不同指令集可能是原因之一。</p><p>我们大多数开发者都会使用 x86_64 的 Macbook 作为工作上主要使用的设备，在命令行中输入 uname -m 就能获得当前机器的硬件信息：</p><pre><code>$ uname -mx86_64</code></pre><p>x86 是目前比较常见的指令集，除了 x86 之外，还有 arm 等指令集，苹果最新 Macbook 的自研芯片就使用了 arm 指令集，不同的处理器使用了不同的架构和机器语言，所以很多编程语言为了在不同的机器上运行需要将源代码根据架构翻译成不同的机器代码。</p><p>复杂指令集计算机（CISC）和精简指令集计算机（RISC）是两种遵循不同设计理念的指令集，从名字我们就可以推测出这两种指令集的区别：</p><ul><li>复杂指令集：通过增加指令的类型减少需要执行的指令数；</li><li>精简指令集：使用更少的指令类型完成目标的计算任务；</li></ul><p>早期的 CPU 为了减少机器语言指令的数量一般使用复杂指令集完成计算任务，这两者并没有绝对的优劣，它们只是在一些设计上的选择不同以达到不同的目的，我们会在后面的机器码生成一节中详细介绍指令集架构，不过各位读者也可以主动了解相关的内容。</p><h1 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a>编译原理</h1><p>Go 语言编译器的源代码在 src/cmd/compile 目录中，目录下的文件共同组成了 Go 语言的编译器</p><p>Go语言的具体编译过程如下：</p><p><img src="http://qlkvpxmsx.hd-bkt.clouddn.com/Go%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.png" alt></p><p>至此，我们就简单了解了Go源码编译的过程。</p>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> 源码解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Go特性8】Socket编程之UDP</title>
      <link href="/2021/01/02/go-feature-socket-udp/"/>
      <url>/2021/01/02/go-feature-socket-udp/</url>
      
        <content type="html"><![CDATA[<h1 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h1><p>在之前的案例中，我们一直使用的是TCP协议来编写Socket的客户端与服务端。其实也可以使用UDP协议来编写Socket的客户端与服务端。</p><h3 id="UDP服务器"><a href="#UDP服务器" class="headerlink" title="UDP服务器"></a>UDP服务器</h3><p><font color="red">由于UDP是“无连接”的，所以，服务器端不需要额外创建监听套接字</font>，只需要指定好IP和port，然后监听该地址，等待客户端与之建立连接，即可通信。</p><p>创建监听地址：</p><pre><code>func ResolveUDPAddr(network, address string) (*UDPAddr, error) </code></pre><p>创建监听连接：</p><pre><code>func ListenUDP(network string, laddr *UDPAddr) (*UDPConn, error) </code></pre><p>接收udp数据：</p><pre><code>func (c *UDPConn) ReadFromUDP(b []byte) (int, *UDPAddr, error)</code></pre><p>写出数据到udp：</p><pre><code>func (c *UDPConn) WriteToUDP(b []byte, addr *UDPAddr) (int, error)</code></pre><p>服务端完整代码实现如下：</p><pre><code>package main  import (    &quot;fmt&quot;    &quot;net&quot; )  func main() {    //创建监听的地址，并且指定udp协议    udp_addr, err := net.ResolveUDPAddr(&quot;udp&quot;, &quot;127.0.0.1:8002&quot;)    if err != nil {       fmt.Println(&quot;ResolveUDPAddr err:&quot;, err)       return    }    conn, err := net.ListenUDP(&quot;udp&quot;, udp_addr)    //创建监听链接    if err != nil {       fmt.Println(&quot;ListenUDP err:&quot;, err)       return    }    defer conn.Close()     buf := make([]byte, 1024)    n, raddr, err := conn.ReadFromUDP(buf)        //接收客户端发送过来的数据，填充到切片buf中。    if err != nil {       return    }    fmt.Println(&quot;客户端发送：&quot;, string(buf[:n]))     _, err = conn.WriteToUDP([]byte(&quot;nice to see u in udp&quot;), raddr) //向客户端发送数据    if err != nil {       fmt.Println(&quot;WriteToUDP err:&quot;, err)       return    } }</code></pre><h3 id="UDP客户端"><a href="#UDP客户端" class="headerlink" title="UDP客户端"></a>UDP客户端</h3><p>udp客户端的编写与TCP客户端的编写，基本上是一样的，只是将协议换成udp.代码如下：</p><pre><code>package main  import (    &quot;net&quot;    &quot;fmt&quot; )  func main() {    conn, err := net.Dial(&quot;udp&quot;, &quot;127.0.0.1:8002&quot;)     if err != nil {       fmt.Println(&quot;net.Dial err:&quot;, err)       return    }    defer conn.Close()     conn.Write([]byte(&quot;Hello! I&#39;m client in UDP!&quot;))     buf := make([]byte, 1024)    n, err1 := conn.Read(buf)    if err1 != nil {       return    }    fmt.Println(&quot;服务器发来：&quot;, string(buf[:n])) }</code></pre><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p>其实对于UDP而言，服务器不需要并发，只要循环处理客户端数据即可。客户端也等同于TCP通信并发的客户端。</p><h3 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h3><pre><code>package main  import (    &quot;net&quot;    &quot;fmt&quot; )  func main() {    // 创建 服务器 UDP 地址结构。指定 IP + port    laddr, err := net.ResolveUDPAddr(&quot;udp&quot;, &quot;127.0.0.1:8003&quot;)    if err != nil {       fmt.Println(&quot;ResolveUDPAddr err:&quot;, err)       return    }    // 监听 客户端连接    conn, err := net.ListenUDP(&quot;udp&quot;, laddr)    if err != nil {       fmt.Println(&quot;net.ListenUDP err:&quot;, err)       return    }    defer conn.Close()     for {       buf := make([]byte, 1024)       n, raddr, err := conn.ReadFromUDP(buf)       if err != nil {          fmt.Println(&quot;conn.ReadFromUDP err:&quot;, err)          return       }       fmt.Printf(&quot;接收到客户端[%s]：%s&quot;, raddr, string(buf[:n]))        conn.WriteToUDP([]byte(&quot;I-AM-SERVER&quot;), raddr) // 简单回写数据给客户端    } }</code></pre><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><pre><code>package main  import (    &quot;net&quot;    &quot;os&quot;    &quot;fmt&quot; )  func main() {    conn, err := net.Dial(&quot;udp&quot;, &quot;127.0.0.1:8003&quot;)    if err != nil {       fmt.Println(&quot;net.Dial err:&quot;, err)       return    }    defer conn.Close()    go func() {       str := make([]byte, 1024)       for {          n, err := os.Stdin.Read(str) //从键盘读取内容， 放在str          if err != nil {             fmt.Println(&quot;os.Stdin. err1 = &quot;, err)             return          }          conn.Write(str[:n])       // 给服务器发送       }    }()    buf := make([]byte, 1024)    for {       n, err := conn.Read(buf)       if err != nil {          fmt.Println(&quot;conn.Read err:&quot;, err)          return       }       fmt.Println(&quot;服务器写来：&quot;, string(buf[:n]))    } }</code></pre><h2 id="UDP与TCP的差异"><a href="#UDP与TCP的差异" class="headerlink" title="UDP与TCP的差异"></a>UDP与TCP的差异</h2><table><thead><tr><th>TCP</th><th>UDP</th></tr></thead><tbody><tr><td>面向连接</td><td>面向无连接</td></tr><tr><td>要求系统资源较多</td><td>要求系统资源较少</td></tr><tr><td>TCP程序结构较复杂</td><td>UDP程序结构较简单</td></tr><tr><td>使用流式</td><td>使用数据包式</td></tr><tr><td>保证数据准确性</td><td>不保证数据准确性</td></tr><tr><td>保证数据顺序</td><td>不保证数据顺序</td></tr><tr><td>通讯速度较慢</td><td>通讯速度较快</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> udp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Go特性7】Socket编程之TCP</title>
      <link href="/2020/12/31/go-feature-socket-tcp/"/>
      <url>/2020/12/31/go-feature-socket-tcp/</url>
      
        <content type="html"><![CDATA[<h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><p><img src="http://qlkvpxmsx.hd-bkt.clouddn.com/TCP%E7%9A%84C%3AS%E6%9E%B6%E6%9E%84.png" alt></p><h2 id="简单C-S模型通信"><a href="#简单C-S模型通信" class="headerlink" title="简单C/S模型通信"></a>简单C/S模型通信</h2><h3 id="Server端"><a href="#Server端" class="headerlink" title="Server端"></a>Server端</h3><p>Listen函数：</p><pre><code>func Listen(network, address string) (Listener, error)    network：选用的协议：TCP、UDP，     如：“tcp”或 “udp”    address：IP地址+端口号,             如：“127.0.0.1:8000”或 “:8000”</code></pre><p>Listener 接口：</p><pre><code>type Listener interface {        Accept() (Conn, error)        Close() error        Addr() Addr}</code></pre><p>Conn 接口：</p><pre><code>type Conn interface {    Read(b []byte) (n int, err error)    Write(b []byte) (n int, err error)    Close() error    LocalAddr() Addr    RemoteAddr() Addr    SetDeadline(t time.Time) error    SetReadDeadline(t time.Time) error    SetWriteDeadline(t time.Time) error}</code></pre><p>示例代码：</p><pre><code>//TCP服务器.gopackage main  import (    &quot;net&quot;    &quot;fmt&quot; )  func main()  {    // 创建一个用于监听的socket套接字    listener, err:= net.Listen(&quot;tcp&quot;, &quot;:8000&quot;)    if err != nil {       fmt.Println(&quot;listen err:&quot;, err)       return    }    defer listener.Close()          // 主协程结束时，关闭listener     fmt.Println(&quot;服务器等待客户端建立连接...&quot;)    // 等待客户端连接请求    conn, err := listener.Accept()    if err != nil {       fmt.Println(&quot;accept err:&quot;, err)       return    }   defer conn.Close()             // 使用结束，断开与客户端链接    fmt.Println(&quot;客户端与服务器连接建立成功...&quot;)     // 接收客户端数据    buf := make([]byte, 1024)        // 创建1024大小的缓冲区，用于read    n, err := conn.Read(buf)    if err != nil {       fmt.Println(&quot;read err:&quot;, err)       return    }    fmt.Println(&quot;服务器读到:&quot;, string(buf[:n])) // 读多少，打印多少。 }</code></pre><p>如图，在整个通信过程中，<font color="red">服务器端有两个socket参与进来，但用于通信的只有 conn 这个socket</font>。它是由 listener创建的。隶属于服务器端。</p><p><img src="http://qlkvpxmsx.hd-bkt.clouddn.com/%E5%9B%BE%E7%89%87%201.png" alt></p><h3 id="Client端"><a href="#Client端" class="headerlink" title="Client端"></a>Client端</h3><p>Dial函数：</p><pre><code>func Dial(network, address string) (Conn, error)    network：选用的协议：TCP、UD`P，如：“tcp”或 “udp”    address：服务器IP地址+端口号, 如：“121.36.108.11:8000”或 “www.itcast.cn:8000”</code></pre><p>Conn 接口：</p><pre><code>type Conn interface {    Read(b []byte) (n int, err error)    Write(b []byte) (n int, err error)    Close() error    LocalAddr() Addr    RemoteAddr() Addr    SetDeadline(t time.Time) error    SetReadDeadline(t time.Time) error    SetWriteDeadline(t time.Time) error}</code></pre><p>示例代码：</p><pre><code>package main  import (    &quot;net&quot;    &quot;fmt&quot; )  func main() {    // 主动发起连接请求    conn, err := net.Dial(&quot;tcp&quot;, &quot;127.0.0.1:8000&quot;)    if err != nil {       fmt.Println(&quot;Dial err:&quot;, err)       return    }    defer conn.Close()         // 结束时，关闭连接     // 发送数据    _, err = conn.Write([]byte(&quot;Are u ready?&quot;))    if err != nil {       fmt.Println(&quot;Write err:&quot;, err)       return    } }</code></pre><h2 id="并发的C-S模型通信"><a href="#并发的C-S模型通信" class="headerlink" title="并发的C/S模型通信"></a>并发的C/S模型通信</h2><h3 id="并发Server"><a href="#并发Server" class="headerlink" title="并发Server"></a>并发Server</h3><p>现在已经完成了客户端与服务端的通信，但是服务端只能接收一个用户发送过来的数据，怎样接收多个客户端发送过来的数据，实现一个高效的并发服务器呢？</p><p><img src="http://qlkvpxmsx.hd-bkt.clouddn.com/%E5%B9%B6%E5%8F%91%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1.png" alt></p><p>Accept(())函数的作用是等待客户端的链接，如果客户端没有链接，该方法会阻塞。如果有客户端链接，那么该方法返回一个Socket负责与客户端进行通信。所以，每来一个客户端，该方法就应该返回一个Socket与其通信，因此，可以使用一个死循环，将Accept(())调用过程包裹起来。</p><p><font color="red">需要注意的是，实现并发处理多个客户端数据的服务器，就需要针对每一个客户端连接，单独产生一个Socket，并创建一个单独的goroutine与之完成通信。</font></p><pre><code>//监听    listener, err := net.Listen(&quot;tcp&quot;, &quot;127.0.0.1:8001&quot;)    if err != nil {            fmt.Println(&quot;err = &quot;, err)            return    }    defer listener.Close()    //接收多个用户    for {            conn, err := listener.Accept()            if err != nil {                  fmt.Println(&quot;err = &quot;, err)                    return            }            //处理用户请求, 新建一个协程            go HandleConn(conn)}</code></pre><p>将客户端的数据处理工作封装到HandleConn方法中，需将Accept()返回的Socket传递给该方法，变量conn的类型为：net.Conn。可以使用conn.RemoteAddr()来获取成功与服务器建立连接的客户端IP地址和端口号：</p><p>Conn 接口：</p><pre><code>type Conn interface {    Read(b []byte) (n int, err error)    Write(b []byte) (n int, err error)    Close() error    LocalAddr() Addr    RemoteAddr() Addr    SetDeadline(t time.Time) error    SetReadDeadline(t time.Time) error    SetWriteDeadline(t time.Time) error}</code></pre><pre><code>//获取客户端的网络地址信息addr := conn.RemoteAddr().String()fmt.Println(addr, &quot; conncet sucessful&quot;)</code></pre><p><font color="red">客户端可能持续不断的发送数据，因此接收数据的过程可以放在for循环中</font>，服务端也持续不断的向客户端返回处理后的数据。</p><p>添加一个限定，如果客户端发送一个“exit”字符串，表示客户端通知服务器不再向服务端发送数据，此时应该结束HandleConn方法，同时关闭与该客户端关联的Socket。</p><pre><code>buf := make([]byte, 2048)    //创建一个切片，存储客户端发送的数据for {        //读取用户数据         n, err := conn.Read(buf)        if err != nil {            fmt.Println(&quot;err = &quot;, err)            return        }        fmt.Printf(&quot;[%s]: %s\n&quot;, addr, string(buf[:n]))        if  &quot;exit&quot; == string(buf[:n-2]) {         //自己写的客户端测试, 发送时，多了2个字符, &quot;\r\n&quot;            fmt.Println(addr, &quot; exit&quot;)            return        }        //服务器处理数据：把客户端数据转大写，再写回给client        conn.Write([]byte(strings.ToUpper(string(buf[:n])))) }</code></pre><p>在上面的代码中，Read(())方法获取客户端发送过来的数据，填充到切片buf中，返回的是实际填充的数据的长度，所以将客户端发送过来的数据进行打印，打印的是实际接收到的数据。</p><pre><code>fmt.Printf(&quot;[%s]: %s\n&quot;, addr, string(buf[:n])).</code></pre><p>同时也可以将客户端的网络地址信息打印出来。<br>在判断客户端数据是否为“exit”字符串时，要注意，客户端会自动的多发送2个字符：“\r\n”（这在windows系统下代表回车、换行）</p><p>Server使用Write方法将数据写回给客户端，参数类型是 []byte，需使用strings包下的ToUpper函数来完成大小写转换。转换的对象即为string((buf[:n]))</p><p>综上，HandleConn方法完整定义如下：</p><pre><code>//处理用户请求func HandleConn(conn net.Conn) {//函数调用完毕，自动关闭conndefer conn.Close()          //获取客户端的网络地址信息          addr := conn.RemoteAddr().String()          fmt.Println(addr, &quot; conncet sucessful&quot;)          buf := make([]byte, 2048)          for {                  //读取用户数据                 n, err := conn.Read(buf)                 if err != nil {                         fmt.Println(&quot;err = &quot;, err)                         return                    }                    fmt.Printf(&quot;[%s]: %s\n&quot;,  addr,  string(buf[:n]))                fmt.Println(&quot;len = &quot;, len(string(buf[:n])))                        //if &quot;exit&quot; == string(buf[:n-1]) {     // nc测试，发送时，只有 \n                 if  &quot;exit&quot; == string(buf[:n-2]) {    // 自己写的客户端测试, 发送时，多了2个字符, &quot;\r\n&quot;                        fmt.Println(addr, &quot; exit&quot;)                        return                 }                 //把数据转换为大写，再给用户发送                 conn.Write([]byte(strings.ToUpper(string(buf[:n]))))          }}</code></pre><h3 id="并发Client"><a href="#并发Client" class="headerlink" title="并发Client"></a>并发Client</h3><p>客户端不仅需要持续的向服务端发送数据，同时也要接收从服务端返回的数据。因此可将发送和接收放到不同的协程中。</p><p>主协程循环接收服务器回发的数据（该数据应已转换为大写），并打印至屏幕；子协程循环从键盘读取用户输入数据，写给服务器。读取键盘输入可使用 os.Stdin.Read((str))。定义切片str，将读到的数据保存至str中。</p><p>这样，客户端也实现了多任务。</p><p>客户端代码实现：</p><pre><code>package main  import (    &quot;net&quot;    &quot;fmt&quot;    &quot;os&quot; )  func main() {    // 主动发起连接请求    conn, err := net.Dial(&quot;tcp&quot;, &quot;127.0.0.1:8001&quot;)    if err != nil {       fmt.Println(&quot;Dial err:&quot;, err)       return    }    defer conn.Close()                       // 客户端终止时，关闭与服务器通信的 socket      // 启动子协程，接收用户键盘输入    go func() {        str := make([]byte, 1024)           // 创建用于存储用户键盘输入数据的切片缓冲区。       for {                                // 反复读取          n, err :=os.Stdin.Read(str)        // 获取用户键盘输入          if err != nil {             fmt.Println(&quot;os.Stdin.Read err:&quot;, err)             return          }          // 将从键盘读到的数据，发送给服务器          _, err = conn.Write(str[:n])       // 读多少，写多少          if err != nil {             fmt.Println(&quot;conn.Write err:&quot;, err)             return          }       }    }()     // 主协程，接收服务器回发数据，打印至屏幕    buf := make([]byte, 1024)                // 定义用于存储服务器回发数据的切片缓冲区    for {       n, err := conn.Read(buf)              // 从通信 socket 中读数据，存入切片缓冲区       if err != nil {          fmt.Println(&quot;conn.Read err:&quot;, err)          return       }       fmt.Printf(&quot;服务器回发：%s\n&quot;, string(buf[:n]))    } }</code></pre><h2 id="TCP通信"><a href="#TCP通信" class="headerlink" title="TCP通信"></a>TCP通信</h2><p>下图是一次TCP通讯的时序图。TCP连接建立断开。包含大家熟知的三次握手和四次握手。</p><p><img src="http://qlkvpxmsx.hd-bkt.clouddn.com/TCP%E9%80%9A%E4%BF%A1.png" alt></p><p>在这个例子中，首先客户端主动发起连接、发送请求，然后服务器端响应请求，然后客户端主动关闭连接。两条竖线表示通讯的两端，从上到下表示时间的先后顺序。注意，数据从一端传到网络的另一端也需要时间，所以图中的箭头都是斜的。</p><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>所谓三次握手（Three-Way Handshake）即建立TCP连接，就是指建立一个TCP连接时，需要客户端和服务端总共发送3个包以确认连接的建立。好比两个人在打电话：<br>Client:“喂，你听得到吗？”<br>Server:“我听得到，你听得到我吗？”<br>Client:“我能听到你，今天balabala…”</p><p>建立连接（三次握手）的过程：</p><ol><li>客户端发送一个带SYN标志的TCP报文到服务器。这是上图中三次握手过程中的段1。客户端发出SYN位表示连接请求。序号是1000，这个序号在网络通讯中用作临时的地址，每发一个数据字节，这个序号要加1，这样在接收端可以根据序号排出数据包的正确顺序，也可以发现丢包的情况。<br>另外，规定SYN位和FIN位也要占一个序号，这次虽然没发数据，但是由于发了SYN位，因此下次再发送应该用序号1001。<br>mss表示最大段尺寸，如果一个段太大，封装成帧后超过了链路层的最大长度，就必须在IP层分片，为了避免这种情况，客户端声明自己的最大段尺寸，建议服务器端发来的段不要超过这个长度。</li><li>服务器端回应客户端，是三次握手中的第2个报文段，同时带ACK标志和SYN标志。表示对刚才客户端SYN的回应；同时又发送SYN给客户端，询问客户端是否准备好进行数据通讯。<br>服务器发出段2，也带有SYN位，同时置ACK位表示确认，确认序号是1001，表示“我接收到序号1000及其以前所有的段，请你下次发送序号为1001的段”，也就是应答了客户端的连接请求，同时也给客户端发出一个连接请求，同时声明最大尺寸为1024。</li><li>客户必须再次回应服务器端一个ACK报文，这是报文段3。<br>客户端发出段3，对服务器的连接请求进行应答，确认序号是8001。</li></ol><p>在这个过程中，客户端和服务器分别给对方发了连接请求，也应答了对方的连接请求，其中服务器的请求和应答在一个段中发出。<br>因此一共有三个段用于建立连接，称为“三方握手”。在建立连接的同时，双方协商了一些信息，例如，双方发送序号的初始值、最大段尺寸等。</p><h3 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h3><ol><li>客户端发出段4，包含从序号1001开始的20个字节数据。</li><li>服务器发出段5，确认序号为1021，对序号为1001-1020的数据表示确认收到，同时请求发送序号1021开始的数据，服务器在应答的同时也向客户端发送从序号8001开始的10个字节数据。</li><li>客户端发出段6，对服务器发来的序号为8001-8010的数据表示确认收到，请求发送序号8011开始的数据。</li></ol><p>在数据传输过程中，ACK和确认序号是非常重要的，应用程序交给TCP协议发送的数据会暂存在TCP层的发送缓冲区中，发出数据包给对方之后，只有收到对方应答的ACK段才知道该数据包确实发到了对方，可以从发送缓冲区中释放掉了，如果因为网络故障丢失了数据包或者丢失了对方发回的ACK段，经过等待超时后TCP协议自动将发送缓冲区中的数据包重发。</p><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p>所谓四次挥手（Four-Way-Wavehand）即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。在socket编程中，这一过程由客户端或服务器任一方执行close来触发。好比两个人打完电话要挂断：<br>Client:“我要说的事情都说完了，我没事了。挂啦？”<br>Server:“等下，我还有一个事儿。Balabala…”<br>Server:“好了，我没事儿了。挂了啊。”<br>Client:“ok！拜拜”</p><p>关闭连接（四次握手）的过程：</p><p>由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。</p><ol><li>客户端发出段7，FIN位表示关闭连接的请求。</li><li>服务器发出段8，应答客户端的关闭连接请求。</li><li>服务器发出段9，其中也包含FIN位，向客户端发送关闭连接请求。</li><li>客户端发出段10，应答服务器的关闭连接请求。</li></ol><p>建立连接的过程是三次握手，而关闭连接通常需要4个段，服务器的应答和关闭连接请求通常不合并在一个段中，因为有连接半关闭的情况，这种情况下客户端关闭连接之后就不能再发送数据给服务器了，但是服务器还可以发送数据给客户端，直到服务器也关闭连接为止。</p><p><img src="http://qlkvpxmsx.hd-bkt.clouddn.com/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E3%80%814%E6%AC%A1%E6%8C%A5%E6%89%8B.png" alt></p><h3 id="TCP状态转换图"><a href="#TCP状态转换图" class="headerlink" title="TCP状态转换图"></a>TCP状态转换图</h3><p><img src="http://qlkvpxmsx.hd-bkt.clouddn.com/TCP%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%9B%BE.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> tcp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【leetcode-567】字符串的排列</title>
      <link href="/2020/12/30/leetcode-567/"/>
      <url>/2020/12/30/leetcode-567/</url>
      
        <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/permutation-in-string/" target="_blank" rel="noopener">567. 字符串的排列</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定两个字符串 s1 和 s2，写一个函数来判断 s2 是否包含 s1 的排列。</p><p>换句话说，第一个字符串的排列之一是第二个字符串的子串。</p><p>示例1:</p><pre><code>输入: s1 = &quot;ab&quot; s2 = &quot;eidbaooo&quot;输出: True解释: s2 包含 s1 的排列之一 (&quot;ba&quot;).</code></pre><p>示例2:</p><pre><code>输入: s1= &quot;ab&quot; s2 = &quot;eidboaoo&quot;输出: False</code></pre><p>注意：</p><ol><li>输入的字符串只包含小写字母</li><li>两个字符串的长度都在 [1, 10,000] 之间</li></ol><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>这道题的直接思路是先对子串s1进行全排列，然后将每种排列去s2中找，但是由于全排列的时间复杂度为O((n!))，所以不可能这么做，也就是说我们需要换一种思路。</p><p>现在我们换一种问法，能否s2中找到一个子串，使得这个子串包含s1中的所有字符但是不包含其他字符？</p><p>作为字符串匹配问题，我们很容易就想到滑动窗口算法。既然采用滑动窗口算法，就需要套算法框架：</p><pre><code>/* 滑动窗口算法框架 */void slidingWindow(string s, string t) {    unordered_map&lt;char, int&gt; need, window;    for (char c : t) need[c]++;    int left = 0, right = 0;    int valid = 0;     while (right &lt; s.size()) {        // c 是将移入窗口的字符        char c = s[right];        // 右移窗口        right++;        // 进行窗口内数据的一系列更新        ...        /*** debug 输出的位置 ***/        printf(&quot;window: [%d, %d)\n&quot;, left, right);        /********************/        // 判断左侧窗口是否要收缩        while (window needs shrink) {            // d 是将移出窗口的字符            char d = s[left];            // 左移窗口            left++;            // 进行窗口内数据的一系列更新            ...        }    }}</code></pre><p>对于这个问题，我们主要需要注意的点在于：</p><ol><li>判断窗口收缩的条件是什么？</li><li>何时返回true？</li></ol><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code>func checkInclusion(s1 string, s2 string) bool {    // 用map定义滑动窗口和目标子串    window, need := make(map[byte]int), make(map[byte]int)    // 初始化目标子串    for _, v := range s1 {        need[byte(v)]++    }    // 定义窗口左右边界    left, right := 0,0    // 记录已经凑足的有效字符种类数    valid := 0    // 右边界没到底    for right != len(s2)  {        // 记录当前字符        c := s2[right]        // 右边界右移        right++        // 将此字符加入窗口        window[c]++        // 如果这个字符所需个数已经满足要求，valid++        if window[c] == need[c] {            valid++        }        // 如果字符总个数已经达到了要求字符数，可能是一种全排列，准备缩小窗口        for right - left == len(s1)  {            // 字符总个数和对应字符数均符合，说明刚好是一种全排列，直接返回true            if valid == len(need) {                return true            }            // 走到这里说明不是一种全排列，缩小窗口            c := s2[left]            // 如果减去这个字符之后会导致这个字符的个数不足，那么valid--            if window[c] == need[c] {                valid--            }            // 缩小窗口            window[c]--            left++            }    }    // 已经走到底了还是没有符合要求的字符串    return false}</code></pre><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><h3 id="时间复杂度：O-n"><a href="#时间复杂度：O-n" class="headerlink" title="时间复杂度：O((n))"></a>时间复杂度：O((n))</h3><p>在最坏的情况下，两个指针都要扫描整个字符串S一遍，如果字符串的长度为n，则时间复杂度是O((2n))=O((n))</p><h3 id="空间复杂度：O-C"><a href="#空间复杂度：O-C" class="headerlink" title="空间复杂度：O((C))"></a>空间复杂度：O((C))</h3><p>采用了两个辅助的map，用于记录当前窗口的字符串和子串，如果子串字符种类数为C，则空间复杂度为O((C))</p><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><p>写出滑动窗口算法的框架不难，难的是处理好细节问题，而这个细节问题则需要具体问题具体分析，比如对于这道题，需要注意的就是：</p><ol><li><p>何时不再扩张窗口（右边界不移动）？</p><p> 由于各种全排列的字符数量是固定的，所以一旦窗口扩张到字符数量到了目标子串的数量，那么就需要查看是否已经得到了满足要求的子串，如果没有，则需要移动左边界，缩小窗口，然后右边界继续右移。</p></li><li><p>何时返回 true ？</p><p> 当进入缩小窗口循环的时候，说明字符总数已经匹配了，那么只要再满足一个条件，就是对应字符的数量匹配就说明是一个合法的排列了，可以直接返回true。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Go特性6】Socket编程初探</title>
      <link href="/2020/12/29/go-feature-socket/"/>
      <url>/2020/12/29/go-feature-socket/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是Socket"><a href="#什么是Socket" class="headerlink" title="什么是Socket?"></a>什么是Socket?</h1><p>Socket，英文含义是【插座、插孔】，一般称之为套接字，用于描述IP地址和端口。可以实现不同程序间的数据通信。</p><p>Socket起源于Unix，而Unix基本哲学之一就是“一切皆文件”，都可以用“打开open –&gt; 读写write/read –&gt; 关闭close”模式来操作。Socket就是该模式的一个实现，网络的Socket数据传输是一种特殊的I/O，Socket也是一种文件描述符。Socket也具有一个类似于打开文件的函数调用：Socket()，该函数返回一个整型的Socket描述符，随后的连接建立、数据传输等操作都是通过该Socket实现的。</p><p>套接字的内核实现较为复杂，不宜在学习初期深入学习，了解到如下结构足矣。</p><p><img src="http://qlkvpxmsx.hd-bkt.clouddn.com/%E5%A5%97%E6%8E%A5%E5%AD%97.png" alt></p><p>在TCP/IP协议中，“IP地址+TCP或UDP端口号”唯一标识网络通讯中的一个进程。“IP地址+端口号”就对应一个socket。欲建立连接的两个进程各自有一个socket来标识，那么这两个socket组成的socket pair就唯一标识一个连接。因此可以用Socket来描述网络连接的一对一关系。</p><p>常用的Socket类型有两种：流式Socket（SOCK_STREAM）和数据报式Socket（SOCK_DGRAM）。流式是一种面向连接的Socket，针对于面向连接的TCP服务应用；数据报式Socket是一种无连接的Socket，对应于无连接的UDP服务应用。</p><h1 id="网络应用程序设计模式"><a href="#网络应用程序设计模式" class="headerlink" title="网络应用程序设计模式"></a>网络应用程序设计模式</h1><h3 id="C-S模式"><a href="#C-S模式" class="headerlink" title="C/S模式"></a>C/S模式</h3><p>传统的网络应用设计模式，客户机(client)/服务器(server)模式。需要在通讯两端各自部署客户机和服务器来完成数据通信。</p><ul><li>优点</li></ul><p>客户端位于目标主机上可以<font color="blue">保证性能，将数据缓存至客户端本地，从而提高数据传输效率</font>。且，一般来说客户端和服务器程序由一个开发团队创作，所以他们之间所采用的协议相对灵活。可以在标准协议的基础上根据需求裁剪及定制。例如，腾讯所采用的通信协议，即为ftp协议的修改剪裁版。</p><p>因此，<font color="blue">传统的网络应用程序及较大型的网络应用程序都首选C/S模式进行开发。</font>如，知名的网络游戏魔兽世界。3D画面，数据量庞大，<font color="blue">使用C/S模式可以提前在本地进行大量数据的缓存处理，从而提高观感。</font></p><ul><li>缺点</li></ul><p>由于客户端和服务器都需要有一个开发团队来完成开发。<font color="blue">工作量将成倍提升，开发周期较长</font>。另外，从用户角度出发，<font color="blue">需要将客户端安插至用户主机上，对用户主机的安全性构成威胁</font>。这也是很多用户不愿使用C/S模式应用程序的重要原因。</p><h3 id="B-S模式"><a href="#B-S模式" class="headerlink" title="B/S模式"></a>B/S模式</h3><p>浏览器(Browser)/服务器(Server)模式。只需在一端部署服务器，而另外一端使用每台PC都默认配置的浏览器即可完成数据的传输。</p><ul><li>优点</li></ul><p>B/S模式相比C/S模式而言，由于它没有独立的客户端，使用标准浏览器作为客户端，其工作开发量较小。只需开发服务器端即可。另外由于其采用浏览器显示数据，因此<font color="blue">移植性非常好，不受平台限制</font>。如早期的偷菜游戏，在各个平台上都可以完美运行。</p><ul><li>缺点</li></ul><p>由于使用第三方浏览器，因此网络应用支持受限。另外，没有客户端放到对方主机上，<font color="blue">缓存数据不尽如人意，从而传输数据量受到限制。应用的观感大打折扣。第三，必须与浏览器一样，采用标准http协议进行通信，协议选择不灵活</font>。</p><p>因此在开发过程中，模式的选择由上述各自的特点决定。根据实际需求选择应用程序设计模式。</p>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【leetcode-76】最小覆盖子串</title>
      <link href="/2020/12/27/leetcode-76/"/>
      <url>/2020/12/27/leetcode-76/</url>
      
        <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/minimum-window-substring/" target="_blank" rel="noopener">76. 最小覆盖子串</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “” 。</p><p>注意：如果 s 中存在这样的子串，我们保证它是唯一的答案。</p><p>示例 1：</p><pre><code>输入：s = &quot;ADOBECODEBANC&quot;, t = &quot;ABC&quot;输出：&quot;BANC&quot;</code></pre><p>示例 2：</p><pre><code>输入：s = &quot;a&quot;, t = &quot;a&quot;输出：&quot;a&quot;</code></pre><p>提示：</p><ul><li>1 &lt;= s.length, t.length &lt;= 105</li><li>s 和 t 由英文字母组成</li></ul><p>进阶：你能设计一个在 o((n) 时间内解决此问题的算法吗？</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>这题我们当然可以用暴力解法，即以字符串s的每一个字符为起点进行枚举，从中筛选出符合题且长度最小的子串，但是这个算法的时间复杂度将大于O((n))，所以肯定不是最优解。</p><p>实际上子串的问题都可以考虑通过双指针技巧减少时间复杂度，链表一般用快慢指针、数组一般用左右指针，而左右指针又常用于二分搜索，而这道题则是属于左右指针中最难的一类，滑动窗口算法。</p><p>直接上滑动窗口算法框架：</p><pre><code>/* 滑动窗口算法框架 */void slidingWindow(string s, string t) {    unordered_map&lt;char, int&gt; need, window;    for (char c : t) need[c]++;    int left = 0, right = 0;    int valid = 0;     while (right &lt; s.size()) {        // c 是将移入窗口的字符        char c = s[right];        // 右移窗口        right++;        // 进行窗口内数据的一系列更新        ...        /*** debug 输出的位置 ***/        printf(&quot;window: [%d, %d)\n&quot;, left, right);        /********************/        // 判断左侧窗口是否要收缩        while (window needs shrink) {            // d 是将移出窗口的字符            char d = s[left];            // 左移窗口            left++;            // 进行窗口内数据的一系列更新            ...        }    }}</code></pre><p>对于这道题，滑动窗口算法的思路是这样：</p><ol><li><p>我们在字符串 S 中使用双指针中的左右指针技巧，初始化 left = right = 0，把索引左闭右开区间 [left, right) 称为一个「窗口」。</p></li><li><p>我们先不断地增加 right 指针扩大窗口 [left, right)，直到窗口中的字符串符合要求（包含了 T 中的所有字符）。</p></li><li><p>此时，我们停止增加 right，转而不断增加 left 指针缩小窗口 [left, right)，直到窗口中的字符串不再符合要求（不包含 T 中的所有字符了）。同时，每次增加 left，我们都要更新一轮结果。</p></li><li><p>重复第 2 和第 3 步，直到 right 到达字符串 S 的尽头。</p></li></ol><p>实际上这道题的思路已经很清晰了，接下来就是一些细节问题，需要边写代码边处理。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code>func minWindow(s string, t string) string {    // 定义滑动窗口以及目标子串    window, need := make(map[byte]int, 0), make(map[byte]int, 0)    // 初始化目标子串    for _, c := range t {        need[byte(c)]++    }    // 定义窗口左右边界    left, right := 0, 0    // 定义当前窗口已经包含的有效字符种类数    valid := 0    // 记录最小覆盖子串的起始索引及长度（只可能小于等于s）    start, minLength := 0, len(s) + 1    //滑动终止条件（窗口右边界小于母串长度）    for right &lt; len(s) {        // c是即将移入窗口的字符        c := s[right]        // 右边界右移        right++        // 如果c是有效字符,更新当前窗口c的个数        if need[c] != 0 {            window[c]++            // 当前窗口内的该类字符已经凑足了，更新valid            if window[c] == need[c]{                valid++            }        }        // 判断左侧窗口是否要收缩(所有所需字符已经凑足)        // 注意这里是for而不是if，因为只要满足条件，就要不断缩小窗口        for valid == len(need) {            // 先获得一个结果，再试图缩小窗口            // 先更新最小覆盖串            if right - left &lt; minLength {                // start记录了当前子串的起点，跟minLength一起确定一个字符串                start = left                minLength = right - left            }            // 继续缩小窗口            // c是即将移出窗口的字符            c := s[left]            // 左边界右移            left++            // 如果c是有效字符,更新当前窗口c的个数            if need[c] != 0 {                window[c]--                // 更新完后，检查是c的个数仍然满足所需个数，不满足，则更新valid                if window[c] &lt; need[c] {                    valid--                }            }        }    }    // 如果最小长度有变化，则说明找到了    if minLength != len(s) + 1 {        return s[start:start+minLength]    }    return &quot;&quot;}</code></pre><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><h3 id="时间复杂度：O-n"><a href="#时间复杂度：O-n" class="headerlink" title="时间复杂度：O((n))"></a>时间复杂度：O((n))</h3><p>在最坏的情况下，两个指针都要扫描整个字符串S一遍，如果字符串的长度为n，则时间复杂度是O((2n))=O((n))</p><h3 id="空间复杂度：O-C"><a href="#空间复杂度：O-C" class="headerlink" title="空间复杂度：O((C))"></a>空间复杂度：O((C))</h3><p>采用了两个辅助的map，用于记录当前窗口的字符串和子串，如果子串长度为C，则空间复杂度为O((C))</p><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><p>滑动窗口算法属于比较难的一类问题，但是如果一旦确定了用滑动窗口算法就只需要套模版就行了，剩下的就是细节问题，比如对于这道题，我忽略的细节问题主要有两处：</p><ul><li>在缩小窗口，也就是移动左指针时，判断结束条件采用的是for，而不是if，因为只要当前子串满足条件，就要不断缩小窗口，这样才能找到一个最短的子串。</li><li>依旧是指针左移时，进入循环的第一件事应该是先获得一个结果，就是记录当前子串并更新最小子串，然后再试图，往移动左指针，缩小窗口。</li></ul><p>此外，还有一个小技巧，就是移动右指针和移动左指针的操作非常相似，有比较好的对称关系，这样可以方便记忆。</p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fabric 1.4源码分析:BCCSP模块</title>
      <link href="/2020/12/26/fabric-bccsp/"/>
      <url>/2020/12/26/fabric-bccsp/</url>
      
        <content type="html"><![CDATA[<h1 id="模块简介"><a href="#模块简介" class="headerlink" title="模块简介"></a>模块简介</h1><blockquote><p>注: 本文所涉及的代码均基于fabric 1.4.6的版本，其他版本可能会略有不同，但大体相似</p></blockquote><p>BCCSP ( Blockchain Cryptographic Service Provider)为 Fabric 其他模块(如 MSP 组件 等)提供密码服务套件，包括<font color="red">加密、解密、签名与验证、哈希函数</font>等方法。目前，原生fabric的BCCSP模块提供了 PKCS11类型和SW类型两种基本实现。</p><p>其中：</p><ul><li>PKCS11 (Public-Key Cryptography Standards)类型是基于 HSM ( Hardware Security Modules)硬件安全模块(https:// github.com/miekg/pkcsll )的加密服务实现,属于通用的接口标准，利 用pkcsll库提供的上下文对象pkcsl l.Ctx在SessionHandle基础上支持密码服务</li><li>SW类型是基于软件的加密服务实现的，直接使用crypto库下的包支持密码服务。同时，BCCSP 模块可提供对应的两类工厂对象，其他模块则基于这两类工厂对象调用对应的密码服务接口。</li></ul><p>本着一切从源码的角度出发，我们先来看看在fabric中的BCCSP模块的代码目录。</p><pre><code>$ tree ./bccsp -L 1./bccsp├── factory             初始化BCCSP对象及其工厂对象├── gm                  实现软件加密(国密)的BCCSP、key和keystore接口├── idemix              身份混淆器(和零知识证明有关)├── mocks               用于mock测试├── pkcs11              实现硬件加密的BCCSP、key和keystore接口├── signer              基于bccsp实现crypto.Signer├── sw                  实现软件加密(标准加密)的BCCSP、key和keystore接口└── utils               一些独立封装的辅助函数├── bccsp.go            定义BCCSP、key接口├── keystore.go         定义keystore接口├── idemixerrs.go       定义了idemix的err├── ecdsaopts.go        ├── aesopts.go├── gmopts.go├── hashopts.go         实现各自的opts接口├── idemixopts.go├── opts.go└── rsaopts.go</code></pre><p>这样过了一遍bccsp的代码目录之后，相信大家会对BCCSP模块有一些印象，但是还是没法获得一个整体的认知。下面，我们从一个更宏观的角度来理解bccsp模块的整体架构。</p><h1 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h1><p>我根据自己的理解画了一幅bccsp模块架构图，省略掉了细节，只保留了我认为的关键部分，如有不当之处还望大佬指正。</p><p><img src="http://qlkvpxmsx.hd-bkt.clouddn.com/BCCSP%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84.png" alt></p><p>如图所示，从上往下，我们依次分析。</p><h3 id="上层调用模块"><a href="#上层调用模块" class="headerlink" title="上层调用模块"></a>上层调用模块</h3><p>这一层主要是msp模块，msp模块是Fabric架构重要的系统抽象组件，为客户端、Peer<br>节点、Orderer节点等提供PKI数字证书以管理组织成员身份，从而有效控制资源实体（组<br>织、成员等）的认证、授权、撤销等身份权限操作。</p><p>而msp要实现组织和成员的认证、授权和撤销等操作就不可避免地需要用到加密、解密、签名与验证、哈希等方法，而这些方法则由BCCSP模块去完成。</p><h3 id="BCCSP模块"><a href="#BCCSP模块" class="headerlink" title="BCCSP模块"></a>BCCSP模块</h3><p>具体的，这些方法被bccsp模块拆分成了四类接口，分别是BCCSP接口、key接口、keystore接口、opts系列接口（一共有7个）。</p><p>其中：</p><ul><li>BCCSP接口定义了加密、解密、签名、验签和哈希等10个方法。</li><li>key接口定义了密钥管理等5个方法。</li><li>keystore接口定义了密钥存储等3个方法。</li><li>opts接口定义了主要用来返回参数密钥名称和是否需要持久化密钥（大部分没有给出实现）。</li></ul><p>关于这些接口下文会详细介绍，这里先简单了解一下即可。</p><p>为了实现这四套接口，目前有多种实现，主要包括fabric原生的pkcs11硬件加密插件和sw软件加密插件，以及我们自己实现的gm国密插件，其中sw和gm都属于软实现。</p><blockquote><p>扩展阅读：密码学通常有软实现和硬实现，软实现就是常用的各种加密库，比如Go中crypto包，硬实现是使用加密机提供的一套加密服务。软实现和硬实现的重要区别是，密码算法的安全性强依赖随机数，软实现利用的是OS的伪随机数，而硬实现利用的是加密机生成的随机数，所以硬实现的安全强度要高于软实现。</p></blockquote><h3 id="底层实现模块"><a href="#底层实现模块" class="headerlink" title="底层实现模块"></a>底层实现模块</h3><p>目前这些加密插件都需要依赖底层加密库实现。</p><ul><li>对于SW加密插件，目前底层直接依赖于 Go SDK 原生的加密库(主要是crypto包)；</li><li>对于pkcs11加密插件，目前主要依赖的是github上开源的第三方库<br><a href="https://github.com/miekg/pkcs11，" target="_blank" rel="noopener">https://github.com/miekg/pkcs11，</a> 该加密库是PKCS11 API的Go实现。它对库进行了严密的包装，但在有意义的地方使用了Go风格，它已经和SoftHSM测试过了。当然，它也可以直接上硬件加密机。</li><li>对于GM国密插件, 目前主要是利用开源的第三方国密库，比如同济的 <a href="https://github.com/tjfoc/gmsm/" target="_blank" rel="noopener">gmsm库</a><br>当然，也可以考虑直接用支持国密的加密机实现，只需要做一些接口的适配工作即可。</li></ul><h1 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a>运行流程</h1><p>刚才我们都是看的都是静态的代码，接下来我们要让代码动起来，了解一下bccsp模块在fabric运行过程中是如何发挥作用的。</p><h2 id="编辑bccsp配置项"><a href="#编辑bccsp配置项" class="headerlink" title="编辑bccsp配置项"></a>编辑bccsp配置项</h2><p>首先我们从配置文件出发：</p><p>在 sampleconfig 目录下的 core.yaml 文件中的BCCSP模块可以对加密实现和加密库进行选择和配置。</p><pre><code>    # BCCSP (Blockchain crypto provider): Select which crypto implementation or    # library to use    BCCSP:        # if setting is GM, chaincode.golang.dynamiclink must be false.        Default: SW        # Settings for the SW crypto provider (i.e. when DEFAULT: SW)        SW:            # TODO: The default Hash and Security level needs refactoring to be            # fully configurable. Changing these defaults requires coordination            # SHA2 is hardcoded in several places, not only BCCSP            Hash: SHA2            Security: 256            Library:            # Location of Key Store            FileKeyStore:                # If &quot;&quot;, defaults to &#39;mspConfigPath&#39;/keystore                KeyStore:        # Settings for the PKCS#11 crypto provider (i.e. when DEFAULT: PKCS11)        PKCS11:            # Location of the PKCS11 module library            Library:            # Token Label            Label:            # User PIN            Pin:            Hash:            Security:            FileKeyStore:                KeyStore:</code></pre><p>通过PEER_BCCSP_DEFAULT 字段可选择那种哪种加密方式，比如我们这边选择SW，那么下面就需要对SW的各个配置项进行配置</p><h2 id="加载BCCSP配置项"><a href="#加载BCCSP配置项" class="headerlink" title="加载BCCSP配置项"></a>加载BCCSP配置项</h2><p>如果我们熟悉fabric节点启动流程的话，就会知道在orderer和peer节点启动的时候会去加载orderer.yaml和peer.yanl配置文件，通过读取里面的配置文件对节点进行初始化。</p><h3 id="orderer节点初始化bccsp"><a href="#orderer节点初始化bccsp" class="headerlink" title="orderer节点初始化bccsp"></a>orderer节点初始化bccsp</h3><p>对于orderer节点来说，该节点的启动命令是orderer start，用于启动主程序的main()函数。 该函数会调用server.Main()主函数，初始化相关组件配置，其中就包括初始化msp组件。该函数位于orderer/common/server/main.go文件中。</p><pre><code>// main函数是orderer节点启动进程的入口func Main() {    ...    //加载orderer.yaml配置文件    conf, err := localconfig.Load()    ...    //初始化本地MSP组件    initializeLocalMsp(conf)    ...}</code></pre><p>它首先调用 localconfig.Load() 方法加载orderer.yaml配置文件<br>，读取其中的配置项，当然也包括bccsp配置项，读取完成后会返回一个TopLevel的实例conf</p><p>然后再由 initializeLocalMsp（conf）函数调用mspmgmt.LoadLocalMsp（）方法, 接受Orderer配置对象conf中的General通用配置输入参数，即MSP配置文件路径LocalMSPDir、BCCSP配置项与MSP名称LocalMSPID,以初始化本地MSP组件。</p><pre><code>// LoadLocalMsp loads the local MSP from the specified directory// 利用MSP配置文件、BCCSP配置项和MSPID初始化本地MSP组件func LoadLocalMsp(dir string, bccspConfig *factory.FactoryOpts, mspID string) error {    ..    conf, err := msp.GetLocalMspConfig(dir, bccspConfig, mspID)    ...}</code></pre><blockquote><p>这里值得注意的是，bccsp的配置项和orderer的其他配置项不太一样，orderer的其他配置项会调用uconf.completeInitialization()方法设置缺省的默认值，而bccsp的配置项则是在msp.GetLocalMspConfig方法中单独设置默认值的：</p></blockquote><pre><code>func GetLocalMspConfig(dir string, bccspConfig *factory.FactoryOpts, ID string) (*msp.MSPConfig, error) {    signcertDir := filepath.Join(dir, signcerts)    keystoreDir := filepath.Join(dir, keystore)    // 设置bccsp配置项缺省的默认值    bccspConfig = SetupBCCSPKeystoreConfig(bccspConfig, keystoreDir)    // 根据bccsp配置项初始化 bccsp factory    err := factory.InitFactories(bccspConfig)    if err != nil {        return nil, errors.WithMessage(err, &quot;could not initialize BCCSP Factories&quot;)    }    ...}</code></pre><p>如代码中所示，设置完缺省值之后就开始始化 bccsp factory，至此为止，就正式进入了我们的bccsp模块。</p><h3 id="peer节点初始化bccsp"><a href="#peer节点初始化bccsp" class="headerlink" title="peer节点初始化bccsp"></a>peer节点初始化bccsp</h3><p>此时我们在来看看peer节点的初始化过程。</p><p>Peer节点启动命令为peer node start,其入口主程序的main()主函数(peer/main.go)负 责初始化peer主命令对象，注册子命令与初始化环境配置，解析用户输入的子命令start并启动Peer节点。</p><pre><code>func main() {    ...    //     mainCmd.AddCommand(node.Cmd())    ...}</code></pre><p>在启动peer节点时会初始化本地MSP组件。通过Viper组件获取core.yaml文件中MSP组件的</p><ul><li>配置文件路径 mspMgrConfigDir</li><li>BCCSP 配置项 bccspConfig</li><li>MSP 名称 ID 即 localMSPID </li><li>MSP 组件类型localMSPType（默认为FABRIC类型）</li></ul><p>提供给common.InitCrypto()函数作为参数进行调用，以获取BCCSP区块链加密服务组件，并用于 初始化本地MSP组件。</p><pre><code>func InitCmd(cmd *cobra.Command, args []string) {    ...    // 初始化本地MSP组件对象    var mspMgrConfigDir = config.GetPath(&quot;peer.mspConfigPath&quot;) // 获取MSP配置文件路径    var mspID = viper.GetString(&quot;peer.localMspId&quot;) // 获取本地MSP名称，比如Org1MSP    var mspType = viper.GetString(&quot;peer.localMspType&quot;) // 获取本地MSP组件类型，这个没找到直接指定的地方    if mspType == &quot;&quot; {        // 应该是走了默认FABRIC路径        mspType = msp.ProviderTypeToString(msp.FABRIC)    }    // 利用上面的BCCSP组件配置信息，初始化MSP组件对象    err = InitCrypto(mspMgrConfigDir, mspID, mspType)    ...}</code></pre><p>其中 peer.mspConfigPath是通过 <strong>CORE_PEER_MSPCONFIGPATH</strong> 进行解析的，它<br>当前msp配置文件路径在byfn环境变量中有指定，比如peer0.org1节点的配置文件路径是</p><pre><code>CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp</code></pre><p>然后就是调用这个InitCrypto方法了</p><pre><code>// InitCrypto initializes crypto for this peer// 初始化MSP组件对象func InitCrypto(mspMgrConfigDir, localMSPID, localMSPType string) error {    ···    // 检查MSP配置文件路径是否存在    fi, err := os.Stat(mspMgrConfigDir)    // 检查localMSPID是否存在    if localMSPID == &quot;&quot; {        return errors.New(&quot;the local MSP must have an ID&quot;)    }    // 重新设置了BCCSP密钥存储文件的绝对路径 peer.BCCSP.SW.FileKeyStore.KeyStore    SetBCCSPKeystorePath()    //解析配置文件中的BCCSP配置信息并保存到bccspConfig变量    err = viperutil.EnhancedExactUnmarshalKey(&quot;peer.BCCSP&quot;, &amp;bccspConfig)    // 基于上述参数初始化本地MSP组件对象    err = mspmgmt.LoadLocalMspWithType(mspMgrConfigDir, bccspConfig, localMSPID, localMSPType)    ···}</code></pre><p>而最后这个 LoadLocalMspWithType 方法其实本质和orderer节点一样，最后也是调用GetLocalMspConfig，只不过多包了一层，判断msp的类型，是FABRIC还是IDEMIX啥的，目前默认是FABRIC</p><p>而我们上面将orderer节点的时候将过在GetLocalMspConfig方法中会初始化bccsp factory。至此，peer节点启动时调用bccsp模块的路径到此为止。</p><h3 id="节点初始化BCCSP流程图"><a href="#节点初始化BCCSP流程图" class="headerlink" title="节点初始化BCCSP流程图"></a>节点初始化BCCSP流程图</h3><p><img src="http://qlkvpxmsx.hd-bkt.clouddn.com/%E8%8A%82%E7%82%B9%E5%88%9D%E5%A7%8B%E5%8C%96bccsp.png" alt></p><h5 id="此外，启动客户端和实例化链码的时候应该也会初始化这个bccsp组件，这里先略了，下次补上～"><a href="#此外，启动客户端和实例化链码的时候应该也会初始化这个bccsp组件，这里先略了，下次补上～" class="headerlink" title="此外，启动客户端和实例化链码的时候应该也会初始化这个bccsp组件，这里先略了，下次补上～"></a>此外，启动客户端和实例化链码的时候应该也会初始化这个bccsp组件，这里先略了，下次补上～</h5><h1 id="接口及其实现（以SW为例）"><a href="#接口及其实现（以SW为例）" class="headerlink" title="接口及其实现（以SW为例）"></a>接口及其实现（以SW为例）</h1><p>上一节通过分析peer和orderer节点的启动流程知道了节点启动时是如何调用bccsp模块的，最终都会调用这个bccsp模块InitFactories初始化一个bccsp对象。那么这里就从这个InitFactories方法说起，介绍一下BCCSP模块内部是怎么玩的。</p><p><img src="http://qlkvpxmsx.hd-bkt.clouddn.com/%E5%88%9D%E5%A7%8B%E5%8C%96bccsp.png" alt></p><p>如图所示，initFactories会根据传入的config.opts这个字段判断创建SWFactory、GMFactory、PKCS11Factory以及PluginFactory对象，然后调用initBCCSP构造全局默认的BCCSP对象defaultBCCSP，而这个initBCCSP方法实际上是调用了BCCSPFactory接口下的Get方法创建一个BCCSP工厂对象实例的，这里就讲到了我们的第一套接口BCCSPFactory。</p><h2 id="BCCSPFactory接口"><a href="#BCCSPFactory接口" class="headerlink" title="BCCSPFactory接口"></a>BCCSPFactory接口</h2><p>BCCSPFactory接口主要用于构造一个BCCSP实例，它包含 Name 和 Get 两个方法。</p><pre><code>// BCCSPFactory is used to get instances of the BCCSP interface.// A Factory has name used to address it.// 根据 FactoryOpts 构建一个BCCSP实例type BCCSPFactory interface {    // Name returns the name of this factory    Name() string    // Get returns an instance of BCCSP using opts.    Get(opts *FactoryOpts) (bccsp.BCCSP, error)}</code></pre><h3 id="sw实现"><a href="#sw实现" class="headerlink" title="sw实现"></a>sw实现</h3><ul><li><h4 id="Name方法"><a href="#Name方法" class="headerlink" title="Name方法"></a>Name方法</h4></li></ul><pre><code>const (    SoftwareBasedFactoryName = &quot;SW&quot;)func (f *SWFactory) Name() string {    // 直接返回工厂类型的名字&quot;SW&quot;    return SoftwareBasedFactoryName}</code></pre><ul><li><h4 id="Get方法"><a href="#Get方法" class="headerlink" title="Get方法"></a>Get方法</h4></li></ul><pre><code>// 根据FactoryOpts构建一个BCCSP实例func (f *SWFactory) Get(config *FactoryOpts) (bccsp.BCCSP, error) {    // 验证参数是否为空    if config == nil || config.SwOpts == nil {        return nil, errors.New(&quot;Invalid config. It must not be nil.&quot;)    }    swOpts := config.SwOpts    var ks bccsp.KeyStore    // 如果Ephemeral字段为true，说明是一个临时密钥    if swOpts.Ephemeral == true {        // 实例化一个既不加载也不存储密钥的虚拟密钥对象        ks = sw.NewDummyKeyStore()    } else if swOpts.FileKeystore != nil {        // 如果非临时密钥，而且FileKeystore字段不为空，则实例化一个存储于文件夹中的密钥对象        fks, err := sw.NewFileBasedKeyStore(nil, swOpts.FileKeystore.KeyStorePath, false)        if err != nil {            return nil, errors.Wrapf(err, &quot;Failed to initialize software key store&quot;)        }        ks = fks    } else if swOpts.InmemKeystore != nil {        // 如果FileKeystore字段为空，实例化一个暂时存储在内存中的密钥对象        ks = sw.NewInMemoryKeyStore()    } else {        // 如果Ephemeral字段为false，但FileKeystore字段也为空，        // 那么也是默认实例化一个临时虚拟密钥存储类型        ks = sw.NewDummyKeyStore()    }    // 根据传入参数创建一个软实现的标准加密类型bccsp实例对象(sw.csp类型)    return sw.NewWithParams(swOpts.SecLevel, swOpts.HashFamily, ks)}</code></pre><p>细心的听众可能已经注意到在Get方法中调用了sw.NewDummyKeyStore方法和sw.New方法，那这两个方法又是如何实现的呢，这就涉及到我们接下来要讲的KeyStore接口和BCCSP接口了。</p><h2 id="KeyStore接口"><a href="#KeyStore接口" class="headerlink" title="KeyStore接口"></a>KeyStore接口</h2><p>KeyStore接口主要用于实现对加密密钥实例bccsp.key对象的存储和检索。它具体包含三个方法，ReadOnly、GetKey和StoreKey。</p><pre><code>type KeyStore interface {    // 返回是否是只读类型的key    ReadOnly() bool    // 根据传入的ski返回key对象    GetKey(ski []byte) (k Key, err error)    // 存储key    StoreKey(k Key) (err error)}</code></pre><h3 id="sw实现-1"><a href="#sw实现-1" class="headerlink" title="sw实现"></a>sw实现</h3><ul><li><h4 id="ReadOnly方法"><a href="#ReadOnly方法" class="headerlink" title="ReadOnly方法"></a>ReadOnly方法</h4></li></ul><pre><code>// 返回readOnly字段func (ks *fileBasedKeyStore) ReadOnly() bool {    return ks.readOnly}</code></pre><ul><li><h4 id="GetKey方法"><a href="#GetKey方法" class="headerlink" title="GetKey方法"></a>GetKey方法</h4></li></ul><pre><code>// 根据传入的ski返回key对象func (ks *fileBasedKeyStore) GetKey(ski []byte) (bccsp.Key, error) {    // 验证ski不为空    if len(ski) == 0 {        return nil, errors.New(&quot;Invalid SKI. Cannot be of zero length.&quot;)    }    // 取ski的后缀    suffix := ks.getSuffix(hex.EncodeToString(ski))    // 如果后缀是key，则    switch suffix {    case &quot;key&quot;:        // 加载AES对称密钥        key, err := ks.loadKey(hex.EncodeToString(ski))        if err != nil {            return nil, fmt.Errorf(&quot;Failed loading key [%x] [%s]&quot;, ski, err)        }        return &amp;aesPrivateKey{key, false}, nil    case &quot;sk&quot;:        // 加载私钥        key, err := ks.loadPrivateKey(hex.EncodeToString(ski))        if err != nil {            return nil, fmt.Errorf(&quot;Failed loading secret key [%x] [%s]&quot;, ski, err)        }        switch key.(type) {        case *ecdsa.PrivateKey:            return &amp;ecdsaPrivateKey{key.(*ecdsa.PrivateKey)}, nil        case *rsa.PrivateKey:            return &amp;rsaPrivateKey{key.(*rsa.PrivateKey)}, nil        default:            return nil, errors.New(&quot;Secret key type not recognized&quot;)        }    case &quot;pk&quot;:        // 加载公钥        key, err := ks.loadPublicKey(hex.EncodeToString(ski))        if err != nil {            return nil, fmt.Errorf(&quot;Failed loading public key [%x] [%s]&quot;, ski, err)        }        switch key.(type) {        case *ecdsa.PublicKey:            return &amp;ecdsaPublicKey{key.(*ecdsa.PublicKey)}, nil        case *rsa.PublicKey:            return &amp;rsaPublicKey{key.(*rsa.PublicKey)}, nil        default:            return nil, errors.New(&quot;Public key type not recognized&quot;)        }    // 如果后缀缀都不符合，则直接去keystore的路径下遍历并解析所有密钥文件，搜索其中和传入的ski相匹配的密钥    default:        return ks.searchKeystoreForSKI(ski)    }}</code></pre><ul><li><h3 id="StoreKey方法"><a href="#StoreKey方法" class="headerlink" title="StoreKey方法"></a>StoreKey方法</h3></li></ul><pre><code>// 将密钥存储在当前keystore中func (ks *fileBasedKeyStore) StoreKey(k bccsp.Key) (err error) {    // 只读类型的keystore不能存储密钥    if ks.readOnly {        return errors.New(&quot;Read only KeyStore.&quot;)    }    // 存储的密钥不能为空    if k == nil {        return errors.New(&quot;Invalid key. It must be different from nil.&quot;)    }    switch k.(type) {    // 存储ecdsa私钥    case *ecdsaPrivateKey:        kk := k.(*ecdsaPrivateKey)        err = ks.storePrivateKey(hex.EncodeToString(k.SKI()), kk.privKey)        if err != nil {            return fmt.Errorf(&quot;Failed storing ECDSA private key [%s]&quot;, err)        }    // 存储ecdsa公钥    case *ecdsaPublicKey:        kk := k.(*ecdsaPublicKey)        err = ks.storePublicKey(hex.EncodeToString(k.SKI()), kk.pubKey)        if err != nil {            return fmt.Errorf(&quot;Failed storing ECDSA public key [%s]&quot;, err)        }    // 存储rsa私钥    case *rsaPrivateKey:        kk := k.(*rsaPrivateKey)        err = ks.storePrivateKey(hex.EncodeToString(k.SKI()), kk.privKey)        if err != nil {            return fmt.Errorf(&quot;Failed storing RSA private key [%s]&quot;, err)        }    // 存储rsa公钥    case *rsaPublicKey:        kk := k.(*rsaPublicKey)        err = ks.storePublicKey(hex.EncodeToString(k.SKI()), kk.pubKey)        if err != nil {            return fmt.Errorf(&quot;Failed storing RSA public key [%s]&quot;, err)        }    // 存储aes对称密钥    case *aesPrivateKey:        kk := k.(*aesPrivateKey)        err = ks.storeKey(hex.EncodeToString(k.SKI()), kk.privKey)        if err != nil {            return fmt.Errorf(&quot;Failed storing AES key [%s]&quot;, err)        }    default:        return fmt.Errorf(&quot;Key type not reconigned [%s]&quot;, k)    }    return}</code></pre><blockquote><p>存储密钥其实就是将密钥对象通过x509序列化以及pem编码后写入磁盘文件保存，而读取密钥则是其反向操作，即从文件中读出编码后的密钥，然后使用PEM解码和X509反序列化解析出密钥对象。</p></blockquote><h2 id="BCCSP接口"><a href="#BCCSP接口" class="headerlink" title="BCCSP接口"></a>BCCSP接口</h2><p>BCCSP接口是BCCSP模块中最核心的接口，主要用于实现密钥生成、派生、签名和验签、加密和解密以及哈希等方法。具体如下。</p><pre><code>// 主要用于实现密钥生成、派生、签名和验签、加密和解密以及哈希等方法type BCCSP interface {    // 根据参数opts的值生成对应类型的密钥    KeyGen(opts KeyGenOpts) (k Key, err error)    // 根据密钥k和参数opts，派生出新的密钥    KeyDeriv(k Key, opts KeyDerivOpts) (dk Key, err error)    // 根据指定的opts从raw中导出对应类型的密钥实例    KeyImport(raw interface{}, opts KeyImportOpts) (k Key, err error)    // 根据指定的ski获取密钥    GetKey(ski []byte) (k Key, err error)    // 获取数据的摘要    Hash(msg []byte, opts HashOpts) (hash []byte, err error)    // 根据opts指定的类型获得对应的哈希方法    GetHash(opts HashOpts) (h hash.Hash, err error)    // 利用非对称密钥k对数据摘要进行签名    Sign(k Key, digest []byte, opts SignerOpts) (signature []byte, err error)    // 利用非对称密钥对数据摘要进行验签    Verify(k Key, signature, digest []byte, opts SignerOpts) (valid bool, err error)    // 利用密钥对数据进行加密    Encrypt(k Key, plaintext []byte, opts EncrypterOpts) (ciphertext []byte, err error)    // 利用密钥对数据进行解密    Decrypt(k Key, ciphertext []byte, opts DecrypterOpts) (plaintext []byte, err error)}</code></pre><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><ul><li><h4 id="SW-Wrapper"><a href="#SW-Wrapper" class="headerlink" title="SW/Wrapper"></a>SW/Wrapper</h4></li></ul><p>SW用于实现这个BCCSP接口的实例叫做CSP，定义如下:</p><pre><code>type CSP struct {    ks bccsp.KeyStore    KeyGenerators map[reflect.Type]KeyGenerator    KeyDerivers   map[reflect.Type]KeyDeriver    KeyImporters  map[reflect.Type]KeyImporter    Encryptors    map[reflect.Type]Encryptor    Decryptors    map[reflect.Type]Decryptor    Signers       map[reflect.Type]Signer    Verifiers     map[reflect.Type]Verifier    Hashers       map[reflect.Type]Hasher}</code></pre><p>这个CSP实际上是一个基于wrappers的BCCSP接口的实现。它其实就是做了一个分类，将BCCSP要实现的那些方法分成这几类：<br>KeyGenerator、KeyDeriver、KeyImporter、Encryptor、Decryptor、Signer、Verifier、Hasher。</p><p><img src="http://qlkvpxmsx.hd-bkt.clouddn.com/BCCSP%E6%8E%A5%E5%8F%A3.png" alt></p><p>然后每一类实际上是一个map，这个map的键是类型，值是一个实例，这样就可以根据传入的参数选择对应的具体算法实现，比如往KeyGenerators这个map传入一个ecdsa类型的参数，那么就会去调用ecdsa的密钥生成方法了，废话不多说了，直接看源码。</p><ul><li><h4 id="KeyGen方法"><a href="#KeyGen方法" class="headerlink" title="KeyGen方法"></a>KeyGen方法</h4></li></ul><pre><code>// 根据参数opts的值生成对应类型的密钥func (csp *CSP) KeyGen(opts bccsp.KeyGenOpts) (k bccsp.Key, err error) {    // 验证opts不为空    if opts == nil {        return nil, errors.New(&quot;Invalid Opts parameter. It must not be nil.&quot;)    }    // 根据传入的参数opts获取相应的KeyGenerator实例（aesKeyGenerator,rsaKeyGenerator,ecdsaKeyGenerator）    keyGenerator, found := csp.KeyGenerators[reflect.TypeOf(opts)]    if !found {        return nil, errors.Errorf(&quot;Unsupported &#39;KeyGenOpts&#39; provided [%v]&quot;, opts)    }    // 调用密钥生成方法生成密钥    k, err = keyGenerator.KeyGen(opts)    if err != nil {        return nil, errors.Wrapf(err, &quot;Failed generating key with opts [%v]&quot;, opts)    }    // 如果密钥的Ephemeral字段为false，则调用StoreKey存储密钥    if !opts.Ephemeral() {        err = csp.ks.StoreKey(k)        if err != nil {            return nil, errors.Wrapf(err, &quot;Failed storing key [%s]&quot;, opts.Algorithm())        }    }    return k, nil}</code></pre><ul><li><h4 id="KeyDeriv方法"><a href="#KeyDeriv方法" class="headerlink" title="KeyDeriv方法"></a>KeyDeriv方法</h4></li></ul><pre><code>// 根据密钥k和参数opts，派生出新的密钥，该方法目前只在idemix中会用到func (csp *CSP) KeyDeriv(k bccsp.Key, opts bccsp.KeyDerivOpts) (dk bccsp.Key, err error) {    //  验证传入的密钥不为空    if k == nil {        return nil, errors.New(&quot;Invalid Key. It must not be nil.&quot;)    }    // 验证传入的opts不为空    if opts == nil {        return nil, errors.New(&quot;Invalid opts. It must not be nil.&quot;)    }    // 根据传入的密钥k获取相应的KeyDeriver实例    // （ecdsaPublicKeyKeyDeriver,ecdsaPrivateKeyKeyDeriver,aesPrivateKeyKeyDeriver）    keyDeriver, found := csp.KeyDerivers[reflect.TypeOf(k)]    if !found {        return nil, errors.Errorf(&quot;Unsupported &#39;Key&#39; provided [%v]&quot;, k)    }    // 调用KeyDerive方法生成密钥（生成一个和传入密钥相同类型的密钥）    k, err = keyDeriver.KeyDeriv(k, opts)    if err != nil {        return nil, errors.Wrapf(err, &quot;Failed deriving key with opts [%v]&quot;, opts)    }    // 如果opts的Ephemeral字段为false，则调用StoreKey存储密钥    if !opts.Ephemeral() {        err = csp.ks.StoreKey(k)        if err != nil {            return nil, errors.Wrapf(err, &quot;Failed storing key [%s]&quot;, opts.Algorithm())        }    }    return k, nil}</code></pre><ul><li><h4 id="KeyImport方法"><a href="#KeyImport方法" class="headerlink" title="KeyImport方法"></a>KeyImport方法</h4></li></ul><pre><code>// 根据指定的opts从raw中导出对应类型的密钥实例func (csp *CSP) KeyImport(raw interface{}, opts bccsp.KeyImportOpts) (k bccsp.Key, err error) {    // 验证raw不为空    if raw == nil {        return nil, errors.New(&quot;Invalid raw. It must not be nil.&quot;)    }    //验证opts不为空    if opts == nil {        return nil, errors.New(&quot;Invalid opts. It must not be nil.&quot;)    }    // 根据传入的密钥k获取相应的KeyImporter实例    // aes256ImportKeyOptsKeyImporter    // hmacImportKeyOptsKeyImporter    // ecdsaPKIXPublicKeyImportOptsKeyImporter    // ecdsaPrivateKeyImportOptsKeyImporter    // ecdsaGoPublicKeyImportOptsKeyImporter    // rsaGoPublicKeyImportOptsKeyImporter    // x509PublicKeyImportOptsKeyImporter    keyImporter, found := csp.KeyImporters[reflect.TypeOf(opts)]    if !found {        return nil, errors.Errorf(&quot;Unsupported &#39;KeyImportOpts&#39; provided [%v]&quot;, opts)    }    // 调用KeyImport方法导入密钥    k, err = keyImporter.KeyImport(raw, opts)    if err != nil {        return nil, errors.Wrapf(err, &quot;Failed importing key with opts [%v]&quot;, opts)    }    // 如果opts的Ephemeral字段为false，则调用StoreKey存储密钥    if !opts.Ephemeral() {        err = csp.ks.StoreKey(k)        if err != nil {            return nil, errors.Wrapf(err, &quot;Failed storing imported key with opts [%v]&quot;, opts)        }    }    return}</code></pre><ul><li><h4 id="GetKey方法-1"><a href="#GetKey方法-1" class="headerlink" title="GetKey方法"></a>GetKey方法</h4></li></ul><pre><code>// 根据指定的ski获取当前BCCSP实例中存储的对应密钥func (csp *CSP) GetKey(ski []byte) (k bccsp.Key, err error) {    k, err = csp.ks.GetKey(ski)    if err != nil {        return nil, errors.Wrapf(err, &quot;Failed getting key for SKI [%v]&quot;, ski)    }    return}</code></pre><ul><li><h4 id="Hash方法"><a href="#Hash方法" class="headerlink" title="Hash方法"></a>Hash方法</h4></li></ul><pre><code>// 获取数据摘要func (csp *CSP) Hash(msg []byte, opts bccsp.HashOpts) (digest []byte, err error) {    // 验证opts参数不为空    if opts == nil {        return nil, errors.New(&quot;Invalid opts. It must not be nil.&quot;)    }    // 根据传入的参数opts获取相应的Hasher实例    hasher, found := csp.Hashers[reflect.TypeOf(opts)]    if !found {        return nil, errors.Errorf(&quot;Unsupported &#39;HashOpt&#39; provided [%v]&quot;, opts)    }    // 调用hash方法生成摘要    digest, err = hasher.Hash(msg, opts)    if err != nil {        return nil, errors.Wrapf(err, &quot;Failed hashing with opts [%v]&quot;, opts)    }    returni}</code></pre><ul><li><h4 id="GetHash方法"><a href="#GetHash方法" class="headerlink" title="GetHash方法"></a>GetHash方法</h4></li></ul><pre><code>// 根据opts指定的类型获得对应的哈希方法func (csp *CSP) GetHash(opts bccsp.HashOpts) (h hash.Hash, err error) {    // 验证opts参数不为空    if opts == nil {        return nil, errors.New(&quot;Invalid opts. It must not be nil.&quot;)    }    // 根据传入的参数opts获取相应的Hasher实例    hasher, found := csp.Hashers[reflect.TypeOf(opts)]    if !found {        return nil, errors.Errorf(&quot;Unsupported &#39;HashOpt&#39; provided [%v]&quot;, opts)    }    // 返回hash方法    h, err = hasher.GetHash(opts)    if err != nil {        return nil, errors.Wrapf(err, &quot;Failed getting hash function with opts [%v]&quot;, opts)    }    return}</code></pre><ul><li><h4 id="Sign方法"><a href="#Sign方法" class="headerlink" title="Sign方法"></a>Sign方法</h4></li></ul><pre><code>// 利用非对称密钥k对数据摘要进行签名func (csp *CSP) Sign(k bccsp.Key, digest []byte, opts bccsp.SignerOpts) (signature []byte, err error) {    // 验证私钥不为空    if k == nil {        return nil, errors.New(&quot;Invalid Key. It must not be nil.&quot;)    }    // 验证摘要内容不为空    if len(digest) == 0 {        return nil, errors.New(&quot;Invalid digest. Cannot be empty.&quot;)    }    // 根据传入的密钥k获取相应的signer实例    keyType := reflect.TypeOf(k)    signer, found := csp.Signers[keyType]    if !found {        return nil, errors.Errorf(&quot;Unsupported &#39;SignKey&#39; provided [%s]&quot;, keyType)    }    // 调用signer签名方法进行签名，值得注意的是，这个opts在ecdsa中没有用到    // ecdsaSigner, rsaSigner    signature, err = signer.Sign(k, digest, opts)    if err != nil {        return nil, errors.Wrapf(err, &quot;Failed signing with opts [%v]&quot;, opts)    }    return}</code></pre><ul><li><h4 id="Verify"><a href="#Verify" class="headerlink" title="Verify"></a>Verify</h4></li></ul><pre><code>// 利用非对称密钥对数据摘要进行验签func (csp *CSP) Verify(k bccsp.Key, signature, digest []byte, opts bccsp.SignerOpts) (valid bool, err error) {    // 验证传入公钥不为空    if k == nil {        return false, errors.New(&quot;Invalid Key. It must not be nil.&quot;)    }    // 验证签名不为空    if len(signature) == 0 {        return false, errors.New(&quot;Invalid signature. Cannot be empty.&quot;)    }    // 验证摘要不为空    if len(digest) == 0 {        return false, errors.New(&quot;Invalid digest. Cannot be empty.&quot;)    }    // 根据传入的密钥k获取相应的Verifier实例    // ecdsa、rsa 值得注意的是，如果这里传入的是私钥，则会根据私钥导出公钥再作验证    verifier, found := csp.Verifiers[reflect.TypeOf(k)]    if !found {        return false, errors.Errorf(&quot;Unsupported &#39;VerifyKey&#39; provided [%v]&quot;, k)    }    // 调用verify方法进行验签    valid, err = verifier.Verify(k, signature, digest, opts)    if err != nil {        return false, errors.Wrapf(err, &quot;Failed verifing with opts [%v]&quot;, opts)    }    return}</code></pre><ul><li><h4 id="Encrypt"><a href="#Encrypt" class="headerlink" title="Encrypt"></a>Encrypt</h4></li></ul><pre><code>// 利用密钥对数据进行加密func (csp *CSP) Encrypt(k bccsp.Key, plaintext []byte, opts bccsp.EncrypterOpts) ([]byte, error) {    // 验证加密密钥不为空    if k == nil {        return nil, errors.New(&quot;Invalid Key. It must not be nil.&quot;)    }    // 根据传入的密钥k获取相应的Encryptor实例，目前只支持aes    encryptor, found := csp.Encryptors[reflect.TypeOf(k)]    if !found {        return nil, errors.Errorf(&quot;Unsupported &#39;EncryptKey&#39; provided [%v]&quot;, k)    }    // 调用Encrypt方法进行加密    return encryptor.Encrypt(k, plaintext, opts)}</code></pre><ul><li><h4 id="Decrypt"><a href="#Decrypt" class="headerlink" title="Decrypt"></a>Decrypt</h4></li></ul><pre><code>// 利用密钥对数据进行加密func (csp *CSP) Encrypt(k bccsp.Key, plaintext []byte, opts bccsp.EncrypterOpts) ([]byte, error) {    // 验证加密密钥不为空    if k == nil {        return nil, errors.New(&quot;Invalid Key. It must not be nil.&quot;)    }    // 根据传入的密钥k获取相应的Encryptor实例，目前只支持aes    encryptor, found := csp.Encryptors[reflect.TypeOf(k)]    if !found {        return nil, errors.Errorf(&quot;Unsupported &#39;EncryptKey&#39; provided [%v]&quot;, k)    }    // 调用Encrypt方法进行加密    return encryptor.Encrypt(k, plaintext, opts)}</code></pre><h2 id="Key接口"><a href="#Key接口" class="headerlink" title="Key接口"></a>Key接口</h2><p>KeyStore接口主要用于实现对密钥管理，它具体包含如下方法：</p><pre><code>// key接口主要用于密钥管理type Key interface {    // 将密钥key转成bytes格式    Bytes() ([]byte, error)    // 返回密钥的key的ski    SKI() []byte    // 是否是对称加密密钥    Symmetric() bool    // 是否是私钥    Private() bool    // 返回该密钥的公钥    PublicKey() (Key, error)}</code></pre><h3 id="sw实现-2"><a href="#sw实现-2" class="headerlink" title="sw实现"></a>sw实现</h3><ul><li><h4 id="Bytes方法"><a href="#Bytes方法" class="headerlink" title="Bytes方法"></a>Bytes方法</h4></li></ul><pre><code>// 将ecdsa的公钥转成bytes形式func (k *ecdsaPublicKey) Bytes() (raw []byte, err error) {    // 调用go sdk的x509包中的方法    raw, err = x509.MarshalPKIXPublicKey(k.pubKey)    if err != nil {        return nil, fmt.Errorf(&quot;Failed marshalling key [%s]&quot;, err)    }    return}</code></pre><p>值得注意的是，对于rsa和ecdsa的私钥是不支持转成Bytes操作的，如果直接调用这个方法，会返回err</p><ul><li><h4 id="SKI方法"><a href="#SKI方法" class="headerlink" title="SKI方法"></a>SKI方法</h4></li></ul><pre><code>// 返回ecdsa公钥的skifunc (k *ecdsaPublicKey) SKI() []byte {    // 检查密钥是否为空    if k.pubKey == nil {        return nil    }    // 序列化公钥，调用go sdk的elliptic包的Marshal方法序（将一个点转化成未压缩形式）    raw := elliptic.Marshal(k.pubKey.Curve, k.pubKey.X, k.pubKey.Y)    // 将结果用sha256做哈希    hash := sha256.New()    hash.Write(raw)    return hash.Sum(nil)}</code></pre><ul><li><h4 id="Symmetric方法"><a href="#Symmetric方法" class="headerlink" title="Symmetric方法"></a>Symmetric方法</h4></li></ul><pre><code>// 返回是否是对称密钥func (k *aesPrivateKey) Symmetric() bool {    return true}</code></pre><p>只有aes返回true，rsa和ecdsa均返回false</p><ul><li><h4 id="Private方法"><a href="#Private方法" class="headerlink" title="Private方法"></a>Private方法</h4></li></ul><pre><code>// 返回是否是私钥func (k *ecdsaPrivateKey) Private() bool {    return true}</code></pre><h2 id="opts系列接口"><a href="#opts系列接口" class="headerlink" title="opts系列接口"></a>opts系列接口</h2><p>KeyStore接口主要用于实现对密钥管理，它具体包含如下方法：</p><pre><code>// 主要用来提供生成密钥的参数type KeyGenOpts interface {    Algorithm() string    Ephemeral() bool}// 主要用来从一个Key实例派生出另一个Key实例type KeyDerivOpts interface {    Algorithm() string    Ephemeral() bool}// 主要用来在密钥导入时生成参数type KeyImportOpts interface {    Algorithm() string    Ephemeral() bool}// 为hash方法提供参数选择type HashOpts interface {    Algorithm() string}// 为签名方法提供参数选择type SignerOpts interface {    crypto.SignerOpts}// 无方法，可以根据需要定义加密参数type EncrypterOpts interface{}// 无方法，可以根据需要定义加密参数type DecrypterOpts interface{}</code></pre><h3 id="sw实现-3"><a href="#sw实现-3" class="headerlink" title="sw实现"></a>sw实现</h3><ul><li><h4 id="Algorithm方法"><a href="#Algorithm方法" class="headerlink" title="Algorithm方法"></a>Algorithm方法</h4></li></ul><pre><code>func (opts *ECDSAKeyGenOpts) Algorithm() string {    return ECDSA}</code></pre><ul><li><h4 id="Ephemeral方法"><a href="#Ephemeral方法" class="headerlink" title="Ephemeral方法"></a>Ephemeral方法</h4></li></ul><pre><code>func (opts *ECDSAKeyGenOpts) Ephemeral() bool {    return opts.Temporary}</code></pre><ul><li><h4 id="HashOpts方法"><a href="#HashOpts方法" class="headerlink" title="HashOpts方法"></a>HashOpts方法</h4></li></ul><pre><code>func (opts *ECDSAKeyGenOpts) Ephemeral() bool {    return opts.Temporary}</code></pre><h2 id="接口调用关系图"><a href="#接口调用关系图" class="headerlink" title="接口调用关系图"></a>接口调用关系图</h2><h1 id="GM插件"><a href="#GM插件" class="headerlink" title="GM插件"></a>GM插件</h1><p>至于国密GM插件的实现其实与SW插件类似，基本也是仿照SW插件改造出来的，只不过中间封装了一层sm2、sm3和sm4接口:</p><pre><code>type Sm2 interface {    // 创建私钥    GenerateKey() (*crypto.PrivateKey, error)    // 数字签名和验证    Sign(priv *crypto.PrivateKey, rand io.Reader, digest []byte, opts gocrypto.SignerOpts) ([]byte, error)    Verify(pub *crypto.PublicKey, digest []byte, sign []byte) bool    // 非对称加密和解密    Encrypt(pub *crypto.PublicKey, msg []byte) ([]byte, error)    Decrypt(priv *crypto.PrivateKey, ciphertext []byte) ([]byte, error)    // 公钥和私钥的保存与加载    SavePrivateKeytoPem(fileName string, key *crypto.PrivateKey, pwd []byte) (bool, error)    LoadPrivateKeyFromPem(fileName string, pwd []byte) (*crypto.PrivateKey, error)    SavePublicKeytoPem(fileName string, key *crypto.PublicKey, _ []byte) (bool, error)    LoadPublicKeyFromPem(fileName string, pwd []byte) (*crypto.PublicKey, error)}type Sm3 interface {    // 创建符合Hash接口的sm3实例    New() hash.Hash    // 使用sm3计算数据的摘要    Sum(data []byte) []byte}type Sm4 interface {    // 创建符合Block接口的sm4实例    NewCipher(key []byte) (cipher.Block, error)    // 使用对称密钥加密和解密    Encrypt(key []byte, dst, src []byte)    Decrypt(key []byte, dst, src []byte)    // 密钥保存和加载    SaveKeyToPem(fileName string, key []byte, pwd []byte) (bool, error)    LoadKeyFromPem(fileName string, pwd []byte) ([]byte, error)}</code></pre><p>通过将国密算法需要实现的BCCSP模块中的接口整理了一下，归纳成sm2、sm3、sm4这三套接口，这样就使得国密插件的具体实现与BCCSP模块进行了解耦。理论上我们只需要实现这三套接口，就可以实现一个新的国密插件。之所以这样设计，是因为目前底层国密的加密库目前有多个选择，这样就使得国密插件的实现更灵活，可以更方便的引入和适配新的底层国密库。</p><p>具体国密插件的实现可参考 <a href="https://blog.csdn.net/weixin_39066447/article/details/111468172" target="_blank" rel="noopener">fabric国密改造</a></p><h1 id="pkcs11插件"><a href="#pkcs11插件" class="headerlink" title="pkcs11插件"></a>pkcs11插件</h1><p>1.4版本的pkcs11实现有较多的TODO以及FIXME，并不完善</p><p>通过对比pkcs11的factoryOpts和SW的factoryOpts，我们发现</p><pre><code>type FactoryOpts struct {    //     ProviderName string      `mapstructure:&quot;default&quot; json:&quot;default&quot; yaml:&quot;Default&quot;`    SwOpts       *SwOpts     `mapstructure:&quot;SW,omitempty&quot; json:&quot;SW,omitempty&quot; yaml:&quot;SwOpts&quot;`    PluginOpts   *PluginOpts `mapstructure:&quot;PLUGIN,omitempty&quot; json:&quot;PLUGIN,omitempty&quot; yaml:&quot;PluginOpts&quot;`}</code></pre><pre><code>type FactoryOpts struct {    ProviderName string             `mapstructure:&quot;default&quot; json:&quot;default&quot; yaml:&quot;Default&quot;`    SwOpts       *SwOpts            `mapstructure:&quot;SW,omitempty&quot; json:&quot;SW,omitempty&quot; yaml:&quot;SwOpts&quot;`    PluginOpts   *PluginOpts        `mapstructure:&quot;PLUGIN,omitempty&quot; json:&quot;PLUGIN,omitempty&quot; yaml:&quot;PluginOpts&quot;`    Pkcs11Opts   *pkcs11.PKCS11Opts `mapstructure:&quot;PKCS11,omitempty&quot; json:&quot;PKCS11,omitempty&quot; yaml:&quot;PKCS11&quot;`}</code></pre><p>可以发现pkcs11的FactoryOpts主要是多了Pkcs11Opts这个字段，而在这个字段中定义了library、label、pin这几个值，如果大家还有印象的话应该记得在加载配置文件core.yaml的时候pkcs11那里其实是有这些字段的。</p><pre><code>PKCS11:    # Location of the PKCS11 module library    Library: /usr/lib/softhsm/libsofthsm2.so     #/etc/hyperledger/fabric/libsofthsm2.so    # Token Label    Label: ForFabric    # User PIN    Pin: &quot;98765432&quot;    Hash: SHA2    Security: 256</code></pre><p>而查看和pkcs11的bccsp实例，我们会发现</p><pre><code>type impl struct {    // sw的bccsp实例    bccsp.BCCSP    conf *config    ks   bccsp.KeyStore    ctx      *pkcs11.Ctx    sessions chan pkcs11.SessionHandle    slot     uint    lib        string    softVerify bool    //Immutable flag makes object immutable    immutable bool}</code></pre><p>实际上pkcs11的实例中是包含了一个sw的bccsp实例的，这一点在new一个BCCSP实例的时候也得到了验证</p><pre><code>func New(opts PKCS11Opts, keyStore bccsp.KeyStore) (bccsp.BCCSP, error) {    ...    // 调用了sw的NewWithParams方法new了一个sw的bccsp实例    swCSP, err := sw.NewWithParams(opts.SecLevel, opts.HashFamily, keyStore)    if err != nil {        return nil, errors.Wrapf(err, &quot;Failed initializing fallback SW BCCSP&quot;)    }    lib := opts.Library    pin := opts.Pin    label := opts.Label    ...    sessions := make(chan pkcs11.SessionHandle, sessionCacheSize)    // 最后返回的bccsp实例包含了一个sw的bccsp的实例    csp := &amp;impl{swCSP, conf, keyStore, ctx, sessions, slot, lib, opts.SoftVerify, opts.Immutable}    return csp, nil}</code></pre><p>而pkcs11插件在实现bccsp接口的时候也多次调用了内部包含sw bccsp对应的方法。</p><p>就比如bccsp接口中的KeyGen方法</p><pre><code>func (csp *impl) KeyGen(opts bccsp.KeyGenOpts) (k bccsp.Key, err error) {    switch opts.(type) {    case *bccsp.ECDSAKeyGenOpts:        ski, pub, err := csp.generateECKey(csp.conf.ellipticCurve, opts.Ephemeral())        ···    case *bccsp.ECDSAP256KeyGenOpts:        ski, pub, err := csp.generateECKey(oidNamedCurveP256, opts.Ephemeral())        ···    case *bccsp.ECDSAP384KeyGenOpts:        ski, pub, err := csp.generateECKey(oidNamedCurveP384, opts.Ephemeral())        ···    default:        return csp.BCCSP.KeyGen(opts)    }    return k, nil}</code></pre><p>我们可以发现它都是先走自己单独的生成密钥的那套方法，走不通时再去调SW的KeyGen方法。而进一步分析发现，其实pkcs11自己的那套密钥生成方法也是一层接口封装，底层其实用的是开源的一套pkcs11标准实现加密库 <a href="https://github.com/miekg/pkcs11" target="_blank" rel="noopener">https://github.com/miekg/pkcs11</a> ，这个库是pkcs11的Go语言实现，它实现了pkcs11标准规定的那些接口，而且已经通过和SoftHSM的测试，当然底层也可以用硬件加密机实现。</p><p><img src="http://qlkvpxmsx.hd-bkt.clouddn.com/pkcs11%E7%9A%84BCCSP%E5%AE%9E%E7%8E%B0.png" alt></p><p>值得注意的是，pkcs11由于是采用硬件加密，因此它的密钥是保存在硬件加密模块中的，所以它并没有实现keystore密钥存储接口，同时，它也不会通过软件实现密钥生成、密钥派生以及密钥导入等场景，所以也就不支持opts系列接口，这一点和SW以及GM都不太一样。</p><h1 id="idemix插件"><a href="#idemix插件" class="headerlink" title="idemix插件"></a>idemix插件</h1><p>和零知识证明有关</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="http://qlkvpxmsx.hd-bkt.clouddn.com/BCCSP%E6%A8%A1%E5%9D%97%E6%80%BB%E7%BB%93.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> fabric </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fabric </tag>
            
            <tag> bccsp </tag>
            
            <tag> 密码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Go特性5】锁和条件变量</title>
      <link href="/2020/12/25/go-feature-lock/"/>
      <url>/2020/12/25/go-feature-lock/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是锁？"><a href="#什么是锁？" class="headerlink" title="什么是锁？"></a>什么是锁？</h3><p>锁是某个协程（线程）在访问某个资源时先锁住，防止其它协程的访问，等访问完毕解锁后其他协程再来加锁进行访问。这和我们生活中加锁使用公共资源相似，例如：公共卫生间。</p><h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><p><font color="red">死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁。</font></p><p>常见三种死锁类型：</p><ol><li>单go程自己死锁</li></ol><p>无缓冲channel 应该在至少 2 个以上的go程中进行通信。否则死锁！！！</p><ol start="2"><li>go程间channel访问顺序导致死锁</li></ol><p>示例代码：</p><pre><code>package mainimport &quot;fmt&quot;func main() {ch := make(chan int)ch &lt;- 1           // I&#39;m blocked because there is no channel read yet. fmt.Println(&quot;send&quot;)go func() {    &lt;-ch          // I will never be called for the main routine is blocked!    fmt.Println(&quot;received&quot;)}()fmt.Println(&quot;over&quot;)}</code></pre><p>使用channel一端读（写），要保证另一端写（读）操作，同时有机会执行。否则死锁。</p><ol start="3"><li><p>多go程，多channel 交叉死锁</p><p> A go程，掌握M的同时，尝试拿N； </p><p> B go程，掌握N的同时尝试拿M。 </p></li></ol><p>各方都在请求对方的资源同时又不愿放弃手里的资源</p><ol start="4"><li><font color="red">在go语言中，尽量不要将 互斥锁、读写锁 与 channel 混用。 ——  隐性死锁。</font></li></ol><h1 id="互斥锁-建议锁"><a href="#互斥锁-建议锁" class="headerlink" title="互斥锁(建议锁)"></a>互斥锁(建议锁)</h1><p>每个资源都对应于一个可称为 “互斥锁” 的标记，这个标记用来保证在任意时刻，只能有一个协程（线程）访问该资源。其它的协程只能等待。</p><p>互斥锁是传统并发编程对共享资源进行访问控制的主要手段，它由标准库sync中的Mutex结构体类型表示。sync.Mutex类型只有两个公开的指针方法，Lock和Unlock。Lock锁定当前的共享资源，Unlock进行解锁。</p><p>在使用互斥锁时，一定要注意：<font color="red">对资源操作完成后，一定要解锁，否则会出现流程执行异常，死锁等问题。通常借助defer。锁定后，立即使用defer语句保证互斥锁及时解锁。</font></p><p>如下所示：</p><pre><code>var mutex sync.Mutex        // 定义互斥锁变量 mutex func write(){    mutex.Lock( )    defer mutex.Unlock( ) }</code></pre><p>我们可以使用互斥锁来解决前面提到的多任务编程的问题，如下所示：</p><pre><code>package main  import (    &quot;fmt&quot;    &quot;time&quot;    &quot;sync&quot; )  var mutex sync.Mutex  func printer(str string)  {    mutex.Lock()                   // 添加互斥锁    defer mutex.Unlock()             // 使用结束时解锁     for _, data := range str {        // 迭代器       fmt.Printf(&quot;%c&quot;, data)       time.Sleep(time.Second)       // 放大协程竞争效果    }    fmt.Println()               }  func person1(s1 string)  {    printer(s1) }  func person2()  {    printer(&quot;world&quot;)            // 调函数时传参 }  func main()  {    go person1(&quot;hello&quot;)           // main 中传参    go person2()    for {       ;    } }</code></pre><p>程序执行结果与多任务资源竞争时一致。最终由于添加了互斥锁，可以按序先输出hello再输出 world。但这里需要我们自行创建互斥锁，并在适当的位置对锁进行释放。</p><h1 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h1><p><font color="red">读锁和写锁是同一把锁的两个属性（以读模式和写模式枷锁），而不是两把锁，所以在同一个时刻只能加一把锁</font></p><p>互斥锁的本质是当一个goroutine访问的时候，其他goroutine都不能访问。这样在资源同步，避免竞争的同时也降低了程序的并发性能。程序由原来的并行执行变成了串行执行。</p><p>其实，当我们对一个不会变化的数据只做“读”操作的话，是不存在资源竞争的问题的。因为数据是不变的，不管怎么读取，多少goroutine同时读取，都是可以的。</p><p><font color="blue">所以问题不是出在“读”上，主要是修改，也就是“写”。修改的数据要同步，这样其他goroutine才可以感知到。所以真正的互斥应该是读取和修改、修改和修改之间，读和读是没有互斥操作的必要的。<br>因此，衍生出另外一种锁，叫做读写锁。</font></p><p>读写锁可以让多个读操作并发，同时读取，但是对于写操作是完全互斥的。也就是说，当一个goroutine进行写操作的时候，其他goroutine既不能进行读操作，也不能进行写操作。<br>GO中的读写锁由结构体类型sync.RWMutex表示。此类型的方法集合中包含两对方法：</p><p>一组是对写操作的锁定和解锁，简称“写锁定”和“写解锁”：</p><pre><code>func (*RWMutex)Lock()func (*RWMutex)Unlock()</code></pre><p>另一组表示对读操作的锁定和解锁，简称为“读锁定”与“读解锁”：</p><pre><code>func (*RWMutex)RLock()func (*RWMutex)RUlock()</code></pre><p>读写锁基本示例：</p><pre><code>package main  import (    &quot;sync&quot;    &quot;fmt&quot;    &quot;math/rand&quot; )  var count int                   // 全局变量count var rwlock sync.RWMutex           // 全局读写锁 rwlock  func read(n int)  {    rwlock.RLock()    fmt.Printf(&quot;读 goroutine %d 正在读取数据...\n&quot;, n)    num := count    fmt.Printf(&quot;读 goroutine %d 读取数据结束，读到 %d\n&quot;, n, num)    defer rwlock.RUnlock() } func write(n int)  {    rwlock.Lock()    fmt.Printf(&quot;写 goroutine %d 正在写数据...\n&quot;, n)    num := rand.Intn(1000)    count = num    fmt.Printf(&quot;写 goroutine %d 写数据结束，写入新值 %d\n&quot;, n, num)    defer rwlock.Unlock() }  func main()  {    for i:=0; i&lt;5; i++ {       go read(i+1)    }    for i:=0; i&lt;5; i++ {       go write(i+1)    }    for {       ;    } }</code></pre><p>我们在read里使用读锁，也就是RLock和RUnlock，写锁的方法名和我们平时使用的一样，是Lock和Unlock。这样，我们就使用了读写锁，可以并发地读，但是同时只能有一个写，并且写的时候不能进行读操作。</p><p>我们从结果可以看出，读取操作可以并行，例如2,3,1正在读取，但是同时只能有一个写，例如1正在写，只能等待1写完，这个过程中不允许进行其它的操作。</p><p>处于读锁定状态，那么针对它的写锁定操作将永远不会成功，且相应的Goroutine也会被一直阻塞。因为它们是互斥的。</p><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>读写锁控制下的多个写操作之间都是互斥的，并且写操作与读操作之间也都是互斥的。但是，多个读操作之间不存在互斥关系。<br>从互斥锁和读写锁的源码可以看出，它们是同源的。读写锁的内部用互斥锁来实现写锁定操作之间的互斥。可以把读写锁看作是互斥锁的一种扩展。</p><h5 id="读时共享，写时独占。写锁优先级比读锁高。"><a href="#读时共享，写时独占。写锁优先级比读锁高。" class="headerlink" title="读时共享，写时独占。写锁优先级比读锁高。"></a>读时共享，写时独占。写锁优先级比读锁高。</h5><h1 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h1><p><font color="blue">条件变量的作用并不保证在同一时刻仅有一个协程（线程）访问某个共享的数据资源，而是在对应的共享数据的状态发生变化时，通知阻塞在某个条件上的协程（线程）。</font></p><p><font color="red">条件变量不是锁，在并发中不能达到同步的目的，因此条件变量总是与锁一块使用。</font></p><p>例如，我们上面说的，如果仓库队列满了，我们可以使用条件变量让生产者对应的goroutine暂停（阻塞），但是当消费者消费了某个产品后，仓库就不再满了，应该唤醒（发送通知给）阻塞的生产者goroutine继续生产产品。</p><p>GO标准库中的sys.Cond类型代表了条件变量。条件变量要与锁（互斥锁，或者读写锁）一起使用。成员变量L代表与条件变量搭配使用的锁。</p><pre><code>type Cond struct {    noCopy noCopy    // L is held while observing or changing the condition    L Locker    notify  notifyList    checker copyChecker }</code></pre><p>对应的有3个常用方法，Wait，Signal，Broadcast。</p><h3 id="func-c-Cond-Wait"><a href="#func-c-Cond-Wait" class="headerlink" title="func ((c *Cond)) Wait(())"></a>func ((c *Cond)) Wait(())</h3><p>该函数的作用可归纳为如下三点：</p><ol><li>阻塞等待条件变量满足    </li><li>释放已掌握的互斥锁相当于cond.L.Unlock(())。 注意：两步为一个原子操作。</li></ol><p><font color="red">以上两步为原子操作，必须一起做，做完之后相当于把锁让出去了，等待对端去读或者写数据，等对段完成相应操作后，会再向这一端发送一个信号，唤醒这一端，继续向下执行。</font></p><ol start="3"><li>当被唤醒，Wait(())函数返回时，解除阻塞并重新获取互斥锁。相当于cond.L.Lock(())</li></ol><h3 id="func-c-Cond-Signal"><a href="#func-c-Cond-Signal" class="headerlink" title="func ((c *Cond)) Signal(())"></a>func ((c *Cond)) Signal(())</h3><p>单发通知，给一个正等待（阻塞）在该条件变量上的goroutine（线程）发送通知。</p><h3 id="func-c-Cond-Broadcast"><a href="#func-c-Cond-Broadcast" class="headerlink" title="func ((c *Cond)) Broadcast(())"></a>func ((c *Cond)) Broadcast(())</h3><p>广播通知，给正在等待（阻塞）在该条件变量上的所有goroutine（线程）发送通知。</p><h2 id="示例代码："><a href="#示例代码：" class="headerlink" title="示例代码："></a>示例代码：</h2><pre><code>package main import &quot;fmt&quot; import &quot;sync&quot; import &quot;math/rand&quot; import &quot;time&quot;  var cond sync.Cond             // 创建全局条件变量  // 生产者 func producer(out chan&lt;- int, idx int) {    for {       cond.L.Lock()               // 条件变量对应互斥锁加锁       for len(out) == 3 {              // 产品区满 等待消费者消费          cond.Wait()                 // 挂起当前协程， 等待条件变量满足，被消费者唤醒       }       num := rand.Intn(1000)     // 产生一个随机数       out &lt;- num                 // 写入到 channel 中 （生产）       fmt.Printf(&quot;%dth 生产者，产生数据 %3d, 公共区剩余%d个数据\n&quot;, idx, num, len(out))       cond.L.Unlock()                 // 生产结束，解锁互斥锁       cond.Signal()               // 唤醒 阻塞的 消费者       time.Sleep(time.Second)       // 生产完休息一会，给其他协程执行机会    } } //消费者 func consumer(in &lt;-chan int, idx int) {    for {       cond.L.Lock()               // 条件变量对应互斥锁加锁（与生产者是同一个）       for len(in) == 0 {          // 产品区为空 等待生产者生产          cond.Wait()                 // 挂起当前协程， 等待条件变量满足，被生产者唤醒       }       num := &lt;-in                    // 将 channel 中的数据读走 （消费）       fmt.Printf(&quot;---- %dth 消费者, 消费数据 %3d,公共区剩余%d个数据\n&quot;, idx, num, len(in))       cond.L.Unlock()                 // 消费结束，解锁互斥锁       cond.Signal()               // 唤醒 阻塞的 生产者       time.Sleep(time.Millisecond * 500)        //消费完 休息一会，给其他协程执行机会    } } func main() {    rand.Seed(time.Now().UnixNano())  // 设置随机数种子    quit := make(chan bool)           // 创建用于结束通信的 channel     product := make(chan int, 3)      // 产品区（公共区）使用channel 模拟    cond.L = new(sync.Mutex)          // 创建互斥锁和条件变量     for i := 0; i &lt; 5; i++ {          // 5个消费者       go producer(product, i+1)    }    for i := 0; i &lt; 3; i++ {          // 3个生产者       go consumer(product, i+1)    }    &lt;-quit                             // 主协程阻塞 不结束 }</code></pre><p>1)    main函数中定义quit，其作用是让主协程阻塞。<br>2)    定义product作为队列，生产者产生数据保存至队列中，最多存储3个数据，消费者从中取出数据模拟消费<br>3)    条件变量要与锁一起使用，这里定义全局条件变量cond，它有一个属性：L Locker。是一个互斥锁。<br>4)    开启5个消费者协程，开启3个生产者协程。<br>5)    producer生产者，在该方法中开启互斥锁，保证数据完整性。并且判断队列是否满，如果已满，调用wait(())让该goroutine阻塞。当消费者取出数后执行cond.Signal(())，会唤醒该goroutine，继续生产数据。<br>6)    consumer消费者，同样开启互斥锁，保证数据完整性。判断队列是否为空，如果为空，调用wait(())使得当前goroutine阻塞。当生产者产生数据并添加到队列，执行cond.Signal(()) 唤醒该goroutine。</p><h2 id="条件变量使用流程"><a href="#条件变量使用流程" class="headerlink" title="条件变量使用流程"></a>条件变量使用流程</h2><ol><li><p>创建条件变量： </p><pre><code>var cond    sync.Cond</code></pre></li><li><p>指定条件变量用的锁： </p><pre><code>cond.L = new(sync.Mutex)</code></pre></li><li><p>给公共区加锁（互斥量）</p><pre><code>cond.L.Lock()    </code></pre></li><li><p>判断是否到达 阻塞条件（缓冲区满/空）    —— for 循环判断</p><pre><code>for  len(ch) == cap(ch) {   cond.Wait()     // 1) 阻塞 2) 解锁 3) 加锁}</code></pre></li><li><p>访问公共区 —— 读、写数据、打印 </p></li><li><p>解锁条件变量用的锁  </p><pre><code>cond.L.Unlock()</code></pre></li><li><p>唤醒阻塞在条件变量上的对端。 </p><ul><li>signal(()) </li><li>Broadcast(())</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Go特性4】select</title>
      <link href="/2020/12/24/go-feature-select/"/>
      <url>/2020/12/24/go-feature-select/</url>
      
        <content type="html"><![CDATA[<h1 id="select"><a href="#select" class="headerlink" title="select"></a>select</h1><h2 id="select作用"><a href="#select作用" class="headerlink" title="select作用"></a>select作用</h2><p>Go里面提供了一个关键字select，通过select可以监听channel上的数据流动。</p><p>select的用法与switch语言非常类似，由select开始一个新的选择块，每个选择条件由case语句来描述。</p><blockquote><p><font color="red">与switch语句相比， select有比较多的限制，其中最大的一条限制就是每个case语句里必须是一个IO操作</font></p></blockquote><p>大致的结构如下：</p><pre><code>    select {    case &lt;-chan1:        // 如果chan1成功读到数据，则进行该case处理语句    case chan2 &lt;- 1:        // 如果成功向chan2写入数据，则进行该case处理语句    default:        // 如果上面都没有成功，则进入default处理流程    }</code></pre><p>在一个select语句中，Go语言会按顺序从头至尾评估每一个发送和接收的语句。</p><ul><li><p>如果其中的任意一语句可以继续执行(即没有被阻塞)，那么就从那些可以执行的语句中任意选择一条来使用。</p></li><li><p>如果没有任意一条语句可以执行(即所有的通道都被阻塞)，那么有两种可能的情况：</p><ol><li>如果给出了default语句，那么就会执行default语句，同时程序的执行会从select语句后的语句中恢复。</li><li>如果没有default语句，那么select语句将被阻塞，直到至少有一个通信可以进行下去。</li></ol></li></ul><p>示例代码：</p><pre><code>package mainimport (    &quot;fmt&quot;)func fibonacci(c, quit chan int) {    x, y := 1, 1    for {        select {        case c &lt;- x:            x, y = y, x+y        case &lt;-quit:            fmt.Println(&quot;quit&quot;)            return        }    }}func main() {    c := make(chan int)    quit := make(chan int)    go func() {        for i := 0; i &lt; 6; i++ {            fmt.Println(&lt;-c)        }        quit &lt;- 0    }()    fibonacci(c, quit)}</code></pre><p>运行结果如下：</p><pre><code>112348quit</code></pre><h2 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h2><p>有时候会出现goroutine阻塞的情况，那么我们如何避免整个程序进入阻塞的情况呢？我们可以利用select来设置超时，通过如下的方式实现：</p><pre><code>func main() {    c := make(chan int)    o := make(chan bool)    go func() {        for {            select {            case v := &lt;-c:                fmt.Println(v)            case &lt;-time.After(5 * time.Second):                fmt.Println(&quot;timeout&quot;)                o &lt;- true                break            }        }    }()    //c &lt;- 666 // 注释掉，引发 timeout    &lt;-o}</code></pre><h2 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h2><ol><li><p>监听的case中，没有满足监听条件，阻塞。</p></li><li><p>监听的case中，有多个满足监听条件，任选一个执行。</p></li><li><p>可以使用default来处理所有case都不满足监听条件的状况。 通常不用（会产生忙轮询）</p></li><li><p>select 自身不带有循环机制，需借助外层 for 来循环监听</p></li><li><p>break 跳出 select中的一个case选项 。类似于switch中的用法。</p></li><li><p>case 后面的语句在监听数据的同时需要拿出数据，如果分两步做，会丢失数据，因为相当于拿了两次，但只用了第二次</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Go特性3】channel</title>
      <link href="/2020/12/23/go-feature-channel/"/>
      <url>/2020/12/23/go-feature-channel/</url>
      
        <content type="html"><![CDATA[<h1 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h1><p>channel是Go语言中的一个核心类型，可以把它看成管道。并发核心单元通过它就可以发送或者接收数据进行通讯，这在一定程度上又进一步降低了编程的难度。</p><p>channel是一个数据类型，<font color="red">主要用来解决协程的同步问题以及协程之间数据共享（数据传递）的问题</font>。</p><p>goroutine运行在相同的地址空间，因此访问共享内存必须做好同步。<font color="red">goroutine 奉行通过通信来共享内存，而不是共享内存来通信</font>。<br>引⽤类型 channel可用于多个 goroutine 通讯。其内部实现了同步，确保并发安全。</p><h3 id="channel的定义"><a href="#channel的定义" class="headerlink" title="channel的定义"></a>channel的定义</h3><p>和map类似，channel也一个对应make创建的底层数据结构的引用。</p><p>channel或用于函数参数传递时，传的是引用。</p><pre><code>make(chan Type)  //等价于make(chan Type, 0)make(chan Type, capacity)</code></pre><p>chan是创建channel所需使用的关键字。Type 代表指定channel收发数据的类型。</p><p><font color="red">当 参数capacity= 0 时，channel 是无缓冲阻塞读写的；当capacity &gt; 0 时，channel 有缓冲、是非阻塞的，直到写满 capacity个元素才阻塞写入。<br></font></p><h3 id="无缓冲的channel（读写必须同步，相当于打电话）"><a href="#无缓冲的channel（读写必须同步，相当于打电话）" class="headerlink" title="无缓冲的channel（读写必须同步，相当于打电话）"></a>无缓冲的channel（读写必须同步，相当于打电话）</h3><p>无缓冲的通道（unbuffered channel）是指在接收前没有能力保存任何值的通道。</p><p>这种类型的通道要求发送goroutine和接收goroutine同时准备好，才能完成发送和接收操作。否则，<font color="red">通道会导致先执行发送或接收操作的 goroutine 阻塞等待<big>,如果只有或写的操作，会导致死锁</big></font>。</p><p>无缓冲的channel创建格式：</p><pre><code>make(chan Type)   //等价于make(chan Type, 0)</code></pre><p>如果没有指定缓冲区容量，那么该通道就是同步的，因此会阻塞到发送者准备好发送和接收者准备好接收。</p><p>示例代码：</p><pre><code>func main() {    c := make(chan int, 0) //创建无缓冲的通道 c     //内置函数 len 返回未被读取的缓冲元素数量，cap 返回缓冲区大小    fmt.Printf(&quot;len(c)=%d, cap(c)=%d\n&quot;, len(c), cap(c))    go func() {        defer fmt.Println(&quot;子协程结束&quot;)        for i := 0; i &lt; 3; i++ {            c &lt;- i            fmt.Printf(&quot;子协程正在运行[%d]: len(c)=%d, cap(c)=%d\n&quot;, i, len(c), cap(c))        }    }()    time.Sleep(2 * time.Second) //延时2s    for i := 0; i &lt; 3; i++ {        num := &lt;-c //从c中接收数据，并赋值给num        fmt.Println(&quot;num = &quot;, num)    }    fmt.Println(&quot;main协程结束&quot;)}</code></pre><blockquote><p>IO操作会比较慢，导致显示出来的结果和实际结果可能不一致</p></blockquote><h3 id="有缓冲的channel（读写可以异步，相当于发微信）"><a href="#有缓冲的channel（读写可以异步，相当于发微信）" class="headerlink" title="有缓冲的channel（读写可以异步，相当于发微信）"></a>有缓冲的channel（读写可以异步，相当于发微信）</h3><p>有缓冲的通道（buffered channel）是一种在被接收前能存储一个或者多个数据值的通道。</p><p>这种类型的通道并不强制要求 goroutine 之间必须同时完成发送和接收。通道会阻塞发送和接收动作的条件也不同。</p><ul><li><p>只有通道中没有要接收的值时，接收动作才会阻塞。</p></li><li><p>只有通道没有可用缓冲区容纳被发送的值时，发送动作才会阻塞。</p></li></ul><p>这导致有缓冲的通道和无缓冲的通道之间的一个很大的不同：无缓冲的通道保证进行发送和接收的 goroutine 会在同一时间进行数据交换；有缓冲的通道没有这种保证。</p><p>有缓冲的channel创建格式：</p><pre><code>    make(chan Type, capacity)</code></pre><p>如果给定了一个缓冲区容量，通道就是异步的。只要缓冲区有未使用空间用于发送数据，或还包含可以接收的数据，那么其通信就会无阻塞地进行。</p><p>示例代码：</p><pre><code>func main() {    c := make(chan int, 3) //带缓冲的通道    //内置函数 len 返回未被读取的缓冲元素数量， cap 返回缓冲区大小    fmt.Printf(&quot;len(c)=%d, cap(c)=%d\n&quot;, len(c), cap(c))    go func() {        defer fmt.Println(&quot;子协程结束&quot;)        for i := 0; i &lt; 3; i++ {            c &lt;- i            fmt.Printf(&quot;子协程正在运行[%d]: len(c)=%d, cap(c)=%d\n&quot;, i, len(c), cap(c))        }    }()    time.Sleep(2 * time.Second) //延时2s    for i := 0; i &lt; 3; i++ {        num := &lt;-c //从c中接收数据，并赋值给num        fmt.Println(&quot;num = &quot;, num)    }    fmt.Println(&quot;main协程结束&quot;)}</code></pre><blockquote><p>内置函数 len 返回未被读取的缓冲元素数量， cap 返回缓冲区大小</p></blockquote><h4 id="关闭channel"><a href="#关闭channel" class="headerlink" title="关闭channel"></a>关闭channel</h4><p>如果发送者知道，没有更多的值需要发送到channel的话，那么让接收者也能及时知道没有多余的值可接收将是有用的，因为接收者可以停止不必要的接收等待。这可以通过内置的close函数来关闭channel实现。</p><p>确定不再相对端发送、接收数据。关闭channel。 使用 close(ch) 关闭channel</p><p>对端可以判断 channel 是否关闭：</p><pre><code>if num， ok := &lt;-ch ;  ok == true {</code></pre><ul><li><p>如果对端已经关闭， ok –&gt; false . num无数据。</p></li><li><p>如果对端没有关闭， ok –&gt; true . num保存读到的数据。</p></li></ul><p>可以使用 range 替代 ok：</p><pre><code>for num := range ch {        // ch 不能替换为 &lt;-ch}</code></pre><p>总结：    </p><ol><li><p>数据不发送完，不应该关闭。</p></li><li><p>已经关闭的channel， 不能再向其写数据。 报错：panic: send on closed channel</p></li><li><p>写端已经关闭channel， 可以从中读取数据。</p></li></ol><p>读无缓冲channel： 读到0 。 —— 说明：写端关闭。</p><p>读有缓冲channel： 如果缓冲区内有数据，先读数据。读完数据后，可以继续读。 读到 0</p><h4 id="单向channel"><a href="#单向channel" class="headerlink" title="单向channel"></a>单向channel</h4><p>默认情况下，通道channel是双向的，也就是，既可以往里面发送数据也可以同里面接收数据。</p><p>但是，我们经常见一个<font color="red">通道作为参数进行传递而值希望对方是单向使用的，要么只让它发送数据，要么只让它接收数据，这时候我们可以指定通道的方向</font>。</p><p>默认的channel 是双向的。 </p><p>var ch chan int<br>ch = make(chan int)</p><p>单向写channel:    </p><pre><code>var  sendCh chan &lt;-     int    sendCh = make(chan &lt;- int)    不能读操作</code></pre><p>单向读channel:    </p><pre><code>var  recvCh  &lt;- chan int    recvCh = make(&lt;-chan int)</code></pre><p>转换：</p><ol><li>双向channel 可以 隐式转换为 任意一种单向channel <pre><code>sendCh  = ch</code></pre></li><li>单向 channel 不能转换为 双向 channel<pre><code>ch = sendCh/recvCh   error！！！</code></pre></li></ol><blockquote><p>传参： 传【引用】</p></blockquote><h2 id="生产者消费者模型"><a href="#生产者消费者模型" class="headerlink" title="生产者消费者模型"></a>生产者消费者模型</h2><p>单向channel最典型的应用是“生产者消费者模型”</p><p>所谓“生产者消费者模型”: 某个模块（函数等）负责产生数据，这些数据由另一个模块来负责处理（此处的模块是广义的，可以是类、函数、协程、线程、进程等）。产生数据的模块，就形象地称为生产者；而处理数据的模块，就称为消费者。</p><h3 id="缓冲区的好处："><a href="#缓冲区的好处：" class="headerlink" title="缓冲区的好处："></a>缓冲区的好处：</h3><ul><li>解耦</li></ul><p>假设生产者和消费者分别是两个类。如果让生产者直接调用消费者的某个方法，那么生产者对于消费者就会产生依赖（也就是耦合）。将来如果消费者的代码发生变化，可能会直接影响到生产者。而如果两者都依赖于某个缓冲区，两者之间不直接依赖，耦合度也就相应降低了。</p><ul><li>处理并发</li></ul><p>生产者直接调用消费者的某个方法，还有另一个弊端。由于函数调用是同步的（或者叫阻塞的），在消费者的方法没有返回之前，生产者只好一直等在那边。万一消费者处理数据很慢，生产者只能无端浪费时间。</p><ul><li>缓存</li></ul><p>如果生产者制造数据的速度时快时慢，缓冲区的好处就体现出来了。当数据制造快的时候，消费者来不及处理，未处理的数据可以暂时存在缓冲区中。等生产者的制造速度慢下来，消费者再慢慢处理掉。</p><blockquote><p>使用有缓冲的channel和有缓冲的channel能实现生产者消费者模型，无缓冲的channel是同步通信，使用有缓冲的channel是异步通信</p></blockquote><h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><h2 id="time-Timer"><a href="#time-Timer" class="headerlink" title="time.Timer"></a>time.Timer</h2><p>Timer是一个定时器。代表未来的一个单一事件，你可以告诉timer你要等待多长时间。</p><pre><code>type Timer struct {    C &lt;-chan Time    r runtimeTimer }</code></pre><p>它提供一个channel，在定时时间到达之前，没有数据写入timer.C会一直阻塞。直到定时时间到，向channel写入值，阻塞解除，可以从中读取数据。</p><h3 id="定时器的常用操作："><a href="#定时器的常用操作：" class="headerlink" title="定时器的常用操作："></a>定时器的常用操作：</h3><h4 id="实现延迟功能"><a href="#实现延迟功能" class="headerlink" title="实现延迟功能"></a>实现延迟功能</h4><ul><li><p>&lt;-time.After(2 * time.Second) //定时2s，阻塞2s,2s后产生一个事件，往channel写内容<br>fmt.Println(“时间到”)</p></li><li><p>time.Sleep(2 * time.Second)<br>fmt.Println(“时间到”)</p></li><li><p>延时2s后打印一句话<br>timer := time.NewTimer(2 * time.Second)<br>&lt;- timer.C<br>fmt.Println(“时间到”)</p></li></ul><h4 id="定时器停止"><a href="#定时器停止" class="headerlink" title="定时器停止"></a>定时器停止</h4><p>time.stop</p><pre><code>timer := time.NewTimer(3 * time.Second)    go func() {        &lt;-timer.C        fmt.Println(&quot;子协程可以打印了，因为定时器的时间到&quot;)    }()    timer.Stop() //停止定时器    for {    }</code></pre><h4 id="定时器重置"><a href="#定时器重置" class="headerlink" title="定时器重置"></a>定时器重置</h4><p>time.reset</p><pre><code>timer := time.NewTimer(3 * time.Second)    go func() {        &lt;-timer.C        fmt.Println(&quot;子协程可以打印了，因为定时器的时间到&quot;)    }()    timer.Stop() //停止定时器    for {    }</code></pre><h4 id="周期定时"><a href="#周期定时" class="headerlink" title="周期定时"></a>周期定时</h4><p>Ticker是一个周期触发定时的计时器，它会按照一个时间间隔往channel发送系统当前时间，而channel的接收者可以以固定的时间间隔从channel中读取事件。</p><pre><code>type Ticker struct {    C &lt;-chan Time     // The channel on which the ticks are delivered.    r runtimeTimer }</code></pre><p>示例代码：</p><pre><code>package mainimport (    &quot;fmt&quot;    &quot;time&quot;)func main() {    //创建定时器，每隔1秒后，定时器就会给channel发送一个事件(当前时间)    ticker := time.NewTicker(time.Second * 1)    i := 0    go func() {        for { //循环            &lt;-ticker.C            i++            fmt.Println(&quot;i = &quot;, i)            if i == 5 {                ticker.Stop() //停止定时器            }        }    }() //别忘了()    //死循环，特地不让main goroutine结束    for {    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Go特性2】Goroutine</title>
      <link href="/2020/12/22/go-feature-goroutine/"/>
      <url>/2020/12/22/go-feature-goroutine/</url>
      
        <content type="html"><![CDATA[<h1 id="Go-并发"><a href="#Go-并发" class="headerlink" title="Go 并发"></a>Go 并发</h1><p>Go 在语言级别支持协程，叫goroutine。Go 语言标准库提供的所有系统调用操作（包括所有同步IO操作），都会出让CPU给其他goroutine。这让轻量级线程的切换管理不依赖于系统的线程和进程，也不需要依赖于CPU的核心数量。</p><p><font color="red">Go从语言层面就支持并行</font>。同时，并发程序的内存管理有时候是非常复杂的，而<font color="red">Go语言提供了自动垃圾回收机制</font>。</p><p>Go语言为并发编程而内置的上层API基于顺序通信进程模型CSP(communicating sequential processes)。这就意味着显式锁都是可以避免的，因为Go通过相对安全的通道发送和接受数据以实现同步，这大大地简化了并发程序的编写。</p><p><font color="red">Go语言中的并发程序主要使用两种手段来实现。goroutine和channel。</font></p><h1 id="Goroutine"><a href="#Goroutine" class="headerlink" title="Goroutine"></a>Goroutine</h1><h3 id="什么是Goroutine？"><a href="#什么是Goroutine？" class="headerlink" title="什么是Goroutine？"></a>什么是Goroutine？</h3><p>goroutine是Go并行设计的核心。<font color="red">goroutine说到底其实就是协程</font>，它比线程更小，十几个goroutine可能体现在底层就是五六个线程，Go语言内部帮你实现了这些goroutine之间的内存共享。执行goroutine只需极少的栈内存(大概是4~5KB)，当然会根据相应的数据伸缩。也正因为如此，可同时运行成千上万个并发任务。goroutine比thread更易用、更高效、更轻便。</p><p>一般情况下，一个普通计算机跑几十个线程就有点负载过大了，但是同样的机器却可以轻松地让成百上千个goroutine进行资源竞争。</p><h3 id="Goroutine的创建"><a href="#Goroutine的创建" class="headerlink" title="Goroutine的创建"></a>Goroutine的创建</h3><p>只需在函数调⽤语句前添加 go 关键字，就可创建并发执⾏单元。</p><p>在并发编程中，我们通常想将一个过程切分成几块，然后让每个goroutine各自负责一块工作，当一个程序启动时，主函数在一个单独的goroutine中运行，我们叫它main goroutine。新的goroutine会用go语句来创建。</p><p>代码示例：</p><pre><code>package mainimport (    &quot;fmt&quot;    &quot;time&quot;)func newTask() {    i := 0    for {        i++        fmt.Printf(&quot;new goroutine: i = %d\n&quot;, i)        time.Sleep(1 * time.Second) //延时1s    }}func main() {    //创建一个 goroutine，启动另外一个任务    go newTask()    i := 0    //main goroutine 循环打印    for {        i++        fmt.Printf(&quot;main goroutine: i = %d\n&quot;, i)        time.Sleep(1 * time.Second) //延时1s    }}</code></pre><h3 id="Goroutine特性"><a href="#Goroutine特性" class="headerlink" title="Goroutine特性"></a>Goroutine特性</h3><p>主goroutine退出后（相当于进程结束），其它的工作goroutine也会自动退出。</p><h4 id="runtime包"><a href="#runtime包" class="headerlink" title="runtime包"></a>runtime包</h4><ul><li>runtime.Gosched() </li></ul><p>用于让出CPU时间片，让出当前goroutine的执行权限，调度器安排其他等待的任务运行，并在下次再获得cpu时间轮片的时候，从该出让cpu的位置恢复执行。</p><p>有点像跑接力赛，A跑了一会碰到代码runtime.Gosched() 就把接力棒交给B了，A歇着了，B继续跑。<br>示例代码：</p><pre><code>package mainimport (&quot;fmt&quot;&quot;runtime&quot;)func main() {    //创建一个goroutine    go func(s string) {        for i := 0; i &lt; 2; i++ {            fmt.Println(s)        }    }(&quot;world&quot;)    for i := 0; i &lt; 2; i++ {        runtime.Gosched()  //import &quot;runtime&quot; 包        /*            屏蔽runtime.Gosched()运行结果如下：                hello                hello            没有runtime.Gosched()运行结果如下：                world                world                hello                hello        */        fmt.Println(&quot;hello&quot;)    }}</code></pre><p>以上程序的执行过程如下：</p><p>主协程进入main()函数，进行代码的执行。当执行到go func()匿名函数时，创建一个新的协程，开始执行匿名函数中的代码，主协程继续向下执行，执行到runtime.Gosched( )时会暂停向下执行，直到其它协程执行完后，再回到该位置，主协程继续向下执行。</p><h4 id="Goexit"><a href="#Goexit" class="headerlink" title="Goexit"></a>Goexit</h4><p>调用 runtime.Goexit() 将立即终止当前 goroutine 执⾏，调度器确保所有已注册 defer延迟调用被执行。</p><p>示例代码：</p><pre><code>package mainimport (&quot;fmt&quot;&quot;runtime&quot;)func main() {    go func() {        defer fmt.Println(&quot;A.defer&quot;)        func() {            defer fmt.Println(&quot;B.defer&quot;)            runtime.Goexit() // 终止当前 goroutine, import &quot;runtime&quot;            fmt.Println(&quot;B&quot;) // 不会执行        }()        fmt.Println(&quot;A&quot;) // 不会执行    }()     //不要忘记()    //死循环，目的不让主goroutine结束    for {    }}</code></pre><p>程序运行结果：</p><h4 id="GOMAXPROCS"><a href="#GOMAXPROCS" class="headerlink" title="GOMAXPROCS"></a>GOMAXPROCS</h4><ul><li>runtime.GOMAXPROCS()</li></ul><p>用来设置可以并行计算的CPU核数的最大值，并返回之前的值。</p><p>示例代码：</p><pre><code>package mainimport (    &quot;fmt&quot;)func main() {//n := runtime.GOMAXPROCS(1)     // 第一次 测试//打印结果：111111111111111111110000000000000000000011111...n := runtime.GOMAXPROCS(2)         // 第二次 测试//打印结果：010101010101010101011001100101011010010100110...    fmt.Printf(&quot;n = %d\n&quot;, n)    for {        go fmt.Print(0)        fmt.Print(1)    }}</code></pre><p>在第一次执行runtime.GOMAXPROCS(1) 时，最多同时只能有一个goroutine被执行。所以会打印很多1。过了一段时间后，GO调度器会将其置为休眠，并唤醒另一个goroutine，这时候就开始打印很多0了，在打印的时候，goroutine是被调度到操作系统线程上的。</p><p>在第二次执行runtime.GOMAXPROCS(2) 时， 我们使用了两个CPU，所以两个goroutine可以一起被执行，以同样的频率交替打印0和1。</p>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【leetcode-704】二分查找</title>
      <link href="/2020/12/20/leetcode-704/"/>
      <url>/2020/12/20/leetcode-704/</url>
      
        <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/binary-search/" target="_blank" rel="noopener">704. 二分查找</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p><p>示例 1:</p><pre><code>输入: nums = [-1,0,3,5,9,12], target = 9输出: 4解释: 9 出现在 nums 中并且下标为 4</code></pre><p>示例 2:</p><pre><code>输入: nums = [-1,0,3,5,9,12], target = 2输出: -1解释: 2 不存在 nums 中因此返回 -1</code></pre><p>提示：</p><ul><li>你可以假设 nums 中的所有元素是不重复的。</li><li>n 将在 [1, 10000]之间。</li><li>nums 的每个元素都将在 [-9999, 9999]之间。</li></ul><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>直接套用二分查找的模版，重点注意细节问题，比如边界值（等号取不取得到）等。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code>func search(nums []int, target int) int {    low, high := 0, len(nums) - 1    for low &lt;= high  {        mid := (low + high)/2        if nums[mid] == target {            return mid        } else if nums[mid] &lt; target {            low = mid + 1        } else {            high = mid - 1        }    }    return -1}</code></pre><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><h3 id="时间复杂度：O-logN"><a href="#时间复杂度：O-logN" class="headerlink" title="时间复杂度：O((logN))"></a>时间复杂度：O((logN))</h3><h3 id="空间复杂度：O-1"><a href="#空间复杂度：O-1" class="headerlink" title="空间复杂度：O((1))"></a>空间复杂度：O((1))</h3><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><p>关于二分查找，后面会专门有一个专题来练习，这里是一个最基本的题型，相当于初探，就不细致讲解了。</p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【剑指offer-57】和为s的两个数字</title>
      <link href="/2020/12/20/offer-57/"/>
      <url>/2020/12/20/offer-57/</url>
      
        <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/" target="_blank" rel="noopener">57. 和为s的两个数字</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。</p><p>示例 1：</p><pre><code>输入：nums = [2,7,11,15], target = 9输出：[2,7] 或者 [7,2]</code></pre><p>示例 2：</p><pre><code>输入：nums = [10,26,30,31,47,60], target = 40输出：[10,30] 或者 [30,10]</code></pre><p>限制：</p><ul><li>1 &lt;= nums.length &lt;= 10^5</li><li>1 &lt;= nums[i] &lt;= 10^6</li></ul><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>考虑到数组有序，可以用双指针技巧，这题的解法有点类似于二分查找，通过sum的大小来调节左右指针的移动。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code>func twoSum(nums []int, target int) []int {    // 让左右指针在两端初始化    left, right := 0, len(nums) - 1    for left &lt; right  {        // 将当前和的大小和目标数字进行比较        sum := nums[left] + nums[right]        if sum == target {            return []int{nums[left], nums[right]}        } else if sum &gt; target {            // 右指针左移            right--        } else {            // 左指针右移            left++        }    }    return []int{}}</code></pre><h1 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h1><h3 id="时间复杂度-O-N"><a href="#时间复杂度-O-N" class="headerlink" title="时间复杂度 O(()N))"></a>时间复杂度 O(()N))</h3><p>N 为数组 nums 的长度；双指针共同线性遍历整个数组。</p><h3 id="空间复杂度-O-1"><a href="#空间复杂度-O-1" class="headerlink" title="空间复杂度 O((1))"></a>空间复杂度 O((1))</h3><p>双指针 left , right 使用常数大小的额外空间。</p><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><ol><li>这题还可以用哈希表法和二分查找法解决，但是时间复杂度和空间复杂度会有所增加，不是最优解法，具体可以参考 <a href="https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/solution/hasher-fen-shuang-zhi-zhen-jie-jue-liang-shu-zhi-h/" target="_blank" rel="noopener">hash\二分\双指针 解决两数之和</a></li><li>只要数组有序，就应该想到双指针技巧，但是，如果数组无序的话，情况就不一样了，比如leetcode第一题<a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener"> 两数之和</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 剑指offer </tag>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【剑指offer-22】链表中倒数第k个节点</title>
      <link href="/2020/12/19/offer-22/"/>
      <url>/2020/12/19/offer-22/</url>
      
        <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/" target="_blank" rel="noopener">22. 链表中倒数第k个节点</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。</p><p>示例：</p><pre><code>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2.返回链表 4-&gt;5.</code></pre><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>第一时间想到的解法：</p><ul><li>先遍历统计链表长度，记为 n ；</li><li>设置一个指针走 ((n-k)) 步，即可找到链表倒数第 k 个节点。</li></ul><p>当然实际上这题如果用快慢指针做, 不需要知道链表长度，只要指针1先走k-1步，然后指针2和指针1同时前进，当指针1指向链表最后一个元素时，指针2即为所求。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code>func getKthFromEnd(head *ListNode, k int) *ListNode {    p1, p2 := head, head    // 指针p1先走k-1步    for ; k-1 &gt; 0 ; k-- {        p1 = p1.Next    }    for p2.Next != nil {        p1 = p1.Next        p2 = p2.Next    }    return p2}</code></pre><h1 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h1><h3 id="时间复杂度-O-N"><a href="#时间复杂度-O-N" class="headerlink" title="时间复杂度 O((N))"></a>时间复杂度 O((N))</h3><p>N 为链表长度；总体看， p1 走了 N 步， p2 走了 ((N-k)) 步。</p><h3 id="空间复杂度-O-1"><a href="#空间复杂度-O-1" class="headerlink" title="空间复杂度 O((1))"></a>空间复杂度 O((1))</h3><p>双指针 p1 , p2 使用常数大小的额外空间。</p><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><blockquote><p> 在链表相关的题目中，双指针的用法非常广泛，很多时候可以降低算法的时间复杂度或空间复杂度，我们在解决链表类的题目时，应该多多考虑尝试这种方法。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【leetcode-141】环形链表</title>
      <link href="/2020/12/19/leetcode-141/"/>
      <url>/2020/12/19/leetcode-141/</url>
      
        <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener">141. 环形链表</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p><p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。</p><p>说明：不允许修改给定的链表。</p><p>进阶：</p><p>你是否可以使用 O((1)) 空间解决此题？</p><p>示例 1：</p><pre><code>输入：head = [3,2,0,-4], pos = 1输出：返回索引为 1 的链表节点解释：链表中有一个环，其尾部连接到第二个节点。</code></pre><p>示例 2：</p><pre><code>输入：head = [1,2], pos = 0输出：返回索引为 0 的链表节点解释：链表中有一个环，其尾部连接到第一个节点。</code></pre><p>示例 3：</p><pre><code>输入：head = [1], pos = -1输出：返回 null解释：链表中没有环。</code></pre><p>提示：</p><ul><li>链表中节点的数目范围在范围 [0, 104] 内</li><li>-105 &lt;= Node.val &lt;= 105</li><li>pos 的值为 -1 或者链表中的一个有效索引</li></ul><h1 id="解法一：哈希表"><a href="#解法一：哈希表" class="headerlink" title="解法一：哈希表"></a>解法一：哈希表</h1><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>最容易想到的方法是遍历所有节点，每次遍历到一个节点时，判断该节点此前是否被访问过。</p><p>具体地，我们可以使用哈希表来存储所有已经访问过的节点。每次我们到达一个节点，如果该节点已经存在于哈希表中，则说明该链表是环形链表，否则就将该节点加入哈希表中。重复这一过程，直到我们遍历完整个链表即可。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code>func hasCycle(head *ListNode) bool {    visited := make(map[*ListNode]bool)    for p := head; p != nil ; p = p.Next {        if visited[p] {            return true        }        visited[p] = true    }    return false}</code></pre><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><h5 id="时间复杂度：O-N"><a href="#时间复杂度：O-N" class="headerlink" title="时间复杂度：O((N))"></a>时间复杂度：O((N))</h5><p>其中 N 为链表中节点的数目。最坏情况下我们需要遍历每个节点一次。</p><h5 id="空间复杂度：O-N"><a href="#空间复杂度：O-N" class="headerlink" title="空间复杂度：O((N))"></a>空间复杂度：O((N))</h5><p>其中 N 是链表中的节点数。主要为哈希表的开销，最坏情况下我们需要将每个节点插入到哈希表中一次。</p><h1 id="解法二：快慢指针"><a href="#解法二：快慢指针" class="headerlink" title="解法二：快慢指针"></a>解法二：快慢指针</h1><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>本方法需要读者对「Floyd 判圈算法」（又称龟兔赛跑算法）有所了解。</p><p>假想「乌龟」和「兔子」在链表上移动，「兔子」跑得快，「乌龟」跑得慢。当「乌龟」和「兔子」从链表上的同一个节点开始移动时，如果该链表中没有环，那么「兔子」将一直处于「乌龟」的前方；如果该链表中有环，那么「兔子」会先于「乌龟」进入环，并且一直在环内移动。等到「乌龟」进入环时，由于「兔子」的速度快，它一定会在某个时刻与乌龟相遇，即套了「乌龟」若干圈。</p><p>我们可以根据上述思路来解决本题。具体地，我们定义两个指针，一快一满。慢指针每次只移动一步，而快指针每次移动两步。初始时，慢指针在位置 head，而快指针在位置 head.next。这样一来，如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。否则快指针将到达链表尾部，该链表不为环形链表。</p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><pre><code>func hasCycle(head *ListNode) bool {    slow, fast := head, head    // 避免空指针的情况    for fast != nil &amp;&amp; fast.Next != nil {         slow = slow.Next         fast = fast.Next.Next        // 只要快慢指针相遇，就说明有环        if slow == fast {            return true        }    }    // 其他情况均返回false    return false}</code></pre><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><h5 id="时间复杂度：O-N-1"><a href="#时间复杂度：O-N-1" class="headerlink" title="时间复杂度：O((N))"></a>时间复杂度：O((N))</h5><p>其中 N 是链表中的节点数。</p><p>当链表中不存在环时，快指针将先于慢指针到达链表尾部，链表中每个节点至多被访问两次。</p><p>当链表中存在环时，每一轮移动后，快慢指针的距离将减小一。而初始距离为环的长度，因此至多移动 N 轮。</p><h5 id="空间复杂度：O-1-。"><a href="#空间复杂度：O-1-。" class="headerlink" title="空间复杂度：O((1))。"></a>空间复杂度：O((1))。</h5><p>我们只使用了两个指针的额外空间。</p><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><p>这道题有两种解法，第一种哈希表是常规思路，第二种快慢指针法则有较强的技巧型。相比较而言，第一种方法更为通用，在做题时，我们首先想到的应该是第一种思路。而第二种思路重在理解，当然，其空间复杂度只有O((1))，会更优。</p><blockquote><p> 在链表相关的题目中，快慢指针的用法非常广泛，很多时候可以降低算法的时间复杂度或空间复杂度，我们在解决链表类的题目时，应该多多考虑尝试这种方法。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【leetcode-142】环形链表2</title>
      <link href="/2020/12/18/leetcode-142/"/>
      <url>/2020/12/18/leetcode-142/</url>
      
        <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">142. 环形链表2</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p><p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。</p><p>说明：不允许修改给定的链表。</p><p>进阶：</p><p>你是否可以使用 O((1)) 空间解决此题？</p><p>示例 1：</p><pre><code>输入：head = [3,2,0,-4], pos = 1输出：返回索引为 1 的链表节点解释：链表中有一个环，其尾部连接到第二个节点。</code></pre><p>示例 2：</p><pre><code>输入：head = [1,2], pos = 0输出：返回索引为 0 的链表节点解释：链表中有一个环，其尾部连接到第一个节点。</code></pre><p>示例 3：</p><pre><code>输入：head = [1], pos = -1输出：返回 null解释：链表中没有环。</code></pre><p>提示：</p><ul><li>链表中节点的数目范围在范围 [0, 104] 内</li><li>-105 &lt;= Node.val &lt;= 105</li><li>pos 的值为 -1 或者链表中的一个有效索引</li></ul><h1 id="解法一：哈希表"><a href="#解法一：哈希表" class="headerlink" title="解法一：哈希表"></a>解法一：哈希表</h1><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>一个非常直观的思路是：我们遍历链表中的每个节点，并将它记录下来；一旦遇到了此前遍历过的节点，就可以判定链表中存在环。借助哈希表可以很方便地实现。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code>func detectCycle(head *ListNode) *ListNode {    visited := make(map[*ListNode]bool)    for  p := head ; p != nil &amp;&amp; p.Next != nil; p = p.Next {        // 如果访问过，就返回true        if visited[p] {            return p        }        visited[p] = true    }    // 其他情况都是false    return nil}</code></pre><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><h5 id="时间复杂度：O-N"><a href="#时间复杂度：O-N" class="headerlink" title="时间复杂度：O((N))"></a>时间复杂度：O((N))</h5><p>其中 N 为链表中节点的数目。我们恰好需要访问链表中的每一个节点。</p><h5 id="空间复杂度：O-N"><a href="#空间复杂度：O-N" class="headerlink" title="空间复杂度：O((N))"></a>空间复杂度：O((N))</h5><p>其中 N 为链表中节点的数目。我们需要将链表中的每个节点都保存在哈希表当中。</p><h1 id="解法二：快慢指针"><a href="#解法二：快慢指针" class="headerlink" title="解法二：快慢指针"></a>解法二：快慢指针</h1><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>第二种是快慢指针，这种方法具有一定技巧性。</p><p>我们使用两个指针，fast 与 slow。它们起始都位于链表的头部。随后，slow 指针每次向后移动一个位置，而 fast 指针向后移动两个位置。如果链表中存在环，则 fast 指针最终将再次与 slow 指针在环中相遇。</p><p>如下图所示，设链表中环外部分的长度为 a。slow 指针进入环后，又走了 b 的距离与 fast 相遇。此时，fast 指针已经走完了环的 n 圈，因此它走过的总距离为 a+n((b+c))+b=a+((n+1))b+nc。</p><p><img src="https://i.ibb.co/cc6mBgt/142-fig1.png" alt></p><p>根据题意，任意时刻，fast 指针走过的距离都为 slow 指针的 22 倍。因此，我们有</p><p>a+((n+1))b+nc=2((a+b)) ⟹ a=c+((n-1))((b+c))</p><p>有了 a=c+((n-1))((b+c)) 的等量关系，我们会发现：从相遇点到入环点的距离加上 n-1 圈的环长，恰好等于从链表头部到入环点的距离。</p><p>因此，当发现 slow 与 fast 相遇时，我们再额外使用一个指针 ptr。起始，它指向链表头部；随后，它和 slow 每次向后移动一个位置。最终，它们会在入环点相遇。</p><p>以上是数学证明，抛开以上数学证明，最终的解题思路就是：</p><ol><li>设置一个快指针，一个慢指针</li><li>快慢指针同时出发（快指针的速度是慢指针的两倍），相遇则停下来</li><li>让慢指针再次指向头节点</li><li>两个指针<font color="red">以相同的速度</font>继续走，相遇则返回其中一个指针</li></ol><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><pre><code>func detectCycle(head *ListNode) *ListNode {    // 设置一个快指针，一个慢指针    fast, slow := head, head    // 这里是为了防止出现空指针报错的情况    for fast != nil &amp;&amp; fast.Next != nil  {        // 设置一个快指针，一个慢指针        fast = fast.Next.Next        slow = slow.Next        if fast == slow {            // 让慢指针再次指向头节点            slow = head            break        }    }    // 如果只有一个节点或者没有节点直接返回无环    if fast == nil || fast.Next == nil {        return nil    }    // 两个指针以相同的速度继续走，相遇则返回其中一个的指针    for fast != slow {        fast = fast.Next        slow = slow.Next    }    return slow}</code></pre><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><h5 id="时间复杂度：O-N-1"><a href="#时间复杂度：O-N-1" class="headerlink" title="时间复杂度：O((N))"></a>时间复杂度：O((N))</h5><p>其中 NN 为链表中节点的数目。在最初判断快慢指针是否相遇时，slow 指针走过的距离不会超过链表的总长度；随后寻找入环点时，走过的距离也不会超过链表的总长度。因此，总的执行时间为 O(N)+O(N)=O(N)。</p><h5 id="空间复杂度：O-1"><a href="#空间复杂度：O-1" class="headerlink" title="空间复杂度：O((1))"></a>空间复杂度：O((1))</h5><p>我们只使用了slow, fast, ptr 三个指针。</p><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><p>这道题有两种解法，第一种哈希表是常规思路，第二种快慢指针法则有较强的技巧型。相比较而言，第一种方法更为通用，在做题时，我们首先想到的应该是第一种思路。而第二种思路重在理解，当然，其空间复杂度只有O(1)，会更优。</p><blockquote><p>其实这道题是<a href="https://vegard-bear.github.io/2020/12/19/leetcode-141/">141. 环形链表</a>的变体，只不过判断链表有无环只需做前面两步即可。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Go特性1】并发编程技术</title>
      <link href="/2020/12/17/go-feature-concurrent/"/>
      <url>/2020/12/17/go-feature-concurrent/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Go最突出的特性之一就在于其对并发编程的支持很好，本文是作为Go并发特性介绍的预备知识</p></blockquote><h1 id="并行和并发"><a href="#并行和并发" class="headerlink" title="并行和并发"></a>并行和并发</h1><h3 id="并行-parallel"><a href="#并行-parallel" class="headerlink" title="并行 ((parallel))"></a>并行 ((parallel))</h3><p>指在同一时刻，有<font color="red">多条指令在多个处理器上同时执行</font>。</p><h3 id="并发-concurrency"><a href="#并发-concurrency" class="headerlink" title="并发 ((concurrency))"></a>并发 ((concurrency))</h3><p>指在<font color="red">同一时刻只能有一条指令执行</font>，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，<font color="red">通过cpu时间片轮转使多个进程快速交替的执行</font>。</p><h1 id="程序和进程"><a href="#程序和进程" class="headerlink" title="程序和进程"></a>程序和进程</h1><ul><li><p>程序，是指编译好的二进制文件，在磁盘上，不占用系统资源(cpu、内存、打开的文件、设备、锁….)</p></li><li><p>进程，是一个抽象的概念，与操作系统原理联系紧密。进程是活跃的程序，占用系统资源。在内存中执行。(程序运行起来，产生一个进程)</p></li></ul><h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><p>进程基本的状态有5种，分别为初始态，就绪态，运行态，挂起态与终止态。</p><h3 id="进程并发"><a href="#进程并发" class="headerlink" title="进程并发"></a>进程并发</h3><p>存在问题：</p><ol><li>系统开销比较大，占用资源比较多，开启进程数量比较少。</li><li>在unix/linux系统下，还会产生“孤儿进程”和“僵尸进程”。</li></ol><ul><li>孤儿进程</li><li>僵尸进程</li></ul><p>在操作系统中，可以产生很多的进程。在unix/linux系统中，正常情况下，<font color="red">子进程是通过父进程fork创建的，子进程再创建新的进程</font>。并且父进程永远无法预测子进程 到底什么时候结束。 当一个 进程完成它的工作终止之后，它的父进程需要调用系统调用取得子进程的终止状态。</p><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><h3 id="线程并发"><a href="#线程并发" class="headerlink" title="线程并发"></a>线程并发</h3><p>什么是线程？</p><p>LWP：light weight process 轻量级的进程，本质仍是进程 (Linux下)。</p><ul><li><p>进程：独立地址空间，拥有PCB </p></li><li><p>线程：有独立的PCB，但没有独立的地址空间(共享)</p></li></ul><p>区别：在于是否共享地址空间。独居(进程)；合租(线程)。<br><big></big></p><ul><li>线程：最小的执行单位</li><li>进程：最小分配资源单位，可看成是只有一个线程的进程。</li></ul><h4 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h4><p>线程同步，指一个线程发出某一功能调用时，在没有得到结果之前，该调用不返回。同时其它线程为保证数据一致性，不能调用该功能。</p><p>“同步”的目的，是为了避免数据混乱，解决与时间有关的错误。实际上，不仅线程间需要同步，进程间、信号间等等都需要同步机制。</p><blockquote><p>所有“多个控制流，共同操作一个共享资源”的情况，都需要同步。</p></blockquote><h1 id="锁的应用"><a href="#锁的应用" class="headerlink" title="锁的应用"></a>锁的应用</h1><h3 id="互斥锁-mutex"><a href="#互斥锁-mutex" class="headerlink" title="互斥锁 mutex"></a>互斥锁 mutex</h3><p>Linux中提供一把互斥锁mutex（也称之为互斥量）。<br>每个线程在对资源操作前都尝试先加锁，成功加锁才能操作，操作结束解锁。同一时刻，只能有一个线程持有该锁。</p><p>互斥锁实质上是操作系统提供的一把“建议锁”（又称“协同锁”），建议程序中有多线程访问共享资源的时候使用该机制。但，并没有强制限定。因此，<font color="red">即使有了mutex，如果有线程不按规则来访问数据，依然会造成数据混乱。</font></p><h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>与互斥量类似，但读写锁允许更高的并行性。其特性为：写独占，读共享。</p><h5 id="读写锁特性："><a href="#读写锁特性：" class="headerlink" title="读写锁特性："></a>读写锁特性：</h5><ol><li>读写锁是“写模式加锁”时， 解锁前，所有对该锁加锁的线程都会被阻塞。</li><li>读写锁是“读模式加锁”时， 如果线程以读模式对其加锁会成功；如果线程以写模式加锁会阻塞。</li><li>读写锁是“读模式加锁”时， 既有试图以写模式加锁的线程，也有试图以读模式加锁的线程。那么读写锁会阻塞随后的读模式锁请求。优先满足写模式锁。<font color="red">读锁、写锁并行阻塞，写锁优先级高</font>。</li></ol><p>读写锁也叫共享-独占锁。当读写锁以读模式锁住时，它是以共享模式锁住的；当它以写模式锁住时，它是以独占模式锁住的。写独占、读共享。</p><p>读写锁非常适合于对数据结构读的次数远大于写的情况。</p><h1 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h1><p>协程((coroutine)), 也叫轻量级线程。</p><ul><li><p>与传统的系统级线程和进程相比，协程最大的优势在于“轻量级”。可以轻松创建上万个而不会导致系统资源衰竭。而线程和进程通常很难超过1万个。这也是协程别称“轻量级线程”的原因。</p></li><li><p>一个线程中可以有任意多个协程，但某一时刻只能有一个协程在运行，多个协程分享该线程分配到的计算机资源。</p></li><li><p>除了Python、Lua、Ruset,go等，多数语言在语法层面并不直接支持协程。</p></li><li><p>在协程中，调用一个任务就像调用一个函数一样，消耗的系统资源最少！但能达到进程、线程并发相同的效果。<br>从系统资源消耗的角度出发来看，进程相当多，线程次之，协程最少。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Go 基础】</title>
      <link href="/2020/12/16/go-basic/"/>
      <url>/2020/12/16/go-basic/</url>
      
        <content type="html"><![CDATA[<h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><p>Go语言保留了指针，但与C语言指针有所不同。主要体现在：</p><ul><li>默认值 nil</li><li>操作符 “&amp;” 取变量地址， “*” 通过指针访问目标对象</li><li>不支持指针运算，不支持 “-&gt;” 运算符，直接⽤ “.” 访问目标成员</li></ul><h4 id="函数new"><a href="#函数new" class="headerlink" title="函数new"></a>函数new</h4><p>表达式new(T)将创建一个T类型的<strong>匿名变量</strong>，所做的是为T类型的新值分配并清零一块内存空间，然后将这块内存空间的地址作为结果返回，而这个结果就是指向这个新的T类型值的指针值，返回的指针类型为*T。</p><p>new创建的内存空间位于heap上，空间的默认值为数据类型默认值。如：new(int) 则 <em>p为0，new(bool) 则 </em>p为false</p><pre><code>func main() {     var p1 *int     p1 = new(int)                         //p1为*int 类型, 指向匿名的int变量     fmt.Println(&quot;*p1 = &quot;, *p1)          //*p1 =  0      p2 := new(bool)                      //p2为*bool 类型, 指向匿名的bool变量     fmt.Println(&quot;*p2 = &quot;, *p2)          //*p2 = false     *p2 = true     fmt.Println(&quot;*p2 = &quot;, *p2)          //*p1 = true }</code></pre><h4 id="指针做函数参数"><a href="#指针做函数参数" class="headerlink" title="指针做函数参数"></a>指针做函数参数</h4><pre><code>func swap01(a, b int) {    a, b = b, a    fmt.Printf(&quot;swap01 a = %d, b = %d\n&quot;, a, b)}func swap02(x, y *int) {    *x, *y = *y, *x}func main() {    a := 10    b := 20    //swap01(a, b)     //值传递（传值）    swap02(&amp;a, &amp;b)     //地址传递（传引用）    fmt.Printf(&quot;a = %d, b = %d\n&quot;, a, b)}</code></pre><h4 id="关于多重赋值"><a href="#关于多重赋值" class="headerlink" title="关于多重赋值"></a>关于多重赋值</h4><p><a href="https://www.jianshu.com/p/de95ef71162d" target="_blank" rel="noopener">https://www.jianshu.com/p/de95ef71162d</a></p><h1 id="切片（slice）"><a href="#切片（slice）" class="headerlink" title="切片（slice）"></a>切片（slice）</h1><h4 id="为什么要有切片"><a href="#为什么要有切片" class="headerlink" title="为什么要有切片?"></a>为什么要有切片?</h4><ol><li>数组的容量固定，不能自动拓展。</li><li>值传递。 数组作为函数参数时，将整个数组值拷贝一份给形参（值拷贝内存消耗大）。</li></ol><p>在Go语言中，我们几乎可以在所有的场景中，使用切片替换数组使用。</p><ul><li>一个slice由三个部分构成：指针、长度和容量。</li></ul><p><font color="red">切片并不是数组或数组指针，它通过内部指针和相关属性引⽤数组⽚段，以实现变⻓⽅案。（后续通过阅读源码深入了解）</font></p><h4 id="切片创建"><a href="#切片创建" class="headerlink" title="切片创建"></a>切片创建</h4><p>可以用make关键字:</p><pre><code>s := make([]int, 5)</code></pre><blockquote><p>注意：make只能创建slice、map和channel，并且返回一个有初始值(非零)的对象。</p></blockquote><h4 id="切片截取"><a href="#切片截取" class="headerlink" title="切片截取"></a>切片截取</h4><p>截取可表示为s[low：high：max]。</p><ul><li>low：表示下标的起点。</li><li>high：表示下标的终点<font color="red">（左闭右开，不包括此下标）</font>。 </li><li>长度 len = high – low。</li><li>容量 cap = max – low。</li></ul><p>长度对应slice中元素的数目；长度不能超过容量，容量一般是从slice的开始位置到底层数据的结尾位置。</p><blockquote><p>切片作为函数参数时，传引用</p></blockquote><h4 id="append函数"><a href="#append函数" class="headerlink" title="append函数"></a>append函数</h4><p>append函数会智能的将底层数组的容量增长，一旦超过原底层数组容量，通常以2倍（1024以下）容量重新分配底层数组，并复制原来的数据。</p><p>因此，使用append 给切片做扩充时，切片的地址可能发生变化。但，数据都被重新保存了，不影响使用</p><h4 id="copy函数"><a href="#copy函数" class="headerlink" title="copy函数"></a>copy函数</h4><p>函数 copy 在两个 slice 间复制数据，复制⻓度以 len 小的为准，两个 slice 指向同⼀底层数组。直接对应位置覆盖。</p><ul><li>copy（目标位置切片， 源切片）</li></ul><h1 id="map"><a href="#map" class="headerlink" title="map"></a>map</h1><p>Go语言中的map(映射、字典)是一种内置的数据结构，它是一个<font color="red">无序</font>的key-value对的集合，比如以身份证号作为唯一键来标识一个人的信息。</p><p>Go语言中并没有提供一个set类型，但是map中的key也是不相同的，可以用map实现类似set的功能。</p><p>map的格式:</p><pre><code>map[keyType]valueType</code></pre><p><strong>在一个map里所有的键都是唯一的，而且必须是支持==和!=操作符的类型，切片、函数以及包含切片的结构类型这些类型由于具有引用语义，不能作为映射的键，使用这些类型会造成编译错误。</strong></p><blockquote><p>注意：map是无序的，我们无法决定它的返回顺序，所以，每次打印结果的顺利有可能不同。</p></blockquote><h4 id="创建map"><a href="#创建map" class="headerlink" title="创建map"></a>创建map</h4><pre><code>m := make(map[int]string, 10)   //第2个参数指定容量</code></pre><h4 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h4><ul><li><p>如果新map元素的key与原map元素key相同     ——&gt; 覆盖（替换）</p></li><li><p>如果新map元素的key与原map元素key不同    ——&gt; 添加</p></li></ul><h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><p>Map的迭代顺序是不确定的，并且不同的哈希函数实现可能导致不同的遍历顺序。在实践中，遍历的顺序是随机的，每一次遍历的顺序都不相同。</p><p>判断map中key是否存在：</p><pre><code>value, ok := m[1]</code></pre><ul><li><p>如果key存在，第一个返回值返回value的值。第二个返回值为 true。</p></li><li><p>如果key存在，第一个返回值返回value的值。第二个返回值为 true。</p></li></ul><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>使用delete()函数，指定key值可以方便的删除map中的k-v映射。</p><pre><code>delete(m1, 2)         //删除key值为2的map</code></pre><blockquote><p>map 做函数参数和返回值，传引用。</p></blockquote><h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><p>如果结构体的全部成员都是可以比较的，那么结构体也是可以比较的，那样的话两个结构体将可以使用 == 或 != 运算符进行比较，但不支持 &gt; 或 &lt;</p><h4 id="做函数参数"><a href="#做函数参数" class="headerlink" title="做函数参数"></a>做函数参数</h4><p>传参过程中，实参会将自己的值拷贝一份给形参。因此结构体“传值”操作几乎不会在实际开发中被使用到。近乎100%的使用都采用“传址”的方式，将结构体的引用传递给所需函数。</p><h1 id="字符串处理函数"><a href="#字符串处理函数" class="headerlink" title="字符串处理函数"></a>字符串处理函数</h1><p>具体可参考<a href="https://studygolang.com/pkgdoc" target="_blank" rel="noopener">Golang标准库文档</a></p><p>除Contains、Join、Trim、Replace等我们学过的字符串处理函数之外，以下函数也常常会被用到。</p><h4 id="字符串分割"><a href="#字符串分割" class="headerlink" title="字符串分割"></a>字符串分割</h4><ul><li>func Split(s, sep string) []string</li></ul><p>功能：把s字符串按照sep分割，返回slice</p><h4 id="按空格拆分字符串"><a href="#按空格拆分字符串" class="headerlink" title="按空格拆分字符串"></a>按空格拆分字符串</h4><ul><li>func Split(s, sep string) []string<br>功能：把s字符串按照sep分割，返回slice</li></ul><h4 id="判断字符串后缀"><a href="#判断字符串后缀" class="headerlink" title="判断字符串后缀"></a>判断字符串后缀</h4><ul><li>func HasSuffix(s, suffix string) bool<br>功能：判断s字符串是否有后缀子串suffix</li></ul><h4 id="判断字符串前缀"><a href="#判断字符串前缀" class="headerlink" title="判断字符串前缀"></a>判断字符串前缀</h4><ul><li>func HasPrefix(s, prefix string) bool<br>功能：判断s字符串是否有前缀子串suffix</li></ul><h1 id="文件IO"><a href="#文件IO" class="headerlink" title="文件IO"></a>文件IO</h1><h2 id="打开、创建文件："><a href="#打开、创建文件：" class="headerlink" title="打开、创建文件："></a>打开、创建文件：</h2><ol><li>创建文件  Create：     文件不存在创建，文件存在，将文件内容清空。</li></ol><ul><li>参数：name， 打开文件的路径： 绝对路径、相对路径        目录分割符：/ </li></ul><ol start="2"><li>打开文件 Open：        以只读方式打开文件。文件不存在，打开失败。</li></ol><ul><li>参数：name， 打开文件的路径： 绝对路径、相对路径</li></ul><ol start="3"><li>打开文件 OpenFile：    以只读、只写、读写 方式打开文件。文件不存在，打开失败。</li></ol><ul><li><p>参1：name， 打开文件的路径： 绝对路径、相对路径</p></li><li><p>参2：打开文件权限： O_RDONLY、O_WRONLY、O_RDWR</p></li><li><p>参3：一般传 6</p></li></ul><h2 id="写文件："><a href="#写文件：" class="headerlink" title="写文件："></a>写文件：</h2><h4 id="按字符串写："><a href="#按字符串写：" class="headerlink" title="按字符串写："></a>按字符串写：</h4><p>WriteString（）    –&gt; n个写入的字符个数</p><pre><code>n, err := f.WriteString(&quot;123&quot;)</code></pre><p>回车换行：    windows： \r\n    Linux: \n</p><h4 id="按位置写"><a href="#按位置写" class="headerlink" title="按位置写:"></a>按位置写:</h4><p>Seek():     修改文件的读写指针位置。</p><ul><li><p>参1： 偏移量。 正：向文件尾偏， 负：向文件头偏</p></li><li><p>参2： 偏移起始位置：    </p></li></ul><p>io.SeekStart: 文件起始位置</p><p>io.SeekCurrent： 文件当前位置</p><p>io.SeekEnd: 文件结尾位置</p><p>返回值：表示从文件起始位置，到当前文件读写指针位置的偏移量。</p><pre><code>off, _ := f.Seek(-5, io.SeekEnd)</code></pre><h4 id="按字节写："><a href="#按字节写：" class="headerlink" title="按字节写："></a>按字节写：</h4><p>writeAt():  在文件制定偏移位置，写入 []byte ,  通常搭配 Seek()</p><ul><li><p>参1： 待写入的数据</p></li><li><p>参2：偏移量</p></li></ul><p>返回：实际写出的字节数。</p><p>n, _ = f.WriteAt([]byte(“1111”), off)    </p><h2 id="读文件："><a href="#读文件：" class="headerlink" title="读文件："></a>读文件：</h2><h4 id="按行读"><a href="#按行读" class="headerlink" title="按行读"></a>按行读</h4><ol><li>创建一个带有缓冲区的 Reader（读写器）</li></ol><pre><code>reader : = bufio.NewReader(打开的文件指针)</code></pre><ol start="2"><li>从reader的缓冲区中 ，读取指定长度的数据。数据长度取决于 参数 dlime</li></ol><pre><code>buf, err := reader.ReadBytes(&#39;\n&#39;)  按行读。</code></pre><p>判断到达文件结尾： </p><pre><code>if err != nil &amp;&amp; err == io.EOF</code></pre><p>到文件结尾。</p><p>文件结束标记，是要单独读一次获取到的。</p><blockquote><p>缓冲区：内存中的一块区域，用来减少物理磁盘访问操作。《计算硬件及组成原理》 —— 机械工业出版社。</p></blockquote><p>按字节读、写文件。</p><ul><li><p>read([]byte):  按字节读文件</p></li><li><p>write([]byte)：按字节字节</p></li></ul><h2 id="目录操作："><a href="#目录操作：" class="headerlink" title="目录操作："></a>目录操作：</h2><h4 id="打开目录：-OpenFile"><a href="#打开目录：-OpenFile" class="headerlink" title="打开目录： OpenFile"></a>打开目录： OpenFile</h4><p>打开目录 OpenFile：    以只读方式打开目录。</p><ul><li><p>参1：name， 打开目录的路径： 绝对路径、相对路径</p></li><li><p>参2：打开目录权限： O_RDONLY</p></li><li><p>参3：os.ModeDir</p></li></ul><p>返回值： 返回一个可以读目录的 文件指针。</p><h4 id="读目录：Readdir"><a href="#读目录：Readdir" class="headerlink" title="读目录：Readdir"></a>读目录：Readdir</h4><p>函数原型：</p><pre><code>func (f *File) Readdir(n int) ([]FileInfo, error) {    //参数: 欲打开的目录项个数。 -1 ， 表所有    //返回值：FileInfo ：}type FileInfo interface {    Name() string               // base name of the file    Size() int64                // length in bytes for regular files; system-dependent for others    Mode() FileMode             // file mode bits    ModTime() time.Time     // modification time    IsDir() bool                // abbreviation for Mode().IsDir()    Sys() interface{}           // underlying data source (can return nil)}    </code></pre>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【leetcode-51】N皇后</title>
      <link href="/2020/12/15/leetcode-51/"/>
      <url>/2020/12/15/leetcode-51/</url>
      
        <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/n-queens/" target="_blank" rel="noopener">46. N皇后</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><p><img src="https://i.niupic.com/images/2020/12/15/97fx.png" alt></p><p>上图为 8 皇后问题的一种解法。</p><p>给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。</p><p>每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p><p>示例：</p><pre><code>输入：4输出：[ [&quot;.Q..&quot;,  // 解法 1  &quot;...Q&quot;,  &quot;Q...&quot;,  &quot;..Q.&quot;], [&quot;..Q.&quot;,  // 解法 2  &quot;Q...&quot;,  &quot;...Q&quot;,  &quot;.Q..&quot;]]解释: 4 皇后问题存在两个不同的解法。</code></pre><p>提示：</p><p>皇后彼此不能相互攻击，也就是说：任何两个皇后都不能处于同一条横行、纵行或斜线上。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>N 皇后是非常经典的题，这题的解题思路也非常清晰，就是通过回溯剪枝进行穷举就行了。这里我们套用框架：</p><pre><code>result = []func backtrack(路径，选择列表) {    if 满足结束条件 {        result.add(路径)    }    return    for 选择 in 选择列表 {        做选择        backtrack(路径，选择列表)        撤销选择    }}</code></pre><p>想清楚几个问题</p><ol><li>起点是什么？<ul><li>从第一行开始遍历</li></ul></li><li>结束条件是什么？<ul><li>遍历到最后一行</li></ul></li><li>怎么定义走过的路径？<ul><li>这里一条路就是一个棋盘的排列方式</li></ul></li><li>如何做选择？<ul><li>在当前行依次遍历所有的列，要保证选中列、行和斜对角都没有冲突</li></ul></li></ol><p>想清楚这几个问题就可以开始写代码了，剩下的就是细节问题了（比如选用什么数据结构）</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// 最终符合要求的若干个棋盘</span><span class="token keyword">var</span> results <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token keyword">func</span> <span class="token function">solveNQueens</span><span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 全局变量需要重置</span>    results <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 定义一个 n * n 的空棋盘</span>    <span class="token keyword">var</span> board <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>        row <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> j <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n <span class="token punctuation">;</span> j<span class="token operator">++</span> <span class="token punctuation">{</span>            row <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>row<span class="token punctuation">,</span> <span class="token function">byte</span><span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>        board <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>board<span class="token punctuation">,</span> <span class="token function">string</span><span class="token punctuation">(</span>row<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 从第 0 行开始遍历</span>    <span class="token function">backTrack</span><span class="token punctuation">(</span>board<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> results<span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">backTrack</span><span class="token punctuation">(</span>board <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">,</span> row <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 结束条件, 最后一行也放好了</span>    <span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>board<span class="token punctuation">)</span> <span class="token operator">==</span> row <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 注意这里用于拷贝的临时变量一定要用 make 开辟空间，分配地址，</span>        <span class="token comment" spellcheck="true">// 不能用 var tmp []string{} 进行声明，否则无法拷贝成功</span>        tmp <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>board<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token function">copy</span><span class="token punctuation">(</span>tmp<span class="token punctuation">,</span> board<span class="token punctuation">)</span>        results <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>results<span class="token punctuation">,</span> tmp<span class="token punctuation">)</span>        <span class="token keyword">return</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 选定当前行，从第一列开始遍历</span>    <span class="token keyword">for</span> col <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> col <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>board<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">;</span> col<span class="token operator">++</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 如果会冲突，跳过这个点</span>        <span class="token keyword">if</span> <span class="token operator">!</span><span class="token function">isValid</span><span class="token punctuation">(</span>board<span class="token punctuation">,</span> row<span class="token punctuation">,</span> col<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">continue</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 如果不冲突，将该节点加入选择（放个皇后）</span>        <span class="token comment" spellcheck="true">// 注意这里的字符赋值方式，需要通过[]byte这种切片形式进行转化，</span>        <span class="token comment" spellcheck="true">// 不能直接给string中的某个字符进行赋值</span>        b <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span>board<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">)</span>        b<span class="token punctuation">[</span>col<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">byte</span><span class="token punctuation">(</span><span class="token string">'Q'</span><span class="token punctuation">)</span>        board<span class="token punctuation">[</span>row<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">string</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// 进入下一行</span>        <span class="token function">backTrack</span><span class="token punctuation">(</span>board<span class="token punctuation">,</span> row <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// 撤销选择，回退一行（把皇后拿掉）</span>        b <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span>board<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">)</span>        b<span class="token punctuation">[</span>col<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">byte</span><span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span>        board<span class="token punctuation">[</span>row<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">string</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 判断当前位置是否合法，这里需要专门写个函数进行处理</span><span class="token keyword">func</span> <span class="token function">isValid</span><span class="token punctuation">(</span>board <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">,</span> row<span class="token punctuation">,</span> col <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">bool</span>  <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 从上往下，检查当前列是否存在冲突（列不变，行--）</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> row <span class="token operator">-</span> <span class="token number">1</span> <span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i<span class="token operator">--</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'Q'</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 左下角是否存在冲突（行--，列--）</span>    <span class="token keyword">for</span> i<span class="token punctuation">,</span> j <span class="token operator">:=</span> row <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> col <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> j <span class="token operator">>=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i<span class="token punctuation">,</span> j <span class="token operator">=</span> i<span class="token number">-1</span><span class="token punctuation">,</span> j<span class="token number">-1</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'Q'</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 右下角是否存在冲突（行--，列++）</span>    <span class="token keyword">for</span> i<span class="token punctuation">,</span> j <span class="token operator">:=</span> row <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> col <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>board<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token punctuation">,</span> j <span class="token operator">=</span> i<span class="token number">-1</span><span class="token punctuation">,</span> j<span class="token operator">+</span><span class="token number">1</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'Q'</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h1><h3 id="时间复杂度：O-N"><a href="#时间复杂度：O-N" class="headerlink" title="时间复杂度：O((N!))"></a>时间复杂度：O((N!))</h3><p>其中 N 是皇后数量。</p><h3 id="空间复杂度：O-N"><a href="#空间复杂度：O-N" class="headerlink" title="空间复杂度：O((N))"></a>空间复杂度：O((N))</h3><p>其中 N 是皇后数量。空间复杂度主要取决于递归调用层数、记录每行放置的皇后的列下标的数组以及三个集合，递归调用层数不会超过 N，数组的长度为 N，每个集合的元素个数都不会超过 N。</p><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><p>这道题有两个需要着重注意的点，特别容易错，我自己做的时候在这里踩了坑：</p><ol><li>对字符串重的某个字符进行赋值时，需要通过[]byte这种切片形式进行转化，不能直接给string中的某个字符进行赋值。</li><li>用于拷贝其一条路径的临时变量一定要用 make 开辟空间，分配地址，不能用 var tmp []string{} 进行声明，否则无法拷贝成功。</li></ol>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> DFS </tag>
            
            <tag> 回溯剪枝 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【leetcode-46】全排列</title>
      <link href="/2020/12/14/leetcode-46/"/>
      <url>/2020/12/14/leetcode-46/</url>
      
        <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/permutations/" target="_blank" rel="noopener">46. 全排列</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个 没有重复 数字的序列，返回其所有可能的全排列。</p><p>示例:</p><pre><code>输入: [1,2,3]输出:[  [1,2,3],  [1,3,2],  [2,1,3],  [2,3,1],  [3,1,2],  [3,2,1]]</code></pre><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>这是一个高中的排列组合问题，我们可以先想一想当时的我们是怎么做的，很明显就是穷举。</p><p>1，2，3，4</p><p>1，2，4，3</p><p>1，3，2，4</p><p>……</p><p>如此下去，其实就是用回溯法剪枝的方法遍历一棵二叉树，或者说深度优先遍历，是一个意思。</p><p>确定用回溯剪枝的方法后，就可以套用回溯剪枝的框架了</p><pre><code>result = []func backtrack(路径，选择列表) {    if 满足结束条件 {        result.add(路径)    }    return    for 选择 in 选择列表 {        做选择        backtrack(路径，选择列表)        撤销选择    }}</code></pre><p>想清楚几个问题</p><ol><li>结束条件是什么？（所有数字都用了一遍）</li><li>怎么定义走过的路径？（用一个数组保存一种排列方式）</li><li>如何做选择？（在给出的数字列表里面依次选）</li></ol><p>想清楚这几个问题就可以开始写代码了。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// 返回的全排列结果</span><span class="token keyword">var</span> res <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token keyword">func</span> <span class="token function">permute</span><span class="token punctuation">(</span>nums <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 注意：这里要重置一下全局数组（leetcode多次执行全局变量不会消失），防止多个测试用例的结果都放到一起</span>    res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 用一个数组维护走过的路径</span>    visited <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token builtin">bool</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 用 path 保存当前路径</span>    <span class="token keyword">var</span> path <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span>    <span class="token comment" spellcheck="true">// 回溯剪枝</span>    <span class="token function">backTrack</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> path<span class="token punctuation">,</span> visited<span class="token punctuation">)</span>    <span class="token keyword">return</span> res<span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">backTrack</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> path <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> visited  <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token builtin">bool</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 先判断结束条件, 走过的路径包含了所有的选择，说明已经得到一种排列方式</span>    <span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token function">len</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 注意：这里不能直接append，因为切片底层共用数据，</span>        <span class="token comment" spellcheck="true">// 这意味着下面切片path一旦改变了，res也会随之改变，而这不是我们希望看到的</span>        <span class="token comment" spellcheck="true">// 所以只能重新开辟一个新的切片将内容拷贝过去</span>        tmp <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token function">copy</span><span class="token punctuation">(</span>tmp<span class="token punctuation">,</span> path<span class="token punctuation">)</span>        res <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> tmp<span class="token punctuation">)</span>        <span class="token keyword">return</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 遍历选择列表，做选择</span>    <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> num <span class="token operator">:=</span> <span class="token keyword">range</span> nums <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 走过的分支直接跳过，直接走下一个分支，避免进入死循环</span>        <span class="token keyword">if</span> visited<span class="token punctuation">[</span>num<span class="token punctuation">]</span> <span class="token punctuation">{</span>            <span class="token keyword">continue</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 将这个选择加入当前路径</span>        path <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> num<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// 将这个选择置为已访问</span>        visited<span class="token punctuation">[</span>num<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span>        <span class="token comment" spellcheck="true">// 进入下一层决策树</span>        <span class="token function">backTrack</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> path<span class="token punctuation">,</span> visited<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// 退出决策树，回退，把这个选择从路径中移除</span>        path <span class="token operator">=</span> path<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token function">len</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>        <span class="token comment" spellcheck="true">// 将这个选择重新置为未访问</span>        visited<span class="token punctuation">[</span>num<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h1><h3 id="时间复杂度：O-n-n"><a href="#时间复杂度：O-n-n" class="headerlink" title="时间复杂度：O((n * n!))"></a>时间复杂度：O((n * n!))</h3><p>其中 n 为序列的长度。<br>算法的复杂度首先受 backtrack 的调用次数制约, 这说明 backtrack 的调用次数是 O((n!)) 的。</p><p>而对于 backtrack 调用的每个叶结点（共 n! 个），我们需要将当前答案使用 O((n)) 的时间复制到答案数组中，相乘得时间复杂度为 O((n * n!))。</p><h3 id="空间复杂度：O-n"><a href="#空间复杂度：O-n" class="headerlink" title="空间复杂度：O((n))"></a>空间复杂度：O((n))</h3><p>其中 n 为序列的长度。除答案数组以外，递归函数在递归过程中需要为每一层递归函数分配栈空间，所以这里需要额外的空间且该空间取决于递归的深度，这里可知递归调用深度为 O((n))</p><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><p>这道题有两个需要着重注意的点，特别容易错，我自己做的时候在这里卡了很久：</p><ol><li>如果定义了全局变量，需要注意要重置一下全局变量，否则多个测试用例的结果会被放到一起，因为leetcode多次执行全局变量不会消失</li><li>当获得一个排列时时，不能直接append，因为切片底层共用数据，这意味着下面如果切片path一旦改变了，我们的res也会随之改变，而这不是我们希望看到的，所以只能重新开辟一个新的切片将内容拷贝过去，这样就保证了path变的时候res不会跟着变</li></ol>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> DFS </tag>
            
            <tag> 回溯剪枝 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【leetcode-322】零钱兑换</title>
      <link href="/2020/12/13/leetcode-322/"/>
      <url>/2020/12/13/leetcode-322/</url>
      
        <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/coin-change/" target="_blank" rel="noopener">322. 零钱兑换</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p><p>你可以认为每种硬币的数量是无限的。</p><p>示例 1：</p><pre><code>输入：coins = [1, 2, 5], amount = 11输出：3 解释：11 = 5 + 5 + 1</code></pre><p>示例 2：</p><pre><code>输入：coins = [2], amount = 3输出：-1</code></pre><p>示例 3：</p><pre><code>输入：coins = [1], amount = 0输出：0</code></pre><p>示例 4：</p><pre><code>输入：coins = [1], amount = 1输出：1</code></pre><p>示例 5：</p><pre><code>输入：coins = [1], amount = 2输出：2</code></pre><p>提示：</p><ul><li>1 &lt;= coins.length &lt;= 12</li><li>1 &lt;= coins[i] &lt;= 231 - 1</li><li>0 &lt;= amount &lt;= 104</li></ul><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>这题可以考虑用动态规划求解，将大问题逐渐分解为小问题，对于动态规划需要考虑以下几步：</p><ol><li>定义 DP table</li><li>确定 base case（最简单情况）</li><li>列出状态转移方程</li></ol><p>对于这个问题，dp 数组可以这样定义：</p><ul><li>当目标金额为 i 时，至少需要 dp [ i ] 个硬币可以凑出</li></ul><p>base case 也就是：</p><ul><li>当目标金额为 0 时，需要 0 个硬币可以凑出</li></ul><p>状态转移方程：</p><pre><code>          0,                     amount = 0dp[n] =            dp[amount-coin] + 1,   amount &gt; 0</code></pre><p>明确了以上几点，就可以套动态规划的框架了</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">coinChange</span><span class="token punctuation">(</span>coins <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> amount <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 定义dp数组, 下标为目标金额，值为对应最少硬币数</span>    dp <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> amount<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 初始状态设置为最大值 amount+1，因为 n 个硬币最多需要 n 个一元硬币，</span>    <span class="token comment" spellcheck="true">// 但这里没有直接设置为下标是为了排除找不到（-1）这种情况</span>    <span class="token keyword">for</span> k <span class="token operator">:=</span> <span class="token keyword">range</span> dp <span class="token punctuation">{</span>        dp<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> amount <span class="token operator">+</span> <span class="token number">1</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 确定 base case</span>    dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>    <span class="token comment" spellcheck="true">// 外层循环遍历dp数组（所有状态）</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token keyword">range</span> dp <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 内层循环遍历硬币种类（求每个状态对应最少硬币数）</span>        <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> coin <span class="token operator">:=</span> <span class="token keyword">range</span> coins <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 排除单个硬币面值大于总额的情况（保证状态转移方程不会发生数组越界）</span>            <span class="token keyword">if</span> coin <span class="token operator">&lt;=</span> i <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 状态转移方程</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> coin<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 计算完整个dp数组（1 ～ amount的最小值），最后返回需要的最小值</span>    <span class="token comment" spellcheck="true">// 说明没找到，返回-1</span>    <span class="token keyword">if</span> dp<span class="token punctuation">[</span>amount<span class="token punctuation">]</span> <span class="token operator">==</span> amount <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> dp<span class="token punctuation">[</span>amount<span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 求较小值函数</span><span class="token keyword">func</span> <span class="token function">min</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> a <span class="token operator">&lt;</span> b <span class="token punctuation">{</span>        <span class="token keyword">return</span> a    <span class="token punctuation">}</span>    <span class="token keyword">return</span> b<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h1><h3 id="时间复杂度：O-Sn"><a href="#时间复杂度：O-Sn" class="headerlink" title="时间复杂度：O((Sn))"></a>时间复杂度：O((Sn))</h3><p>其中 S 是金额，n 是面额数。我们一共需要计算 O((S)) 个状态，S 为题目所给的总金额。对于每个状态，每次需要枚举 n 个面额来转移状态，所以一共需要 O((Sn)) 的时间复杂度。</p><h3 id="空间复杂度：O-S"><a href="#空间复杂度：O-S" class="headerlink" title="空间复杂度：O((S))"></a>空间复杂度：O((S))</h3><p>DP 数组需要开长度为总金额 S 的空间。</p><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><p>对于动态规划问题最重要的是列出状态转移方程，需要弄清楚</p><ol><li>这个问题的 base case（最简单情况）是什么？</li><li>有哪些状态？</li><li>对于每个状态可以作出什么选择使得状态发生改变？</li><li>如果定义 dp 数组来表示这种状态？</li></ol>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【leetcode-752】打开转盘锁</title>
      <link href="/2020/12/10/leetcode-752/"/>
      <url>/2020/12/10/leetcode-752/</url>
      
        <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/open-the-lock/" target="_blank" rel="noopener">752. 打开转盘锁</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有10个数字： ‘0’, ‘1’, ‘2’, ‘3’, ‘4’, ‘5’, ‘6’, ‘7’, ‘8’, ‘9’ 。每个拨轮可以自由旋转：例如把 ‘9’ 变为  ‘0’，’0’ 变为 ‘9’ 。每次旋转都只能旋转一个拨轮的一位数字。</p><p>锁的初始数字为 ‘0000’ ，一个代表四个拨轮的数字的字符串。</p><p>列表 deadends 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。</p><p>字符串 target 代表可以解锁的数字，你需要给出最小的旋转次数，如果无论如何不能解锁，返回 -1。</p><p>示例 1:</p><pre class="line-numbers language-go"><code class="language-go">输入：deadends <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"0201"</span><span class="token punctuation">,</span><span class="token string">"0101"</span><span class="token punctuation">,</span><span class="token string">"0102"</span><span class="token punctuation">,</span><span class="token string">"1212"</span><span class="token punctuation">,</span><span class="token string">"2002"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> target <span class="token operator">=</span> <span class="token string">"0202"</span>输出：<span class="token number">6</span>解释：可能的移动序列为 <span class="token string">"0000"</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">"1000"</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">"1100"</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">"1200"</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">"1201"</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">"1202"</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">"0202"</span>。注意 <span class="token string">"0000"</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">"0001"</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">"0002"</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">"0102"</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">"0202"</span> 这样的序列是不能解锁的，因为当拨动到 <span class="token string">"0102"</span> 时这个锁就会被锁定。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>示例 2:</p><pre class="line-numbers language-go"><code class="language-go">输入<span class="token punctuation">:</span> deadends <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"8888"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> target <span class="token operator">=</span> <span class="token string">"0009"</span>输出：<span class="token number">1</span>解释：把最后一位反向旋转一次即可 <span class="token string">"0000"</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">"0009"</span>。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>示例 3:</p><pre class="line-numbers language-go"><code class="language-go">输入<span class="token punctuation">:</span> deadends <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"8887"</span><span class="token punctuation">,</span><span class="token string">"8889"</span><span class="token punctuation">,</span><span class="token string">"8878"</span><span class="token punctuation">,</span><span class="token string">"8898"</span><span class="token punctuation">,</span><span class="token string">"8788"</span><span class="token punctuation">,</span><span class="token string">"8988"</span><span class="token punctuation">,</span><span class="token string">"7888"</span><span class="token punctuation">,</span><span class="token string">"9888"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> target <span class="token operator">=</span> <span class="token string">"8888"</span>输出：<span class="token operator">-</span><span class="token number">1</span>解释：无法旋转到目标数字且不被锁定。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>示例 4:</p><pre class="line-numbers language-go"><code class="language-go">输入<span class="token punctuation">:</span> deadends <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"0000"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> target <span class="token operator">=</span> <span class="token string">"8888"</span>输出：<span class="token operator">-</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>提示：</p><ol><li>死亡列表 deadends 的长度范围为 [1, 500]。</li><li>目标数字 target 不会在 deadends 之中。</li><li>每个 deadends 和 target 中的字符串的数字会在 10,000 个可能的情况 ‘0000’ 到 ‘9999’ 中产生。</li></ol><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>这道题乍一看感觉有些复杂，但是我们先别急，仔细思考一下这道题到底是要做什么。</p><p>首先，我们有一把锁，这把锁的其实状态是”0000”，然后我们通过不断拨动这把锁（每拨动一次，步数+1），最终得到我们的目标数字target。由于每次拨动的时候都只能改变一个数字，而且下一次拨动的结果是依赖于上一次的状态（相邻），每次拨动只能向上或向下，一共四个数字，那么就是8种可能，相当于每个节点有8个相邻的节点，其实就是BFS。</p><p>既然是BFS，我们就需要明确这几个问题：</p><ul><li><p>起点和终点</p><p>起点就是”0000”，终点是target</p></li><li><p>当前节点和相邻节点的关系（如何访问相邻节点）</p><p>向上向下拨动一次，相当于每个数字（一共四个）+1或者-1</p></li><li><p>会不会走回头路</p><p>需要一个数组visited记录每次访问过的数字</p></li></ul><p>此外，这道题还多了一个附加条件，就是不能访问死亡数字，这个很好解决，就是再定义一个数组，每访问一个数字就检查一下是否包含在死亡数字中。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">openLock</span><span class="token punctuation">(</span>deadends <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">,</span> target <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 记录需要跳过的死亡密码</span>    deads <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> k<span class="token punctuation">,</span> dead <span class="token operator">:=</span> <span class="token keyword">range</span> deadends <span class="token punctuation">{</span>        deads<span class="token punctuation">[</span>dead<span class="token punctuation">]</span> <span class="token operator">=</span> k    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 记录已经访问过的密码，主要是为了避免走回头路，陷入死循环</span>    visited <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span>    q <span class="token operator">:=</span> list<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    step <span class="token operator">:=</span> <span class="token number">0</span>    <span class="token comment" spellcheck="true">// 从起点 0000 开始 遍历</span>    q<span class="token punctuation">.</span><span class="token function">PushBack</span><span class="token punctuation">(</span><span class="token string">"0000"</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> <span class="token punctuation">;</span> q<span class="token punctuation">.</span><span class="token function">Len</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">;</span>  <span class="token punctuation">{</span>        size <span class="token operator">:=</span> q<span class="token punctuation">.</span><span class="token function">Len</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size <span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>            element <span class="token operator">:=</span> q<span class="token punctuation">.</span><span class="token function">Front</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            q<span class="token punctuation">.</span><span class="token function">Remove</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span>            cur<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> element<span class="token punctuation">.</span>Value<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token builtin">string</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">// 如果可能遇到死亡密码，直接跳过，不作处理</span>            <span class="token keyword">if</span> <span class="token boolean">_</span><span class="token punctuation">,</span> ok <span class="token operator">:=</span> deads<span class="token punctuation">[</span>cur<span class="token punctuation">]</span><span class="token punctuation">;</span> ok <span class="token punctuation">{</span>                <span class="token keyword">continue</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 到达终点，直接返回步数</span>            <span class="token keyword">if</span> cur <span class="token operator">==</span> target <span class="token punctuation">{</span>                <span class="token keyword">return</span> step            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 将相邻未遍历节点加入队列</span>            <span class="token keyword">for</span> j <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">4</span> <span class="token punctuation">;</span> j<span class="token operator">++</span>  <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 向上拨动，如果没有拨到过，就入队</span>                up <span class="token operator">:=</span> <span class="token function">addOne</span><span class="token punctuation">(</span>cur<span class="token punctuation">,</span> j<span class="token punctuation">)</span>                <span class="token keyword">if</span>  <span class="token boolean">_</span><span class="token punctuation">,</span> ok <span class="token operator">:=</span> visited<span class="token punctuation">[</span>up<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">!</span>ok <span class="token punctuation">{</span>                    q<span class="token punctuation">.</span><span class="token function">PushBack</span><span class="token punctuation">(</span>up<span class="token punctuation">)</span>                    visited<span class="token punctuation">[</span>up<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">// 向下拨动，如果没有拨到过，就入队</span>                down <span class="token operator">:=</span> <span class="token function">subOne</span><span class="token punctuation">(</span>cur<span class="token punctuation">,</span> j<span class="token punctuation">)</span>                <span class="token keyword">if</span>  <span class="token boolean">_</span><span class="token punctuation">,</span> ok <span class="token operator">:=</span> visited<span class="token punctuation">[</span>down<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">!</span>ok <span class="token punctuation">{</span>                    q<span class="token punctuation">.</span><span class="token function">PushBack</span><span class="token punctuation">(</span>down<span class="token punctuation">)</span>                    visited<span class="token punctuation">[</span>down<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 拨动了一次，步数+1</span>        step<span class="token operator">++</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 走到这里说明尝试了所有可能的次数，也没有拨到</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 向上拨动一次</span><span class="token keyword">func</span> <span class="token function">addOne</span><span class="token punctuation">(</span>s <span class="token builtin">string</span><span class="token punctuation">,</span> j <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">{</span>    b <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 9 再拨动一次是 0（特殊情况）</span>    <span class="token keyword">if</span> b<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'9'</span> <span class="token punctuation">{</span>        b<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'0'</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 其他直接+1就行</span>        b<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">++</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token function">string</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 向下拨动一次</span><span class="token keyword">func</span> <span class="token function">subOne</span><span class="token punctuation">(</span>s <span class="token builtin">string</span><span class="token punctuation">,</span> j <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">{</span>    b <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 0 再拨动一次是 9（特殊情况）</span>    <span class="token keyword">if</span> b<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'0'</span> <span class="token punctuation">{</span>        b<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'9'</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 其他直接-1</span>        b<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">--</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token function">string</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h1><h3 id="时间复杂度：O-N-2-A-N-D"><a href="#时间复杂度：O-N-2-A-N-D" class="headerlink" title="时间复杂度：O((N^2 * A^N + D))"></a>时间复杂度：O((N^2 * A^N + D))</h3><p>我们用 A 表示数字的个数，N 表示状态的位数，D 表示数组 deadends 的大小。在最坏情况下，我们需要搜索完所有状态，状态的总数为 O((A^N))。对于每个状态，我们要枚举修改的位置，需要 O((N)) 的时间，枚举后得到新的状态同样需要 O((N)) 的时间。</p><h3 id="空间复杂度：O-A-N-D"><a href="#空间复杂度：O-A-N-D" class="headerlink" title="空间复杂度：O((A^N + D))"></a>空间复杂度：O((A^N + D))</h3><p>用来存储队列以及 deadends 的集合。</p><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><ol><li><p>分析出问题的模型后，可以先写出代码框架（套模版），然后再根据实际情况进行进一步处理细节问题，不要一开始就陷入细节。</p></li><li><p>此外，这道题还可以用双向BFS进行优化，提升效率。</p></li></ol><ul><li>传统的BFS是从起点开始向四周进行扩散，遇到终点时停止；而双向BFS则是从起点和终点同时开始扩散，当两边有交集的时候停止。</li><li>双向BFS存在局限，就是要知道终点在哪里</li><li>双向BFS不再使用队列，而是使用 HashSet 方便快速地判断两个集合是否有交集</li></ul>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> tree </tag>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【leetcode-111】二叉树的最小深度</title>
      <link href="/2020/12/09/leetcode-111/"/>
      <url>/2020/12/09/leetcode-111/</url>
      
        <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/" target="_blank" rel="noopener">111. 二叉树的最小深度</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个二叉树，找出其最小深度。</p><p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p><p>说明：叶子节点是指没有子节点的节点。</p><p>示例 1：</p><p><img src="https://assets.leetcode.com/uploads/2020/10/12/ex_depth.jpg" alt></p><pre class="line-numbers language-go"><code class="language-go">输入：root <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span>null<span class="token punctuation">,</span>null<span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span>输出：<span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>示例 2：</p><pre class="line-numbers language-go"><code class="language-go">输入：root <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span>null<span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span>null<span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span>null<span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span>null<span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span>输出：<span class="token number">5</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>提示：</p><p>树中节点数的范围在 [0, 105] 内<br>-1000 &lt;= Node.val &lt;= 1000</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>这道题有两种常见解法，即DFS和BFS，各有优劣，但是都是套用模版就行。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><p>对于DFS的话，对于每一个非叶子节点，我们只需要分别递归地计算其左右子树的最小深度，然后当前子树的最小深度就是其中较小者+1</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">minDepth</span><span class="token punctuation">(</span>root <span class="token operator">*</span>TreeNode<span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 遍历到空节点，直接返回高度0</span>    <span class="token keyword">if</span> root <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 遍历到叶子节点，返回高度1</span>    <span class="token keyword">if</span> root<span class="token punctuation">.</span>Left <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>Right <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">1</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 定义一个无穷大的数</span>    minD <span class="token operator">:=</span> math<span class="token punctuation">.</span>MaxInt32    <span class="token comment" spellcheck="true">// 递归求左子树的最小高度</span>    <span class="token keyword">if</span> root<span class="token punctuation">.</span>Left <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        minD <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span><span class="token function">minDepth</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>Left<span class="token punctuation">)</span><span class="token punctuation">,</span> minD<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 递归求右子树的最小高度</span>    <span class="token keyword">if</span> root<span class="token punctuation">.</span>Right <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        minD <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span><span class="token function">minDepth</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>Right<span class="token punctuation">)</span><span class="token punctuation">,</span> minD<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 当前二叉树的最小高度等于左右子树的较小高度+1</span>    <span class="token keyword">return</span> minD <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//  写个求较小值的方法</span><span class="token keyword">func</span> <span class="token function">min</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> x <span class="token operator">&lt;</span> y <span class="token punctuation">{</span>        <span class="token keyword">return</span> x    <span class="token punctuation">}</span>    <span class="token keyword">return</span> y<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><p>对于BFS就是首先明确起点和终点，而在这道题中，起点就是根节点，终点就是叶子节点（左右子节点都是nil），然后就可以套模版了。</p><p>模版如下：</p><ol><li>定义队列</li><li>将第一个节点加入队列（起点）</li><li>只要队列不空，循环</li><li>依次从队首拿出元素，判断是否到达终点</li><li>将其相邻节点加入队列</li><li>更新步数</li></ol><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">minDepth</span><span class="token punctuation">(</span>root <span class="token operator">*</span>TreeNode<span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> root <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 这里用了go的一个list库</span>    q <span class="token operator">:=</span> list<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true">// 根节点入队（从根节点开始）</span>    q<span class="token punctuation">.</span><span class="token function">PushBack</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// root本身就是一层，将depth初始化为1</span>    depth <span class="token operator">:=</span> <span class="token number">1</span>    <span class="token comment" spellcheck="true">// 只要队列不空，就遍历队列中的元素</span>    <span class="token keyword">for</span> <span class="token punctuation">;</span> q<span class="token punctuation">.</span><span class="token function">Len</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">{</span>        size <span class="token operator">:=</span> q<span class="token punctuation">.</span><span class="token function">Len</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size <span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 取出队首元素，并删除</span>            front <span class="token operator">:=</span> q<span class="token punctuation">.</span><span class="token function">Front</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            q<span class="token punctuation">.</span><span class="token function">Remove</span><span class="token punctuation">(</span>front<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">// 进行类型断言</span>            node<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> front<span class="token punctuation">.</span>Value<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token operator">*</span>TreeNode<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">// 判断是否到达终点</span>            <span class="token keyword">if</span> node<span class="token punctuation">.</span>Left <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token operator">&amp;&amp;</span> node<span class="token punctuation">.</span>Right <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> depth            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 将左右子节点加入队列</span>            <span class="token keyword">if</span> node<span class="token punctuation">.</span>Left <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>                q<span class="token punctuation">.</span><span class="token function">PushBack</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>Left<span class="token punctuation">)</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> node<span class="token punctuation">.</span>Right <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>                q<span class="token punctuation">.</span><span class="token function">PushBack</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>Right<span class="token punctuation">)</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 往前推进了一层，步数+1</span>        depth <span class="token operator">++</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> depth<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h1><h3 id="DFS-1"><a href="#DFS-1" class="headerlink" title="DFS"></a>DFS</h3><p>时间复杂度：O((N))，其中 N 是树的节点数。对每个节点访问一次。</p><p>空间复杂度：O((H))，其中 H 是树的高度。空间复杂度主要取决于递归时栈空间的开销，最坏情况下，树呈现链状，空间复杂度为 O((N))。平均情况下树的高度与节点数的对数正相关，空间复杂度为 O((logN))。</p><h3 id="BFS-1"><a href="#BFS-1" class="headerlink" title="BFS"></a>BFS</h3><p>时间复杂度：O((N))，其中 N 是树的节点数。对每个节点访问一次。</p><p>空间复杂度：O((N))，其中 N 是树的节点数。空间复杂度主要取决于队列的开销，队列中的元素个数不会超过树的节点数。</p><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><p>这里用到了go的一个库来模拟队列，可以参考</p><p><a href="https://blog.wolfogre.com/posts/slice-queue-vs-list-queue/" target="_blank" rel="noopener">https://blog.wolfogre.com/posts/slice-queue-vs-list-queue/</a></p><blockquote><p>深度优先和广度优先遍历都可以找到最短距离，但是广度优先遍历的时间复杂度更低，深度优先遍历的空间复杂度更低。这是因为在实际情况下，BFS一旦推进到叶子节点就结束了，还没遍历完整棵树。而DFS一定是要遍历完所有节点，然后进行比较才能得出最短路径。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> tree </tag>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【leetcode-654】最大二叉树</title>
      <link href="/2020/12/07/leetcode-654/"/>
      <url>/2020/12/07/leetcode-654/</url>
      
        <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/maximum-binary-tree/" target="_blank" rel="noopener">654. 最大二叉树</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下:</p><ol><li>二叉树的根是数组中的最大元素。</li><li>左子树是通过数组中最大值左边部分构造出的最大二叉树。</li><li>右子树是通过数组中最大值右边部分构造出的最大二叉树。</li></ol><p>通过给定的数组构建最大二叉树，并且输出这个树的根节点。</p><p>示例 ：</p><pre class="line-numbers language-go"><code class="language-go">输入：<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span>输出：返回下面这棵树的根节点：      <span class="token number">6</span>    <span class="token operator">/</span>   \   <span class="token number">3</span>     <span class="token number">5</span>    \    <span class="token operator">/</span>      <span class="token number">2</span>  <span class="token number">0</span>          \        <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>这道题的解题思路比较常规，没有什么特别的技巧，就是遍历数组找到最大值，作为根节点 root，然后对最大值左边的数组和右边的数组进行递归调用，作为 root 的左右子树。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">/** * Definition for a binary tree node. * type TreeNode struct { *     Val int *     Left *TreeNode *     Right *TreeNode * } */</span><span class="token keyword">func</span> <span class="token function">constructMaximumBinaryTree</span><span class="token punctuation">(</span>nums <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">*</span>TreeNode <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">constuct</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">constuct</span><span class="token punctuation">(</span>nums <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> low<span class="token punctuation">,</span> high <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">*</span>TreeNode <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 说明当前要找的数组已经没有元素了</span>    <span class="token keyword">if</span> low <span class="token operator">></span> high <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">nil</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 找到最大值的下标</span>    index <span class="token operator">:=</span> <span class="token function">findMaxNodeIndex</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 根据最大值构造根节点</span>    root <span class="token operator">:=</span> <span class="token function">new</span><span class="token punctuation">(</span>TreeNode<span class="token punctuation">)</span>    root<span class="token punctuation">.</span>Val <span class="token operator">=</span> nums<span class="token punctuation">[</span>index<span class="token punctuation">]</span>    <span class="token comment" spellcheck="true">// 左右递归遍历构造左右子树，注意数组边界（+1和-1）</span>    root<span class="token punctuation">.</span>Left <span class="token operator">=</span> <span class="token function">constuct</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> low<span class="token punctuation">,</span> index<span class="token number">-1</span><span class="token punctuation">)</span>    root<span class="token punctuation">.</span>Right <span class="token operator">=</span> <span class="token function">constuct</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> high<span class="token punctuation">)</span>    <span class="token keyword">return</span> root<span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 返回指定数组中最大值的那个下标</span><span class="token keyword">func</span> <span class="token function">findMaxNodeIndex</span><span class="token punctuation">(</span>nums <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> low<span class="token punctuation">,</span> high <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span>    index <span class="token operator">:=</span> low    <span class="token keyword">for</span> i <span class="token operator">:=</span> low<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> high <span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token punctuation">{</span>            index <span class="token operator">=</span> i        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> index<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>反思：在搭建好框架后还要处理一些细节问题，比如 “=” 取不取得到，要不要 “+1” 或者 “-1” 等，这些细节问题可能还需要debug的时候一点点去抠</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【leetcode-114】二叉树展开为链表</title>
      <link href="/2020/12/04/leetcode-114/"/>
      <url>/2020/12/04/leetcode-114/</url>
      
        <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/" target="_blank" rel="noopener">114. 二叉树展开为链表</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个二叉树，原地将它展开为一个单链表。</p><p>例如，给定二叉树：</p><pre class="line-numbers language-go"><code class="language-go">    <span class="token number">1</span>   <span class="token operator">/</span> \  <span class="token number">2</span>   <span class="token number">5</span> <span class="token operator">/</span> \   \<span class="token number">3</span>   <span class="token number">4</span>   <span class="token number">6</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将其展开为：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token number">1</span> \  <span class="token number">2</span>   \    <span class="token number">3</span>     \      <span class="token number">4</span>       \        <span class="token number">5</span>         \          <span class="token number">6</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>这道题只要稍微观察一下就可以发现链表中元素的顺序刚好是二叉树进行前序遍历的顺序，但是还需要注意的一点是，由于将二叉树展开成一个链表会破坏二叉树的结构，所以这里我们还需要一个额外的切片来存储这些节点。</p><p>至此，这道题的解题思路就出来了</p><ol><li>开辟一个切片用于保存节点。</li><li>对二叉树进行前序遍历。</li><li>遍历到根节点的时候将节点放到切片中。</li><li>最后按照切片的顺序将相邻节点依次首尾相连成一个链表。</li></ol><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">/** * Definition for a binary tree node. * type TreeNode struct { *     Val int *     Left *TreeNode *     Right *TreeNode * } */</span><span class="token keyword">func</span> <span class="token function">flatten</span><span class="token punctuation">(</span>root <span class="token operator">*</span>TreeNode<span class="token punctuation">)</span>  <span class="token punctuation">{</span>   list <span class="token operator">:=</span> <span class="token function">preOrderTraverse</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 按照切片的顺序重新组装这些节点</span>   <span class="token keyword">for</span> i<span class="token operator">:=</span><span class="token number">1</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span> <span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>       <span class="token comment" spellcheck="true">// 相邻元素首尾相连，</span>       pre<span class="token punctuation">,</span> post <span class="token operator">:=</span> list<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> list<span class="token punctuation">[</span>i<span class="token punctuation">]</span>       <span class="token comment" spellcheck="true">// 注意原节点的left要置为空，否则就不是链表了</span>       pre<span class="token punctuation">.</span>Left<span class="token punctuation">,</span> pre<span class="token punctuation">.</span>Right <span class="token operator">=</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> post   <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">preOrderTraverse</span><span class="token punctuation">(</span>root <span class="token operator">*</span>TreeNode<span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>TreeNode <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 开辟一个新的切片用于保存节点</span>    list <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>TreeNode<span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 按照前序遍历的顺序递归访问这些节点</span>    <span class="token keyword">if</span> root <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 访问根节点时将这个节点append到数组中</span>        list <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> root<span class="token punctuation">)</span>        list <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> <span class="token function">preOrderTraverse</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>Left<span class="token punctuation">)</span><span class="token operator">...</span><span class="token punctuation">)</span>        list <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> <span class="token function">preOrderTraverse</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>Right<span class="token punctuation">)</span><span class="token operator">...</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> list<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【leetcode-116】填充每个节点的下一个右侧节点指针</title>
      <link href="/2020/12/04/leetcode-116/"/>
      <url>/2020/12/04/leetcode-116/</url>
      
        <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/" target="_blank" rel="noopener">116. 填充每个节点的下一个右侧节点指针</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">struct</span> Node <span class="token punctuation">{</span>  <span class="token builtin">int</span> val<span class="token punctuation">;</span>  Node <span class="token operator">*</span>left<span class="token punctuation">;</span>  Node <span class="token operator">*</span>right<span class="token punctuation">;</span>  Node <span class="token operator">*</span>next<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p><p>初始状态下，所有 next 指针都被设置为 NULL。</p><p>进阶：</p><ul><li>你只能使用常量级额外空间。</li><li>使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</li></ul><p>示例：</p><p><img src="https://assets.leetcode.com/uploads/2019/02/14/116_sample.png" alt></p><pre><code>输入：root = [1,2,3,4,5,6,7]输出：[1,#,2,3,#,4,5,6,7,#]解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化的输出按层序遍历排列，同一层节点由 next 指针连接，&#39;#&#39; 标志着每一层的结束。</code></pre><p>提示：</p><ul><li>树中节点的数量少于 4096</li><li>-1000 &lt;= node.val &lt;= 1000</li></ul><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>二叉树的解题分三步走：</p><ol><li>一般节点应该做什么</li><li>叶子节点应该做什么</li><li>前序、中序还是后序</li></ol><p>对于这道题一般节点需要将它的左子树根节点的 next 域指向右子树的根节点</p><p>然后对于叶子节点依旧是直接返回自身即可</p><p>至于遍历次序的话可以先都试试看～</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>于是我们很快就能写出如下答案:</p><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">/** * Definition for a Node. * type Node struct { *     Val int *     Left *Node *     Right *Node *     Next *Node * } */</span><span class="token keyword">func</span> <span class="token function">connect</span><span class="token punctuation">(</span>root <span class="token operator">*</span>Node<span class="token punctuation">)</span> <span class="token operator">*</span>Node <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 为了防止下面的操作出现空指针报错</span>    <span class="token keyword">if</span> root <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token operator">||</span> root<span class="token punctuation">.</span>Left <span class="token operator">==</span> <span class="token boolean">nil</span>  <span class="token punctuation">{</span>        <span class="token keyword">return</span> root    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//左子树根节点的 next 域指向右子树的根节点</span>    root<span class="token punctuation">.</span>Left<span class="token punctuation">.</span>Next <span class="token operator">=</span> root<span class="token punctuation">.</span>Right    <span class="token function">connect</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>Left<span class="token punctuation">)</span>    <span class="token function">connect</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>Right<span class="token punctuation">)</span>    <span class="token keyword">return</span> root<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>需要注意的是，对于叶子节点的判断，由于存在 root.Left.Next 这个逻辑，意味着root.Left不能为空，在一开始需要加上这个判断，否则会报空指针错误</p></blockquote><p>当我们写出如上代码进行提交时，会得到如下结果：</p><pre class="line-numbers language-go"><code class="language-go">输入<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span>输出<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span>#<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span>#<span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span>#<span class="token punctuation">]</span>预期结果<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span>#<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span>#<span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span>#<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们会发现5号节点的后面直接是空，而不是7号节点，原来是因为5号和6号并不在同一棵子树中（他们的父节点不是同一个），因此需要考虑这种特殊情况。</p><p>完善后的代码如下：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">/** * Definition for a Node. * type Node struct { *     Val int *     Left *Node *     Right *Node *     Next *Node * } */</span><span class="token keyword">func</span> <span class="token function">connect</span><span class="token punctuation">(</span>root <span class="token operator">*</span>Node<span class="token punctuation">)</span> <span class="token operator">*</span>Node <span class="token punctuation">{</span>    <span class="token keyword">if</span> root <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token operator">||</span> root<span class="token punctuation">.</span>Left <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> root    <span class="token punctuation">}</span>    root<span class="token punctuation">.</span>Left<span class="token punctuation">.</span>Next <span class="token operator">=</span> root<span class="token punctuation">.</span>Right    <span class="token comment" spellcheck="true">// 增加了不在同一棵子树的情况，注意防止出现空指针报错</span>    <span class="token keyword">if</span> root<span class="token punctuation">.</span>Next <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>Right <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        root<span class="token punctuation">.</span>Right<span class="token punctuation">.</span>Next <span class="token operator">=</span> root<span class="token punctuation">.</span>Next<span class="token punctuation">.</span>Left    <span class="token punctuation">}</span>    <span class="token function">connect</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>Left<span class="token punctuation">)</span>    <span class="token function">connect</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>Right<span class="token punctuation">)</span>    <span class="token keyword">return</span> root<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>反思：二叉树的题目重在观察，有时候我们可以快速写出题解，但是答案却不对，这个时候或许需要注意考虑一些特殊情况</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【leetcode-226】翻转二叉树</title>
      <link href="/2020/12/02/leetcode-226/"/>
      <url>/2020/12/02/leetcode-226/</url>
      
        <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/invert-binary-tree/" target="_blank" rel="noopener">226. 翻转二叉树</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>翻转一棵二叉树。</p><p>示例：</p><p>输入：</p><pre class="line-numbers language-go"><code class="language-go">     <span class="token number">4</span>   <span class="token operator">/</span>   \  <span class="token number">2</span>     <span class="token number">7</span> <span class="token operator">/</span> \   <span class="token operator">/</span> \<span class="token number">1</span>   <span class="token number">3</span> <span class="token number">6</span>   <span class="token number">9</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出：</p><pre class="line-numbers language-go"><code class="language-go">     <span class="token number">4</span>   <span class="token operator">/</span>   \  <span class="token number">7</span>     <span class="token number">2</span> <span class="token operator">/</span> \   <span class="token operator">/</span> \<span class="token number">9</span>   <span class="token number">6</span> <span class="token number">3</span>   <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>观察两棵二叉树，我们会发现对于第一棵树，只要把每个节点的左右子节点进行交换就能得到第二棵树，接下来就是套用二叉树的模版了，当然在写代码前我们还需要考虑：</p><ol><li>如何实现两个节点的交换？</li><li>选择前序遍历、中序便利还是后序遍历？</li><li>对于叶子节点应该怎么操作？</li></ol><p>想明白了以上几个问题，就可以写题解了。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">/** * Definition for a binary tree node. * type TreeNode struct { *     Val int *     Left *TreeNode *     Right *TreeNode * } */</span><span class="token keyword">func</span> <span class="token function">invertTree</span><span class="token punctuation">(</span>root <span class="token operator">*</span>TreeNode<span class="token punctuation">)</span> <span class="token operator">*</span>TreeNode <span class="token punctuation">{</span>    <span class="token keyword">if</span> root <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">nil</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 交换左右子树节点</span>    temp <span class="token operator">:=</span> root<span class="token punctuation">.</span>Left    root<span class="token punctuation">.</span>Left <span class="token operator">=</span> root<span class="token punctuation">.</span>Right    root<span class="token punctuation">.</span>Right <span class="token operator">=</span> temp    <span class="token function">invertTree</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>Left<span class="token punctuation">)</span>    <span class="token function">invertTree</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>Right<span class="token punctuation">)</span>    <span class="token keyword">return</span> root<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>值得一提的是，这道题用前序和后序遍历是可以的，而中序遍历则不行（为什么）</p></blockquote><p>二叉树题目的一个难点就是，如何把题目的要求细化成每个节点需要做的事情，像这道题就是相当于交换每个节点的左右子节点。</p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fabric 链上数据防篡改</title>
      <link href="/2020/08/15/tamper-with-data/"/>
      <url>/2020/08/15/tamper-with-data/</url>
      
        <content type="html"><![CDATA[<blockquote><p>近日，因为工作需要，对 fabric 数据防篡改机制进行了研究，这里提供了一种验证链上数据防篡改的场景以供参考</p></blockquote><h1 id="基本思路："><a href="#基本思路：" class="headerlink" title="基本思路："></a>基本思路：</h1><p>进入某个peer节点修改本地的 Couch DB 数据，修改完后再调用链码发送一笔交易，发现执行结果是该 peer 节点的数据重新变为修改前的数据，说明篡改数据失败，系统具有放篡改能力。</p><p>具体操作如下，为了简化操作，直接借助官方使用 couchdb 样例，链码为 mymarble</p><p>先进入 firstnetwork 目录，执行以下命令起一个使用 couchdb 的byfn网络</p><pre><code>./byfn.sh up -c mychannel -s couchdb</code></pre><p>然后进入客户端</p><pre><code>docker exec -it cli bashexport CHANNEL_NAME=mychannel</code></pre><p>执行以下命令</p><pre><code># peer0.org1 安装链码CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/mspCORE_PEER_ADDRESS=peer0.org1.example.com:7051CORE_PEER_LOCALMSPID=&quot;Org1MSP&quot;CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crtpeer chaincode install -n  mymarble  -v 1.0.0  -p github.com/chaincode/marbles02/go# peer1.org1 安装链码CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/mspCORE_PEER_ADDRESS=peer1.org1.example.com:8051CORE_PEER_LOCALMSPID=&quot;Org1MSP&quot;CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer1.org1.example.com/tls/ca.crtpeer chaincode install -n  mymarble  -v 1.0.0  -p github.com/chaincode/marbles02/go# peer0.org2 安装链码CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/mspCORE_PEER_ADDRESS=peer0.org2.example.com:9051CORE_PEER_LOCALMSPID=&quot;Org2MSP&quot;CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crtpeer chaincode install -n  mymarble  -v 1.0.0  -p github.com/chaincode/marbles02/go# peer1.org2 安装链码CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/mspCORE_PEER_ADDRESS=peer1.org2.example.com:10051CORE_PEER_LOCALMSPID=&quot;Org2MSP&quot;CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer1.org2.example.com/tls/ca.crtpeer chaincode install -n  mymarble  -v 1.0.0  -p github.com/chaincode/marbles02/go# 实例化链链码peer chaincode instantiate -o orderer.example.com:7050 --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C mychannel -n mymarble -v 1.0.0 -c &#39;{&quot;Args&quot;:[&quot;init&quot;]}&#39; -P &quot;AND (&#39;Org1MSP.peer&#39;,&#39;Org2MSP.peer&#39;)&quot;peer chaincode invoke -o orderer.example.com:7050 --tls true --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C $CHANNEL_NAME -n mymarble --peerAddresses peer0.org1.example.com:7051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt --peerAddresses peer0.org2.example.com:9051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt -c &#39;{&quot;Args&quot;:[&quot;initMarble&quot;,&quot;marble1&quot;,&quot;blue&quot;,&quot;35&quot;,&quot;tom&quot;]}&#39;</code></pre><p>此时打开浏览器 <a href="http://localhost:5984/_utils/" target="_blank" rel="noopener">http://localhost:5984/_utils/</a></p><p>进入 peer0.org1 （对外暴露端口为5984）的 couchdb，查看 marble1 变量：</p><pre><code>{  &quot;_id&quot;: &quot;marble1&quot;,  &quot;_rev&quot;: &quot;1-1d12a3e8f79f5c0e40cc73c43701a6ba&quot;,  &quot;color&quot;: &quot;blue&quot;,  &quot;docType&quot;: &quot;marble&quot;,  &quot;name&quot;: &quot;marble1&quot;,  &quot;owner&quot;: &quot;tom&quot;,  &quot;size&quot;: 35,  &quot;~version&quot;: &quot;\u0000CgMBBgA=&quot;}</code></pre><p>我们可以看到在 couchdb 中保存了 marble1 的各个字段的属性。</p><p>然后手动将其中的 35 改为25，并保存（试图通过修改peer本地的couchdb中的数据实现篡改数据的操作）。</p><p>此时在终端调用以下链码，即将 marble1 给 jerry</p><pre><code>peer chaincode invoke -o orderer.example.com:7050 --tls true --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C $CHANNEL_NAME -n mymarble --peerAddresses peer0.org1.example.com:7051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt --peerAddresses peer0.org2.example.com:9051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt -c &#39;{&quot;Args&quot;:[&quot;transferMarble&quot;,&quot;marble1&quot;,&quot;jerry&quot;]}&#39;</code></pre><h5 id="注意此时指定的背书节点为-peer0-org1-和-peer0-org2"><a href="#注意此时指定的背书节点为-peer0-org1-和-peer0-org2" class="headerlink" title="注意此时指定的背书节点为 peer0.org1 和 peer0.org2"></a>注意此时指定的背书节点为 peer0.org1 和 peer0.org2</h5><p><img src="https://note.youdao.com/yws/public/resource/bc554143fcca768f52bf1354ffef92eb/xmlnote/619D267654E5418CA1199D1E0060BEA7/3390" alt></p><p>发现调用失败，返回背书不满足<br>这主要是因为 peer0.org1 的 couchdb 的数据已经改变，和 peer0.org1 的数据不同，导致模拟执行失败</p><p>此时，将其中一个背书节点背书节点 peer0.org1 替换成 peer1.org1，此时再次调用链码</p><pre><code>peer chaincode invoke -o orderer.example.com:7050 --tls true --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C $CHANNEL_NAME -n mymarble --peerAddresses peer1.org1.example.com:8051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer1.org1.example.com/tls/ca.crt --peerAddresses peer0.org2.example.com:9051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt -c &#39;{&quot;Args&quot;:[&quot;transferMarble&quot;,&quot;marble1&quot;,&quot;jerry&quot;]}&#39;</code></pre><p>链码调用成功</p><p>再次进入peer0.org1的couchdb，对外暴露端口为5984</p><p><a href="http://localhost:5984/_utils/" target="_blank" rel="noopener">http://localhost:5984/_utils/</a></p><p>发现此时 marble1  的owner 已经变为jerry，并且仍然是35</p><pre><code>{  &quot;_id&quot;: &quot;marble1&quot;,  &quot;_rev&quot;: &quot;3-c2280ec7b75f7f5536b490acf10515a0&quot;,  &quot;color&quot;: &quot;blue&quot;,  &quot;docType&quot;: &quot;marble&quot;,  &quot;name&quot;: &quot;marble1&quot;,  &quot;owner&quot;: &quot;jerry&quot;,  &quot;size&quot;: 35,  &quot;~version&quot;: &quot;\u0000CgMBBwA=&quot;}</code></pre><p>说明试图篡改数据的操作失败，系统具有防篡改能力</p>]]></content>
      
      
      
        <tags>
            
            <tag> fabric </tag>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fabric 2.2 生命周期链码实战</title>
      <link href="/2020/08/08/fabric-chaincode-2-2/"/>
      <url>/2020/08/08/fabric-chaincode-2-2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>fabric 2.2和1.4的一个重要不同就是进一步完善了对链码的生命周期管理</p></blockquote><h1 id="打包（package）"><a href="#打包（package）" class="headerlink" title="打包（package）"></a>打包（package）</h1><p>必须先打包链码，然后才能将其安装在peer节点上。可以使用 peer lifecycle chaincode package 命令打包Go链码。</p><ul><li><p>使用 –path 标志指示链码的位置。该路径必须是标准路径或相对于您当前工作目录的路径。</p></li><li><p>使用 –label 标志指定 stupid 作为组织用于标识的被打包的链码的标签。</p></li></ul><pre><code>peer lifecycle chaincode package stupid.tar.gz --path github.com/chaincode/stupid --lang golang --label stupid</code></pre><h1 id="安装（install）"><a href="#安装（install）" class="headerlink" title="安装（install）"></a>安装（install）</h1><p>打包链码后，可以使用 peer chaincode install 命令在 peer 节点上安装链码。</p><ul><li>将stupid.tar.gz软件包安装在 peer0.org1.example.com 上。</li></ul><pre><code>peer lifecycle chaincode install stupid.tar.gz2020-08-07 03:29:49.473 UTC [cli.lifecycle.chaincode] submitInstallProposal -&gt; INFO 001 Installed remotely: response:&lt;status:200 payload:&quot;\nGstupid:27a22f86b653f2fd487a41af58404de8cdac47b4c09dddecc16fef2f7f60e2c2\022\006stupid&quot; &gt;2020-08-07 03:29:49.477 UTC [cli.lifecycle.chaincode] submitInstallProposal -&gt; INFO 002 Chaincode code package identifier: stupid:27a22f86b653f2fd487a41af58404de8cdac47b4c09dddecc16fef2f7f60e2c2</code></pre><ul><li>切换为 peer1.org1，并安装链码</li></ul><pre><code>export CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/mspexport CORE_PEER_ADDRESS=peer1.org1.example.com:8051export CORE_PEER_LOCALMSPID=&quot;Org1MSP&quot;export CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer1.org1.example.com/tls/ca.crtpeer lifecycle chaincode install stupid.tar.gz</code></pre><ul><li>切换为 peer0.org2，并安装链码</li></ul><pre><code>export CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/mspexport CORE_PEER_ADDRESS=peer0.org2.example.com:9051export CORE_PEER_LOCALMSPID=&quot;Org2MSP&quot;export CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crtpeer lifecycle chaincode install stupid.tar.gz</code></pre><ul><li>切换为 peer1.org2，并安装链码</li></ul><pre><code>export CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/mspexport CORE_PEER_ADDRESS=peer1.org2.example.com:10051export CORE_PEER_LOCALMSPID=&quot;Org2MSP&quot;export CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer1.org2.example.com/tls/ca.crtpeer lifecycle chaincode install stupid.tar.gz</code></pre><ul><li>检查是否安装成功</li></ul><pre><code>export CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/mspexport CORE_PEER_ADDRESS=peer1.org1.example.com:8051export CORE_PEER_LOCALMSPID=&quot;Org1MSP&quot;export CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer1.org1.example.com/tls/ca.crtpeer lifecycle chaincode queryinstalled --peerAddresses peer0.org1.example.com:7051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crtInstalled chaincodes on peer:Package ID: stupid:27a22f86b653f2fd487a41af58404de8cdac47b4c09dddecc16fef2f7f60e2c2, Label: stupid</code></pre><p>安装链码成功后会返回一个标识符，这个标识符与在下一步会用到。<br>链码标签和哈希值构成了标识符。</p><h1 id="批准（approve）"><a href="#批准（approve）" class="headerlink" title="批准（approve）"></a>批准（approve）</h1><p>在peer节点上安装了chaincode程序包后，可以批准组织的链码定义。链码定义包括链码管理的重要参数，包括链码名称，版本和认可策略等。</p><p>这是命令的示例，该命令批准在channel 版本上命名的链码的定义。</p><ul><li>使用 –package-id 标志传递链码包标识符。</li><li>使用 –signature-policy标志定义链码的背书策略。</li><li>使用 –init-required标志请求执行 Init 函数初始化链码。</li></ul><p>需要注意的是，每个组织都需要进行一次approveformyorg操作，具体需要由组织内的任意一个具有管理员权限的节点来进行即可：</p><p>切换 peer0.org1.example.com，进行approveformyorg 操作，批准链码定义：</p><pre><code>export CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/mspexport CORE_PEER_ADDRESS=peer0.org1.example.com:7051export CORE_PEER_LOCALMSPID=&quot;Org1MSP&quot;export CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crtpeer lifecycle chaincode approveformyorg  -o orderer.example.com:7050 --tls true --cafile $ORDERER_CA --channelID mychannel --name stupid --version 1.0 --init-required --package-id stupid:27a22f86b653f2fd487a41af58404de8cdac47b4c09dddecc16fef2f7f60e2c2 --sequence 1 --signature-policy &quot;AND (&#39;Org1MSP.peer&#39;,&#39;Org2MSP.peer&#39;)&quot; --waitForEvent</code></pre><p>结果输出以下内容：</p><pre><code>2020-08-07 03:47:33.708 UTC [chaincodeCmd] ClientWait -&gt; INFO 001 txid [5f92b2c3b14ddc80829c9c89bc602069a3fd868ec358c4d5d329ccb8dee0b530] committed with status (VALID) at</code></pre><p>然后我们再切换到 peer0.org2.example.com 进行一次 approveformyorg 操作</p><p>切换 peer0.org2.example.com，并批准链码定义</p><pre><code>export CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/mspexport CORE_PEER_ADDRESS=peer0.org2.example.com:9051export CORE_PEER_LOCALMSPID=&quot;Org2MSP&quot;export CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crtexport ORDERER_CA=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pempeer lifecycle chaincode approveformyorg  -o orderer.example.com:7050 --tls --cafile $ORDERER_CA --channelID mychannel --name stupid --version 1.0 --init-required --package-id stupid:27a22f86b653f2fd487a41af58404de8cdac47b4c09dddecc16fef2f7f60e2c2 --sequence 1 --signature-policy &quot;AND (&#39;Org1MSP.peer&#39;,&#39;Org2MSP.peer&#39;)&quot; --waitForEvent</code></pre><ul><li><p>检查是否批准成功</p><pre><code>peer lifecycle chaincode checkcommitreadiness -o orderer.example.com:7050 --channelID mychannel --tls --cafile $ORDERER_CA --name stupid --version 1.0 --init-required --sequence 1 --output json</code></pre></li><li><p>输出结果如下：</p><pre><code>{  &quot;approvals&quot;: {      &quot;Org1MSP&quot;: false,      &quot;Org2MSP&quot;: false  }}</code></pre></li></ul><p>这里显示都是 false，说明批准并未成功，此时可以再尝试进行一次approformyorg 操作，结果如下：</p><pre><code>Error: proposal failed with status: 500 - failed to invoke backing implementation of &#39;ApproveChaincodeDefinitionForMyOrg&#39;: attempted to redefine uncommitted sequence (1) for namespace stupid with unchanged content</code></pre><p>出现这种情况说明存在当前最新的合约没有commit，无法进行新的approve，换句话说就是对同一个链码在同一家组织进行了两次approve操作，而这是不被允许的，说明之前的 approve 操作是成功的，这就与“批准并未成功”的结论矛盾了，到底有没有成功呢？</p><p>请注意，这里是一个比较坑的地方，因为这可能是一个bug，实际上已经approve成功了，但是checkcommitreadiness却显示为false，此时，我们可以先往下走，直接进入commit阶段，如果没问题的话，就接着往下走。</p><p>目前尚不清楚这个是我操作的原因还是fabric 2.x 的一个bug，因为网上有其他人也跟我遇到了同样的问题。</p><h1 id="提交（commit）"><a href="#提交（commit）" class="headerlink" title="提交（commit）"></a>提交（commit）</h1><p>一旦足够多的组织批准了其组织的链代码定义（默认情况下为大多数），则一个组织可以使用 peer lifecycle chaincode commit 命令将该定义提交给渠道。</p><p>该命令需要针对通道上其他组织的peer节点，以收集其组织对定义的认可。</p><pre><code>export ORDERER_CA=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pempeer lifecycle chaincode commit -o orderer.example.com:7050 --channelID mychannel --name stupid --version 1.0 --sequence 1 --init-required --tls true --cafile $ORDERER_CA --peerAddresses peer0.org1.example.com:7051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt --peerAddresses peer0.org2.example.com:9051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt --signature-policy &quot;AND (&#39;Org1MSP.peer&#39;,&#39;Org2MSP.peer&#39;)&quot;</code></pre><p>此处是不是可以不指定 peerAddresses，还有待验证…</p><p>输出结果如下：</p><pre><code>2020-08-08 08:56:13.430 UTC [chaincodeCmd] ClientWait -&gt; INFO 001 txid [837c1b5e18ca5e8e2f2a0ec9f98bbdfcf74585e8c2c2e77047e3d11b44ad9344] committed with status (VALID) at peer0.org1.example.com:70512020-08-08 08:56:13.782 UTC [chaincodeCmd] ClientWait -&gt; INFO 002 txid [837c1b5e18ca5e8e2f2a0ec9f98bbdfcf74585e8c2c2e77047e3d11b44ad9344] committed with status (VALID) at peer0.org2.example.com:9051</code></pre><p>查询是否提交成功：</p><pre><code>peer lifecycle chaincode querycommitted -o orderer.example.com:7050 --channelID mychannel --name stupid --tls --cafile $ORDERER_CA</code></pre><p>结果如下，说明提交成功。</p><pre><code>Committed chaincode definition for chaincode &#39;stupid&#39; on channel &#39;mychannel&#39;:Version: 1.0, Sequence: 1, Endorsement Plugin: escc, Validation Plugin: vscc, Approvals: [Org1MSP: true, Org2MSP: true]</code></pre><p>也可以只指定通道名称，不指定链码名称，那样查询的就是该通道上所有链码的定义。</p><p> 注意commit需要指定签名背书策略，并且需要和链码 approveformyorg 阶段的背书策略一致。</p><pre><code> --signature-policy &quot;AND (&#39;Org1MSP.peer&#39;,&#39;Org2MSP.peer&#39;)&quot;</code></pre><p> 如果少了这个会报如下错误：</p><pre><code> Error: proposal failed with status: 500 - failed to invoke backing implementation of &#39;CommitChaincodeDefinition&#39;: chaincode definition not agreed to by this org (Org1MSP)</code></pre><p>查询链码和调用链码与 1.4 版本相同。</p><h1 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h1><pre><code>peer chaincode invoke -o orderer.example.com:7050 --tls true --cafile $ORDERER_CA -C mychannel -n stupid  -c &#39;{&quot;Args&quot;:[&quot;put&quot;,&quot;a&quot;,&quot;10&quot;]}&#39;</code></pre><p>结果如下：</p><pre><code>Error: endorsement failure during invoke. response: status:500 message:&quot;error in simulation: failed to execute transaction a1465e679dcd1559a7077ec13c45c4db72f8bd73b6aaa4af9fc1127797e96bb1: invalid invocation: chaincode &#39;stupid&#39; has not been initialized for this version, must call as init first&quot;</code></pre><p>说明这里需要执行的第一个函数是init，然后才能执行其他调用链码的操作，这里我们试图执行以下操作进行init：</p><pre><code>peer chaincode instantiate -o orderer.example.com:7050 --tls true --cafile $ORDERER_CA -C mychannel -n stupid -v 1.0 -c &#39;{&quot;Args&quot;:[&quot;init&quot;]}&#39;</code></pre><p>结果如下：</p><pre><code>2020-08-08 09:42:42.029 UTC [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 001 Using default escc2020-08-08 09:42:42.031 UTC [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 002 Using default vsccError: could not assemble transaction, err proposal response was not successful, error code 500, msg Channel &#39;mychannel&#39; has been migrated to the new lifecycle, LSCC is now read-only</code></pre><p>失败了，当前通道已经迁移到 lifecycle 了， 不能执行实例化操作。</p><p>此处需要增加 –isInit 参数，表面此处是初始化链码：</p><pre><code>peer chaincode invoke --isInit -o orderer.example.com:7050 --tls true --cafile $ORDERER_CA -C mychannel -n stupid  -c &#39;{&quot;Args&quot;:[&quot;put&quot;,&quot;a&quot;,&quot;10&quot;]}&#39;</code></pre><p>调用成功：</p><pre><code>2020-08-08 09:58:20.911 UTC [chaincodeCmd] chaincodeInvokeOrQuery -&gt; INFO 001 Chaincode invoke successful. result: status:200</code></pre><h1 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h1><pre><code>peer chaincode invoke -o orderer.example.com:7050 --tls ture --cafile $ORDERER_CA -C mychannel -n stupid  -c &#39;{&quot;Args&quot;:[&quot;get&quot;,&quot;a&quot;]}&#39;</code></pre><p>结果如下：</p><pre><code>2020-08-08 10:00:22.583 UTC [chaincodeCmd] chaincodeInvokeOrQuery -&gt; INFO 001 Chaincode invoke successful. result: status:200</code></pre><h1 id="踩坑指南"><a href="#踩坑指南" class="headerlink" title="踩坑指南"></a>踩坑指南</h1><p>在打包链码的时候遇到问题</p><pre><code>Error: error getting chaincode deployment spec for stupid: error getting chaincode package bytes: failed to calculate dependencies: incomplete package: github.com/hyperledger/fabric/core/chaincode/shim</code></pre><p>解决办法参考<br><a href="https://www.bcskill.com/index.php/archives/925.html" target="_blank" rel="noopener">https://www.bcskill.com/index.php/archives/925.html</a></p><ol><li><p>先下载依赖</p><pre><code> git clone github.com/hyperledger/fabric-chaincode-go/shim git clone github.com/hyperledger/fabric-protos-go/peer</code></pre></li><li><p>修改import包，将</p><pre><code> &quot;github.com/hyperledger/fabric/core/chaincode/shim&quot; pb &quot;github.com/hyperledger/fabric/protos/peer&quot;</code></pre><p> 改成</p><pre><code> &quot;github.com/hyperledger/fabric-chaincode-go/shim&quot; pb &quot;github.com/hyperledger/fabric-protos-go/peer&quot;</code></pre></li><li><p>并在链码文件的同级目录新建go.mod</p></li><li><p>更新依赖</p><pre><code> go mod vendor</code></pre></li><li><p>重启节点，执行打包链码的命令</p></li></ol><p>参考资料</p><p><a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/commands/peerlifecycle.html#example-usage" target="_blank" rel="noopener">Example Usage</a></p><p><a href="https://juejin.im/post/6844904070390480910" target="_blank" rel="noopener">Fabric2.0智能合约实践-设置背书策略</a></p><p><a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/chaincode_lifecycle.html#fabric-chaincode-lifecycle" target="_blank" rel="noopener">Fabric chaincode lifecycle</a></p>]]></content>
      
      
      <categories>
          
          <category> fabric </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fabric </tag>
            
            <tag> chaincode </tag>
            
            <tag> 2.2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fabric 2.2 的新特性</title>
      <link href="/2020/08/08/fabric-newfeature-2-2/"/>
      <url>/2020/08/08/fabric-newfeature-2-2/</url>
      
        <content type="html"><![CDATA[<h1 id="2-2-的新特性"><a href="#2-2-的新特性" class="headerlink" title="2.2 的新特性"></a>2.2 的新特性</h1><h2 id="1-分权的chaincode⽣命周期的管理"><a href="#1-分权的chaincode⽣命周期的管理" class="headerlink" title="1. 分权的chaincode⽣命周期的管理"></a>1. 分权的chaincode⽣命周期的管理</h2><p>详⻅ 2.0 beta版的chaincode⽣命周期管理</p><ul><li>多数组织需要同意chaincode的相关参数，⽐⽅说policy等。 </li><li>更慎重的chaincode升级过程（需要组织重新同意chaincode的相关参数）。 </li><li>更简便地升级policy或者私密数据配置（不⽤重新安装合约，可以直接从让多家组织同意新的参数开始，也就是升级参数的 话，chaincode的version可以不变） </li><li>可检查的chaincode包（需要先打包chaincode，再安装） </li><li>不同成员的同⼀个chaincode的源码可以不同（可以使⽤不同的语⾔编写，或者同⼀语⾔逻辑不同） </li></ul><h2 id="2-新的chaincode部署形式"><a href="#2-新的chaincode部署形式" class="headerlink" title="2. 新的chaincode部署形式"></a>2. 新的chaincode部署形式</h2><ul><li>删除对docker daemon的依赖。</li><li>增加了除了docker容器外的其他运⾏chaincode的选择。</li><li>提供了外部创建chaincode的接⼝，可以⾃⼰实现其他的chaincode的创建和部署过程。 </li><li>chaincode可以作为⼀个外部服务</li></ul><h2 id="3-私密数据的增强"><a href="#3-私密数据的增强" class="headerlink" title="3. 私密数据的增强"></a>3. 私密数据的增强</h2><p>详⻅2.0beta版私密数据新特性</p><ul><li>分享和验证私密数据。拥有私密数据的⼀⽅可以将私密数据分享给没有权限的⼀⽅，接收⽅可以通过调⽤GetPrivateDataHash<br>来验证私密数据的正确性。</li><li>新增collection级别的背书策略。</li><li>隐形的组织级别的collection。如果是单组织使⽤的私密数据，collection可以不⽤显性地去定义就可以直接使⽤。</li></ul><h2 id="4-CouchDB增加缓存来提升性能"><a href="#4-CouchDB增加缓存来提升性能" class="headerlink" title="4. CouchDB增加缓存来提升性能"></a>4. CouchDB增加缓存来提升性能</h2><h2 id="5-更轻量级的docker镜像"><a href="#5-更轻量级的docker镜像" class="headerlink" title="5. 更轻量级的docker镜像"></a>5. 更轻量级的docker镜像</h2><p>改⽤Apline Linux作为底层的操作系统。镜像⼤⼩变⼩了。</p><h2 id="其他变化"><a href="#其他变化" class="headerlink" title="其他变化"></a>其他变化</h2><ul><li>ccenv镜像不再包含shim</li><li>logger从chaincode shim中移除，chaincode的log⼯作交给chaincode开发者⾃⼰处理 </li><li>不再⽀持⽤户的chaincode调⽤系统chaincode </li><li>GetHistoryForKey排序⽅式更改为从新到旧 </li><li>对于orderer来说，之前⽀持的provisional启动⽅式被移除 </li><li>orderer配置的genesismethod和genesisfile改为bootstrapmethod和bootstrapfile</li><li>系统chaincode插件被移除，不可以通过go插件来添加系统chaincode了</li><li>新镜像⾥不⽀持bash</li><li>go版本升级到了1.13.4<font color="green"></font></li><li>添加了背书失败的背书节点的 metrics</li><li>可以在 core.yaml 中通过配置项对背书节点的并发请求数作出限制</li><li>可以在 core.yaml 中通过配置项覆盖私有数据集合分发策略</li><li>服务发现支持在链码私有数据集合级别指定背书策略</li><li>Discover CLI现在支持SEC 1格式的私钥</li><li>依赖更新<ul><li>docker镜像更新到 3.11</li><li>go 版本更新到 1.14.1</li><li>go grpc 更新到 1.28.0</li></ul></li><li>添加对 TLS 1.3 的支持</li><li>添加查询已批准的链码定义的详细信息的功能</li></ul><p><strong>注：标记为绿色的部分为 2.1.0 和 2.2.0 新增的特性，2.0.1 和 2.1.1 版本都是一些 bugfix，没有新的特性。</strong></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/whatsnew.html" target="_blank" rel="noopener">What’s new in Hyperledger Fabric v2.x</a></p>]]></content>
      
      
      <categories>
          
          <category> fabric </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fabric </tag>
            
            <tag> 2.2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fabric 1.4 升级到 2.2 的⽅案</title>
      <link href="/2020/08/08/fabric-upgrade-2-2/"/>
      <url>/2020/08/08/fabric-upgrade-2-2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>v2.2是Fabric v2.x的第一个长期支持（LTS）版本，Fabric的2.1和2.2版本是稳定版本，具有错误修复和其他形式的代码强化功能。从2.0升级到2.2不需要特别的考虑，也不需要特定的镜像版本或通道配置更新。</p></blockquote><h1 id="1-4-升级到-2-2-的主要过程包括（与升级到-2-0-基本一致）"><a href="#1-4-升级到-2-2-的主要过程包括（与升级到-2-0-基本一致）" class="headerlink" title="1.4 升级到 2.2 的主要过程包括（与升级到 2.0 基本一致）"></a>1.4 升级到 2.2 的主要过程包括（与升级到 2.0 基本一致）</h1><ol><li>升级镜像</li><li>升级兼容性配置</li><li>激活 chaincode 的新的⽣命周期管理 </li></ol><h1 id="1-升级镜像"><a href="#1-升级镜像" class="headerlink" title="1. 升级镜像"></a>1. 升级镜像</h1><p>升级镜像主要包括两个步骤： </p><ul><li>备份账本和 MSP 的相关⽂件</li><li>升级镜像⽂件到最新版本 </li></ul><h2 id="1-1-升级-orderer-节点"><a href="#1-1-升级-orderer-节点" class="headerlink" title="1.1 升级 orderer 节点"></a>1.1 升级 orderer 节点</h2><p>对每个 orderer 节点执行以下操作：</p><ol><li>停掉 orderer 节点 </li><li>备份 orderer 节点的账本和 MSP </li><li>移除掉 orderer 节点容器 </li><li>使⽤新镜像创建⼀个 orderer 容器</li></ol><h2 id="1-2-升级-peer-节点"><a href="#1-2-升级-peer-节点" class="headerlink" title="1.2 升级 peer 节点"></a>1.2 升级 peer 节点</h2><ol><li><p>停掉 peer 节点 </p></li><li><p>备份 peer 节点的账本和 MSP </p></li><li><p>移除掉 chaincode 容器（由于 2.0 版本中将 shim 从 fabric ⼯程中移出为单独的⼯程，所以是否删除镜像需要进⾏讨论） </p><ul><li>如果该 chaincode 已经做好了升级准备，那么原来的镜像可以直接删除掉。 </li><li>如果 chaincode 不打算升级，当环境从 1.4 升级到 2.0 后还需要继续使⽤。  <ul><li>不删除chaincode 镜像，那么当升级到2.0后会继续使⽤该镜像创建容器，原 chaincode 可以正常运⾏。</li><li>删除掉了 chaincode 镜像，那么需要对 peer 节点进⾏配置，让其使⽤ ccenv 1.4 版本的镜像来创建chaincode镜像。如 果没有专⻔配置，使⽤了 2.0 版本的 ccenv 的话，会出现错误。（ 因为 2.0 版本 ccenv ⾥没有 shim ），在 base/peer-base.yaml 增加如下内容：<pre><code> - CORE_CHAINCODE_BUILDER=hyperledger/fabric-ccenv:1.4.6</code></pre></li></ul></li></ul></li><li><p>移除掉 peer 节点容器</p></li><li><p>升级 peer 节点的数据库 </p><ul><li>由于 2.0 版本的状态数据库和历史数据库的数据格式与 1.4 有所不同，升级到2.0版本需要对数据库进⾏升级。<pre><code>docker run --rm -v /var/lib/docker/volumes/net_peer0.org1.example.com/_data/:/var/hyperledger/production/ -v /home/centos/gopath/src/github.com/hyperledger/fabric-samples/first-network/crypto-config/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/msp/:/etc/hyperledger/fabric/msp/ --name peer0.org1.example.com hyperledger/fabric-peer:2.0 peer node upgrade-dbs </code></pre></li></ul></li><li><p>使⽤新的镜像创建⼀个 peer 容器</p></li></ol><h3 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h3><ul><li>可以先 ./byfn.sh 起一个 byfn，然后停掉所有 orderer 节点和 peer 节点</li></ul><pre><code>docker-compose -f docker-compose-cli.yaml down</code></pre><ul><li>修改配置文件 base/peer-base.yaml 和 docker-compose-cli.yaml 中的镜像tag</li></ul><pre><code>image: hyperledger/fabric-peer:2.2image: hyperledger/fabric-orderer:2.2image: hyperledger/fabric-tools:2.2</code></pre><ul><li>升级所有 peer 节点的数据库（不升级会报错）</li></ul><pre><code>docker run --rm -v /var/lib/docker/volumes/net_peer0.org1.example.com/_data/:/var/hyperledger/production/ -v /Users/xiongweigang/go/src/github.com/hyperledger/fabric-samples/first-network/crypto-config/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/msp/:/etc/hyperledger/fabric/msp/ --name peer0.org1.example.com hyperledger/fabric-peer:2.2 peer node upgrade-dbsdocker run --rm -v /var/lib/docker/volumes/net_peer1.org1.example.com/_data/:/var/hyperledger/production/ -v /Users/xiongweigang/go/src/github.com/hyperledger/fabric-samples/first-network/crypto-config/peerOrganizations/org1.example.com/peers/peer1.org1.example.com/msp/:/etc/hyperledger/fabric/msp/ --name peer1.org1.example.com hyperledger/fabric-peer:2.2 peer node upgrade-dbsdocker run --rm -v /var/lib/docker/volumes/net_peer0.org2.example.com/_data/:/var/hyperledger/production/ -v /Users/xiongweigang/go/src/github.com/hyperledger/fabric-samples/first-network/crypto-config/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/msp/:/etc/hyperledger/fabric/msp/ --name peer0.org2.example.com hyperledger/fabric-peer:2.2 peer node upgrade-dbsdocker run --rm -v /var/lib/docker/volumes/net_peer1.org2.example.com/_data/:/var/hyperledger/production/ -v /Users/xiongweigang/go/src/github.com/hyperledger/fabric-samples/first-network/crypto-config/peerOrganizations/org2.example.com/peers/peer1.org2.example.com/msp/:/etc/hyperledger/fabric/msp/ --name peer1.org2.example.com hyperledger/fabric-peer:2.2 peer node upgrade-dbs</code></pre><p>最后再重启节点</p><pre><code>docker-compose -f docker-compose-cli.yaml up -d</code></pre><h1 id="2-升级兼容性配置"><a href="#2-升级兼容性配置" class="headerlink" title="2. 升级兼容性配置"></a>2. 升级兼容性配置</h1><p>升级兼容性配置主要包括，升级系统链配置以及升级应⽤链配置两个⽅⾯。 </p><p>在升级过程中可以使⽤ jq 命令来对配置进⾏修改，也可以使⽤其他编辑器对⽂件直接进⾏⼿动的修改。为了⽅便 jq 命令的使 ⽤，⾸先创建⼀个名为capabilities.json的⽂件。⽂件包括以下内容:</p><pre><code>{     &quot;channel&quot;: {         &quot;mod_policy&quot;: &quot;Admins&quot;,             &quot;value&quot;: {                 &quot;capabilities&quot;: {                    &quot;V2_0&quot;: {}                  }            },         &quot;version&quot;: &quot;0&quot;     },    &quot;orderer&quot;: {         &quot;mod_policy&quot;: &quot;Admins&quot;,             &quot;value&quot;: {                 &quot;capabilities&quot;: {                     &quot;V2_0&quot;: {}                 }             },         &quot;version&quot;: &quot;0&quot;     },    &quot;application&quot;: {         &quot;mod_policy&quot;: &quot;Admins&quot;,             &quot;value&quot;: {                 &quot;capabilities&quot;: {                    &quot;V2_0&quot;: {}                 }             },         &quot;version&quot;: &quot;0&quot;     } } </code></pre><h3 id="具体操作-1"><a href="#具体操作-1" class="headerlink" title="具体操作"></a>具体操作</h3><p>进入 cli 容器</p><pre><code>docker exec -it cli bash </code></pre><p>进入 script 文件夹</p><pre><code>cd scripts</code></pre><p>将 capabilities.json 复制到 此文件夹中即 fabric-samples/firstnetwork/scripts 文件夹</p><h2 id="2-1-升级系统链的兼容性配置"><a href="#2-1-升级系统链的兼容性配置" class="headerlink" title="2.1 升级系统链的兼容性配置"></a>2.1 升级系统链的兼容性配置</h2><p>参考脚本updating_capabilities_sys.sh</p><ul><li>⾸先需要对⼀些环境变量进⾏设置<ul><li>CH_NAME :系统链的名称，例如⽬前的 fabric-samples/first-network中的 CH_NAME=byfn-sys-channel </li><li>CORE_PEER_LOCALMSPID :Orderer组织的MSPID，例如⽬前的 fabric-samples/first-network 中的 CORE_PEER_LOCALMSPID=OrdererMSP</li><li>TLS_ROOT_CA : Orderer组织的TLS的CA证书，例如⽬前的 fabric-samples/first-network 中的 TLS_ROOT_CA=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/ orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem </li><li>CORE_PEER_MSPCONFIGPATH :Orderer组织的MSP的配置地址，例如⽬前的fabric-samples/first-network 中的 CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/users/Admin@example.com/msp </li><li>ORDERER_CONTAINER :Orderer组织的容器节点，例如⽬前的fabric-samples/first-network中的 ORDERER_CONTAINER=orderer.example.com:7050</li></ul></li><li>获取系统链原有的配置 <ul><li>获取原有配置<pre><code>peer channel fetch config config_block.pb -o $ORDERER_CONTAINER -c $CH_NAME --tls --cafile $TLS_ROOT_CA</code></pre></li><li>将配置转化为json格式 <pre><code>configtxlator proto_decode --input config_block.pb --type common.Block --output config_block.json</code></pre></li><li>从json中只提取出来配置的部分<pre><code>jq .data.data[0].payload.data.config config_block.json &gt; config.json</code></pre></li></ul></li><li>修改兼容性配置<ul><li>可以使⽤ jq 命令对配置进⾏修改<pre><code>jq -s &#39;.[0] * {&quot;channel_group&quot;:{&quot;groups&quot;:{&quot;Orderer&quot;: {&quot;values&quot;: {&quot;Capabilities&quot;: .[1].orderer}}}}}&#39; config.json ./capabilities.json &gt; modified_config1.jsonjq -s &#39;.[0] * {&quot;channel_group&quot;:{&quot;values&quot;: {&quot;Capabilities&quot;: .[1].channel}}}&#39; modified_config1.json ./capabilities.json &gt; modified_config.json</code></pre></li><li>也可以打开编辑器，将Capabilities相关的配置改为”V2_0”</li></ul></li><li>计算配置的deltaSet，⽣成pb⽂件<ul><li>计算deltaSet<pre><code>configtxlator proto_encode --input config.json --type common.Config --output config.pbconfigtxlator proto_encode --input modified_config.json --type common.Config --output modified_config.pb configtxlator compute_update --channel_id $CH_NAME --original config.pb --updated modified_config.pb --output config_update.pb</code></pre></li><li>⽣成通道更新的pb⽂件<pre><code>configtxlator proto_decode --input config_update.pb --type common.ConfigUpdate --output config_update.jsonecho &#39;{&quot;payload&quot;:{&quot;header&quot;:{&quot;channel_header&quot;:{&quot;channel_id&quot;:&quot;&#39;$CH_NAME&#39;&quot;, &quot;type&quot;:2}},&quot;data&quot;:{&quot;config_update&quot;:&#39;$(cat config_update.json)&#39;}}}&#39; | jq . &gt; config_update_in_envelope.jsonconfigtxlator proto_encode --input config_update_in_envelope.json --type common.Envelope --output config_update_in_envelope.pb</code></pre></li></ul></li><li>提交更新到通道<ul><li>这⾥假设orderer只有⼀家组织，如果有多家则需要每⼀家先对 config_update_in_envelope.pb 进⾏ signconfigtx 操作 <pre><code>peer channel update -f config_update_in_envelope.pb -c $CH_NAME -o $ORDERER_CONTAINER --tls true --cafile $TLS_ROOT_CA</code></pre><h3 id="具体操作-2"><a href="#具体操作-2" class="headerlink" title="具体操作"></a>具体操作</h3></li></ul></li></ul><p>进入 cli 容器</p><pre><code>docker exec -it cli bash </code></pre><p>进入 script 文件夹</p><pre><code>cd scripts</code></pre><p>将脚本 capabilities.json 复制到 此文件夹中即 fabric-sanples/firstnetwork/scripts 文件夹</p><p>然后给该脚本添加可执行权限并执行</p><pre><code>chmod +x updating_capabilities_sys.sh./updating_capabilities_sys.sh</code></pre><h2 id="2-2-升级已有应⽤链的系统配置"><a href="#2-2-升级已有应⽤链的系统配置" class="headerlink" title="2.2 升级已有应⽤链的系统配置"></a>2.2 升级已有应⽤链的系统配置</h2><p>参考脚本 updating_capabilities_mychannel.sh</p><ul><li><p>对环境变量进⾏配置，这⾥以 fabric-samples/first-network中的mychannel为例，mychannel 中包含了 Org1 和 Org2 两个组织</p><pre><code>CH_NAME=mychannelCORE_PEER_LOCALMSPID=Org1MSP TLS_ROOT_CA=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pemCORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp ORDERER_CONTAINER=orderer.example.com:7050 </code></pre></li><li><p>获取mychannel的原有配置</p><ul><li>获取原有配置<pre><code>peer channel fetch config config_block.pb -o $ORDERER_CONTAINER -c $CH_NAME --tls --cafile $TLS_ROOT_CA</code></pre></li><li>将配置转化为json格式<pre><code>configtxlator proto_decode --input config_block.pb --type common.Block --output config_block.json</code></pre></li><li>从json中只提取出来配置的部分 jq<pre><code>.data.data[0].payload.data.config config_block.json &gt; config.json</code></pre></li></ul></li><li><p>修改兼容性配置注意应⽤通道⽐系统通道多了⼀个Application的兼容性需要修改</p><pre><code>  jq -s &#39;.[0] * {&quot;channel_group&quot;:{&quot;groups&quot;:{&quot;Orderer&quot;: {&quot;values&quot;: {&quot;Capabilities&quot;: .[1].orderer}}}}}&#39; config.json ./capabilities.json &gt; modified_config1.json  jq -s &#39;.[0] * {&quot;channel_group&quot;:{&quot;values&quot;: {&quot;Capabilities&quot;: .[1].channel}}}&#39; modified_config1.json ./capabilities.json &gt; modified_config2.json  jq -s &#39;.[0] * {&quot;channel_group&quot;:{&quot;groups&quot;:{&quot;Application&quot;: {&quot;values&quot;: {&quot;Capabilities&quot;: .[1].application}}}}}&#39; modified_config2.json ./capabilities.json &gt; modified_config.json</code></pre></li><li><p>计算配置的deltaSet，⽣成pb⽂件</p><ul><li>计算deltaSet<pre><code>configtxlator proto_encode --input config.json --type common.Config --output config.pbconfigtxlator proto_encode --input modified_config.json --type common.Config --output modified_config.pbconfigtxlator compute_update --channel_id $CH_NAME --original config.pb --updated modified_config.pb --output config_update.pb</code></pre></li></ul></li><li><p>⽣成通道更新的pb⽂件</p><pre><code>  configtxlator proto_decode --input config_update.pb --type common.ConfigUpdate --output config_update.json   echo &#39;{&quot;payload&quot;:{&quot;header&quot;:{&quot;channel_header&quot;:{&quot;channel_id&quot;:&quot;&#39;$CH_NAME&#39;&quot;, &quot;type&quot;:2}},&quot;data&quot;:{&quot;config_update&quot;:&#39;$(cat config_update.json)&#39;}}}&#39; | jq . &gt; config_update_in_envelope.json   configtxlator proto_encode --input config_update_in_envelope.json --type common.Envelope --output config_update_in_envelope.pb</code></pre></li><li><p>提交更新到通道<br>  因为mychannel中有Org1和Org2两个组织（实际上还有Orderer的配置），对通道配置进⾏修改需要通道多数<br>  组织的签名，以及对Orderer配置修改需要Orderer组织的签名。 所以这⾥假设，先让Org1和Org2进⾏签名，再由Orderer进更新的提交。</p><ul><li>Org1签名<pre><code>peer channel signconfigtx -f config_update_in_envelope.pb</code></pre></li><li>切换为Org2<pre><code>CORE_PEER_LOCALMSPID=Org2MSPCORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp</code></pre></li><li>Org2签名<pre><code>peer channel signconfigtx -f config_update_in_envelope.pb</code></pre></li><li>切换为Orderer的组织<pre><code>CORE_PEER_LOCALMSPID=OrdererMSPCORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/users/Admin@example.com/msp</code></pre></li><li>Orderer组织提交变更<pre><code>peer channel update -f config_update_in_envelope.pb -c $CH_NAME -o $ORDERER_CONTAINER --tls true --cafile $TLS_ROOT_CA </code></pre></li></ul></li></ul><h3 id="具体操作-3"><a href="#具体操作-3" class="headerlink" title="具体操作"></a>具体操作</h3><p>进入 cli 容器</p><pre><code>docker exec -it cli bash </code></pre><p>进入 script 文件夹</p><pre><code>cd scripts</code></pre><p>将脚本 updating_capabilities_sys.sh 复制到 此文件夹中，即 fabric-sanples/firstnetwork/scripts 文件夹</p><p>然后给该脚本添加可执行权限并执行</p><pre><code>chmod +x updating_capabilities_sys.sh./updating_capabilities_sys.sh</code></pre><h1 id="3-激活chaincode的新的⽣命周期管理"><a href="#3-激活chaincode的新的⽣命周期管理" class="headerlink" title="3. 激活chaincode的新的⽣命周期管理"></a>3. 激活chaincode的新的⽣命周期管理</h1><p>只更改兼容性，通道若要使⽤chaincode的新的⽣命周期管理⽅案会出现错误，这是因为原有1.4的通道配置中，缺少通道<br>Endorsement和LifecycleEndorsement的配置。 为了⽅便使⽤ jq 命令来添加这两部分内容，⾸先准备包含以下内容的 enable_lifecycle.json⽂件，注意这⾥假设了通道内有两家组织，分别为Org1和Org2，他们的MSPID分别为Org1MSP,Org2MSP。 请根据需要进⾏修改。</p><pre><code>{     &quot;Org1MSPPolicies&quot;: {         &quot;Endorsement&quot;: {             &quot;mod_policy&quot;: &quot;Admins&quot;,             &quot;policy&quot;: {                 &quot;type&quot;: 1,                 &quot;value&quot;: {                 &quot;identities&quot;: [                     {                         &quot;principal&quot;: {                             &quot;msp_identifier&quot;: &quot;Org1MSP&quot;,                             &quot;role&quot;: &quot;PEER&quot;                         },                        &quot;principal_classification&quot;: &quot;ROLE&quot;                     }                 ],                &quot;rule&quot;: {                     &quot;n_out_of&quot;: {                         &quot;n&quot;: 1,                         &quot;rules&quot;: [                             {                              &quot;signed_by&quot;: 0                             }                        ]                     }                 },                &quot;version&quot;: 0             }         },        &quot;version&quot;: &quot;0&quot;         }     },     &quot;Org2MSPPolicies&quot;: {         &quot;Endorsement&quot;: {             &quot;mod_policy&quot;: &quot;Admins&quot;,             &quot;policy&quot;: {                 &quot;type&quot;: 1,                 &quot;value&quot;: {                 &quot;identities&quot;: [                 {                     &quot;principal&quot;: {                         &quot;msp_identifier&quot;: &quot;Org2MSP&quot;,                         &quot;role&quot;: &quot;PEER&quot;                 },                &quot;principal_classification&quot;: &quot;ROLE&quot;                }             ],            &quot;rule&quot;: {                 &quot;n_out_of&quot;: {                     &quot;n&quot;: 1,                     &quot;rules&quot;: [                     {                         &quot;signed_by&quot;: 0                     }                    ]                 }             },            &quot;version&quot;: 0             }         },        &quot;version&quot;: &quot;0&quot;      }     },    &quot;appPolicies&quot;: {         &quot;Endorsement&quot;: {             &quot;mod_policy&quot;: &quot;Admins&quot;,             &quot;policy&quot;: {                 &quot;type&quot;: 3,                 &quot;value&quot;: {                     &quot;rule&quot;: &quot;MAJORITY&quot;,                     &quot;sub_policy&quot;: &quot;Endorsement&quot;                 }             },            &quot;version&quot;: &quot;0&quot;         },        &quot;LifecycleEndorsement&quot;: {             &quot;mod_policy&quot;: &quot;Admins&quot;,             &quot;policy&quot;: {                 &quot;type&quot;: 3,                 &quot;value&quot;: {                     &quot;rule&quot;: &quot;MAJORITY&quot;,                     &quot;sub_policy&quot;: &quot;Endorsement&quot;                 }             },            &quot;version&quot;: &quot;0&quot;         }     } } </code></pre><h2 id="3-1-更改系统链配置"><a href="#3-1-更改系统链配置" class="headerlink" title="3.1 更改系统链配置"></a>3.1 更改系统链配置</h2><p>参考脚本enable_cc_lifecycle_sys.sh</p><ul><li><p>对环境变量进⾏配置</p><pre><code>CH_NAME=byfn-sys-channelCORE_PEER_LOCALMSPID=OrdererMSPTLS_ROOT_CA=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pemCORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/users/Admin@example.com/mspORDERER_CONTAINER=orderer.example.com:7050ORGNAME=Org1MSPCONSORTIUM_NAME=SampleConsortium</code></pre></li><li><p>获取原有的配置</p><pre><code>peer channel fetch config config_block.pb -o $ORDERER_CONTAINER -c $CH_NAME --tls --cafile $TLS_ROOT_CAconfigtxlator proto_decode --input config_block.pb --type common.Block --output config_block.jsonjq .data.data[0].payload.data.config config_block.json &gt; config.json</code></pre></li><li><p>修改相应配置</p><ul><li>修改Org1的配置，增加Org1的Endorsement的配置 <pre><code>jq -s &quot;.[0] * {\&quot;channel_group\&quot;:{\&quot;groups\&quot;:{\&quot;Consortiums\&quot;:{\&quot;groups\&quot;: {\&quot;$CONSORTIUM_NAME\&quot;: {\&quot;groups\&quot;: {\&quot;$ORGNAME\&quot;: {\&quot;policies\&quot;: .[1].${ORGNAME}Policies}}}}}}}}&quot; config.json ./enable_lifecycle.json &gt; modified_config1.json</code></pre></li><li>修改Org2的配置，增加Org2的Endorsement的配置<pre><code>ORGNAME=Org2MSPjq -s &quot;.[0] * jq -s &quot;.[0] * {\&quot;channel_group\&quot;:{\&quot;groups\&quot;:{\&quot;Consortiums\&quot;:{\&quot;groups\&quot;: {\&quot;$CONSORTIUM_NAME\&quot;: {\&quot;groups\&quot;: {\&quot;$ORGNAME\&quot;: {\&quot;policies\&quot;: .[1].${ORGNAME}Policies}}}}}}}}&quot; modified_config1.json ./enable_lifecycle.json &gt; modified_config.json</code></pre></li></ul></li><li><p>计算配置的deltaSet，⽣成pb⽂件</p><ul><li>计算deltaSet<pre><code>configtxlator proto_encode --input config.json --type common.Config --output config.pbconfigtxlator proto_encode --input modified_config.json --type common.Config --output modified_config.pbconfigtxlator compute_update --channel_id $CH_NAME --original config.pb --updated modified_config.pb --output config_update.pb</code></pre></li><li>⽣成通道更新的pb⽂件<pre><code>configtxlator proto_decode --input config_update.pb --type common.ConfigUpdate --output config_update.jsonecho &#39;{&quot;payload&quot;:{&quot;header&quot;:{&quot;channel_header&quot;:{&quot;channel_id&quot;:&quot;&#39;$CH_NAME&#39;&quot;, &quot;type&quot;:2}},&quot;data&quot;:{&quot;config_update&quot;:&#39;$(cat config_update.json)&#39;}}}&#39; | jq . &gt; config_update_in_envelope.jsonconfigtxlator proto_encode --input config_update_in_envelope.json --type common.Envelope --output config_update_in_envelope.pb</code></pre></li></ul></li><li><p>提交更新到通道<br>  因为Consortium中有Org1和Org2两个组织，对每个组织的内容修改都需要该组织的Admin的签名，然后对系 统通道配置进⾏修改需要Orderer组织的Admin签名。 </p><ul><li>Orderer签名<pre><code>peer channel signconfigtx -f config_update_in_envelope.pb </code></pre></li><li>切换为Org1，org1 签名<pre><code>CORE_PEER_LOCALMSPID=Org1MSPCORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msppeer channel signconfigtx -f config_update_in_envelope.pb</code></pre></li><li>切换为Org2 ，org2 签名<pre><code>CORE_PEER_LOCALMSPID=Org2MSPCORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msppeer channel signconfigtx -f config_update_in_envelope.pb</code></pre></li><li>切换回Orderer<pre><code>CORE_PEER_LOCALMSPID=OrdererMSPCORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/users/Admin@example.com/msp</code></pre></li><li>提交更新<pre><code>peer channel update -f config_update_in_envelope.pb -c $CH_NAME -o $ORDERER_CONTAINER --tls true --cafile $TLS_ROOT_CA</code></pre><h2 id="3-2-更改已有的应⽤通道配置"><a href="#3-2-更改已有的应⽤通道配置" class="headerlink" title="3.2 更改已有的应⽤通道配置"></a>3.2 更改已有的应⽤通道配置</h2></li></ul></li></ul><p>以fabric-samples/first-network中的mychannel为例。 参考脚本enable_cc_lifecycle_mychannel.sh</p><ul><li>对环境变量进⾏配置<pre><code>CH_NAME=mychannelCORE_PEER_LOCALMSPID=Org1MSPTLS_ROOT_CA=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pemCORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/mspORDERER_CONTAINER=orderer.example.com:7050ORGNAME=Org1MSPCONSORTIUM_NAME=SampleConsortium</code></pre></li><li>获取原有的配置<pre><code>peer channel fetch config config_block.pb -o $ORDERER_CONTAINER -c $CH_NAME --tls --cafile $TLS_ROOT_CAconfigtxlator proto_decode --input config_block.pb --type common.Block --output config_block.jsonjq .data.data[0].payload.data.config config_block.json &gt; config.json </code></pre></li><li>修改相应配置注意需要⽐系统通道多修改Application的Endorsement和LifeCycleEndorsement<ul><li>修改Org1的配置，增加Org1的Endorsement的配置<pre><code>jq -s &quot;.[0] * {\&quot;channel_group\&quot;:{\&quot;groups\&quot;:{\&quot;Application\&quot;:{\&quot;groups\&quot;: {\&quot;$ORGNAME\&quot;: {\&quot;policies\&quot;: .[1].${ORGNAME}Policies}}}}}}&quot; config.json ./enable_lifecycle.json &gt; modified_config1.json</code></pre></li><li>切换为Org2<pre><code>ORGNAME=Org2MSP</code></pre></li><li>修改Org2的配置，增加Org2的Endorsement的配置<pre><code>jq -s &quot;.[0] * {\&quot;channel_group\&quot;:{\&quot;groups\&quot;:{\&quot;Application\&quot;:{\&quot;groups\&quot;: {\&quot;$ORGNAME\&quot;: {\&quot;policies\&quot;: .[1].${ORGNAME}Policies}}}}}}&quot; modified_config1.json ./enable_lifecycle.json &gt; modified_config2.json</code></pre></li><li>修改通道配置，增加Endorsement和LifeCycleEndorsement配置<pre><code>jq -s &#39;.[0] * {&quot;channel_group&quot;:{&quot;groups&quot;:{&quot;Application&quot;: {&quot;policies&quot;: .[1].appPolicies}}}}&#39; modified_config2.json ./enable_lifecycle.json &gt; modified_config.json</code></pre></li></ul></li><li>计算配置的deltaSet，⽣成pb⽂件<ul><li>计算deltaSet<pre><code>configtxlator proto_encode --input config.json --type common.Config --output config.pbconfigtxlator proto_encode --input modified_config.json --type common.Config --output modified_config.pbconfigtxlator compute_update --channel_id $CH_NAME --original config.pb --updated modified_config.pb --output config_update.pb</code></pre></li><li>⽣成通道更新的pb⽂件<pre><code>configtxlator proto_decode --input config_update.pb --type common.ConfigUpdate --output config_update.jsonecho &#39;{&quot;payload&quot;:{&quot;header&quot;:{&quot;channel_header&quot;:{&quot;channel_id&quot;:&quot;&#39;$CH_NAME&#39;&quot;, &quot;type&quot;:2}},&quot;data&quot;:{&quot;config_update&quot;:&#39;$(cat config_update.json)&#39;}}}&#39; | jq . &gt; config_update_in_envelope.jsonconfigtxlator proto_encode --input config_update_in_envelope.json --type common.Envelope --output config_update_in_envelope.pb</code></pre></li></ul></li><li>提交更新到通道 因为Consortium中有Org1和Org2两个组织，对每个组织的内容修改都需要该组织的Admin的签名。<ul><li>Org1签名<pre><code>peer channel signconfigtx -f config_update_in_envelope.pb</code></pre></li><li>切换为Org2 <pre><code>CORE_PEER_LOCALMSPID=Org2MSPCORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp</code></pre></li><li>Org2来提交通道变更<pre><code>peer channel update -f config_update_in_envelope.pb -c $CH_NAME -o $ORDERER_CONTAINER --tls true --cafile $TLS_ROOT_CA</code></pre></li></ul></li></ul><h1 id="4-⼀些验证过的特殊场景"><a href="#4-⼀些验证过的特殊场景" class="headerlink" title="4. ⼀些验证过的特殊场景"></a>4. ⼀些验证过的特殊场景</h1><h3 id="4-1-是否可以升级镜像但不升级兼容性"><a href="#4-1-是否可以升级镜像但不升级兼容性" class="headerlink" title="4.1 是否可以升级镜像但不升级兼容性"></a>4.1 是否可以升级镜像但不升级兼容性</h3><p>可以的，只升级镜像不升级兼容性的话，还是按照1.4的功能来运⾏</p><h3 id="4-2-是否可以只升级某些通道的兼容性"><a href="#4-2-是否可以只升级某些通道的兼容性" class="headerlink" title="4.2 是否可以只升级某些通道的兼容性"></a>4.2 是否可以只升级某些通道的兼容性</h3><p>可以的，不过建议先升级系统通道，这样之后新⽣成的通道就可以是最新的兼容性配置了。</p><h3 id="4-3-通道中原有的链码是否还可以正常使⽤"><a href="#4-3-通道中原有的链码是否还可以正常使⽤" class="headerlink" title="4.3 通道中原有的链码是否还可以正常使⽤"></a>4.3 通道中原有的链码是否还可以正常使⽤</h3><p>升级镜像后，原有的链码可以正常使⽤，但是需要注意链码镜像的问题，如果保留了原链码的镜像则⽆需关⼼该问题，没有保留的 话，需要将ccenv配置为1.4的镜像版本。通道兼容性的升级也不会影响已有链码的使⽤。</p><h3 id="4-4-升级之后原有链码也有升级需求应该怎么操作"><a href="#4-4-升级之后原有链码也有升级需求应该怎么操作" class="headerlink" title="4.4 升级之后原有链码也有升级需求应该怎么操作"></a>4.4 升级之后原有链码也有升级需求应该怎么操作</h3><p>升级了镜像以及兼容性后，如果原有链码也需要升级，则需要⾛2.0的lifecycle的升级流程，即需要package-install- approveformyorg-commit那⼀套流程。</p><blockquote><p>Fabric的2.1和2.2版本是稳定版本，具有错误修复和其他形式的代码强化功能。升级的时候不需要特别的考虑，也不需要特定的镜像版本或通道配置更新。</p></blockquote><p>#下面是升级到 2.2 新增的一些内容</p><h2 id="从2-0-升级到-2-1"><a href="#从2-0-升级到-2-1" class="headerlink" title="从2.0 升级到 2.1"></a>从2.0 升级到 2.1</h2><p>之前 1.4 升级到 2.0 时，升级peer数据库需要先删除 peer 的数据库，也就是执行 peer node upgrade-dbs 命令</p><pre><code>docker run --rm -v /opt/backup/$PEER_CONTAINER/:/var/hyperledger/production/ \            -v /opt/msp/:/etc/hyperledger/fabric/msp/ \            --env-file ./env&lt;name of node&gt;.list \            --name $PEER_CONTAINER \            hyperledger/fabric-peer:2.0 peer node upgrade-dbs</code></pre><p>然后执行 peer node start 命令重建 peer 数据库</p><pre><code>docker run -d -v /opt/backup/$PEER_CONTAINER/:/var/hyperledger/production/ \            -v /opt/msp/:/etc/hyperledger/fabric/msp/ \            --env-file ./env&lt;name of node&gt;.list \            --name $PEER_CONTAINER \            hyperledger/fabric-peer:2.0 peer node start</code></pre><p>如果在升级过程中未删除 peer 数据库，则启动 peer 时将返回一条错误信息，提示需要先删除数据库。</p><p>如果升级到 2.1 的话，在上面的命令中将 2.0 换成 2.1 就行</p><h2 id="从-2-1-升级到-2-2"><a href="#从-2-1-升级到-2-2" class="headerlink" title="从 2.1 升级到 2.2"></a>从 2.1 升级到 2.2</h2><p>如果升级到 2.2 的话，删除数据库的命令都省了，如果是使用CouchDB作为状态数据库，则从v2.2 开始， peer 支持自动删除该数据库。为了利用这种支持，在运行 upgrade-dbs 命令之前，需要将 peer 的状态数据库配置为 CouchDB，并启动 CouchDB。在v2.0和v2.1中，peer 不会自动删除CouchDB状态数据库。需要手动好删除。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/upgrade_to_newest_version.html" target="_blank" rel="noopener">Considerations for getting to v2.x</a></p>]]></content>
      
      
      <categories>
          
          <category> fabric </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fabric </tag>
            
            <tag> 2.2 </tag>
            
            <tag> upgrade </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fabric 1.4源码分析2：Orderer 核心数据结构</title>
      <link href="/2020/08/02/orderer-data-structure/"/>
      <url>/2020/08/02/orderer-data-structure/</url>
      
        <content type="html"><![CDATA[<blockquote><p>回顾上一节中我们讲述了一笔交易在 orderer 中的处理流程，进入引出了 orderer 源码分析的知识图谱。这次我们就从知识图谱的第一块内容说起，也就是 orderer 核心数据结构。</p></blockquote><p><strong>友情提示：在Fabric中，通道和链在概念上都是一条区块链，所以本文中也可能会混用链和通道的说法，请读者不要过于纠结于这两个概念。</strong></p><h1 id="Registrar"><a href="#Registrar" class="headerlink" title="Registrar"></a>Registrar</h1><p>Registrar 对象是一个多通道注册管理器，负责管理系统通道与所有应用通道，封装了所有通道的 ChainSupport 的 map、共识组件 map、ledgerFactory 对象等组件，维护所有通道上的通道配置、区块账本对象、共识组件等核心资源，创建通道上的共识组件链对象提供Orderer共识排序服务，负责对交易消息排序，切割打包构造新区块并提交账本，同时负责创建新的应用通道与更新通道配置。</p><p>一言蔽之，<br>Registrar 就相当于 Orderer节点上的 “资源管理器”，包含了所有通道 资源的访问和控制点，也就是说，我们如果需要对 orderer 节点的任何一个通道进行操作，都得先从这里入手。</p><blockquote><p>Registrar 对象定义在<br>fabric/orderer/common/multichannel/registrar.go 文件中，具体如下：</p></blockquote><pre><code>// Registrar serves as a point of access and control for the individual channel resources.type Registrar struct {    lock               sync.RWMutex    chains             map[string]*ChainSupport    config             localconfig.TopLevel    consenters         map[string]consensus.Consenter    ledgerFactory      blockledger.Factory    signer             crypto.LocalSigner    blockcutterMetrics *blockcutter.Metrics    systemChannelID    string    systemChannel      *ChainSupport    templator          msgprocessor.ChannelConfigTemplator    callbacks          []channelconfig.BundleActor}</code></pre><ul><li>lock 是一把锁，当需要对于通道资源进行读和写操作时，会对通道加锁，操作完再解锁。</li><li>chains 保存了所有的链，每一条链在 Orderer 中都以 一个 Key - Value 键值对表述，其中键就是 channelID，值就是一条链，这里用 ChainSupport表示，具体下文还会介绍。</li><li>config 保存了从 orderer.yaml 中读取的配置</li><li>consenters 保存了所有的共识插件，每个共识插件都是一个 Consenter，Fabric 1.4 中共识插件有 Solo、Kafka、EtcdRaft 三种。</li><li>ledgerFactory 用来读取和创建链的账本。</li><li>signer用来对Orderer中的数据进行签名，以及创建 <a href="https://lessisbetter.site/2019/11/10/how-fabric-verify-signatures/#%E8%A7%A3%E5%AF%86SignatureHeader" target="_blank" rel="noopener">SignatureHeader</a>。</li><li>blockcutterMetrics 是用于对切块进行一些指标的监测</li><li>systemChannelID 和 systemChannel分别是系统通道ID、系通道实例。</li><li>systemChannel </li><li>templator 用于生成一个通道配置模版</li><li>callbacks 用于对通道配置执行一些回调的操作</li></ul><h1 id="ChainSupport"><a href="#ChainSupport" class="headerlink" title="ChainSupport"></a>ChainSupport</h1><p>ChainSupport 封装了关联通道上的账本资源对象、消息处理器、区 块写组件、共识组件链对象等核心组件与模块，用于过滤验证消息、切割打包消息出块、 提交区块写入账本、创建通道与更新通道配置等流程。</p><p>一言蔽之，ChainSupport 汇集了一条通道所需要的所有资源，一个 ChainSupport 就代表了一条链。</p><blockquote><p>ChainSupport 对象定义在<br>fabric/orderer/common/multichannel/chainsupport.go 文件中，具体如下：</p></blockquote><pre><code>// ChainSupport holds the resources for a particular channel.type ChainSupport struct {    *ledgerResources    msgprocessor.Processor    *BlockWriter    consensus.Chain    cutter blockcutter.Receiver    crypto.LocalSigner}</code></pre><p>ChainSupport 是一堆接口的集合，这些接口构成一条链所有的操作，接口可以分为4类：</p><ul><li>账本：ledgerResources、BlockWriter分别是账本读写和把区块写入到账本。</li><li>消息：msgprocessor.Processor、cutter分别是处理交易和把交易切块。</li><li>共识：consensus.Chain是Orderer的共识实例，比如每条链都有自己的Raft共识实例，它们互不干扰。</li><li>签名：crypto.LocalSigner，同Registrar中的介绍。</li></ul><h1 id="Chain"><a href="#Chain" class="headerlink" title="Chain"></a>Chain</h1><p>Chain 接口的实现是一个共识插件的实例，它利用不同的共识算法（Solo、Kafka 和 Etcdraft）对交易排序并 添加到本地的缓存交易消息列表中，按出块规则切割成批量交易集合，再打包出块提交到账本，同时负责创建新通道与更新通道配置。</p><p>一言蔽之，Chain 接口包含了一个共识插件所要实现的基本方法，它主要负责对交易/消息进行排序并调用 HandleChain 方法进行切块和写入账本，体现了共识算法的可插拔性。</p><blockquote><p>Chain 接口定义在<br>fabric/orderer/consensus/consensus.go 文件中，具体如下：</p></blockquote><pre><code>// Chain defines a way to inject messages for ordering.// Note, that in order to allow flexibility in the implementation, it is the responsibility of the implementer// to take the ordered messages, send them through the blockcutter.Receiver supplied via HandleChain to cut blocks,// and ultimately write the ledger also supplied via HandleChain.  This design allows for two primary flows// 1. Messages are ordered into a stream, the stream is cut into blocks, the blocks are committed (solo, kafka)// 2. Messages are cut into blocks, the blocks are ordered, then the blocks are committed (sbft)Chain定义了一种注入消息的方式来进行排序。// 注意，为了在实现中实现灵活性，实现者负责获取有序消息，并通过 blockcutter 发送它们。接收器通过 HandleChain 来切割块，并写入账本也通过 HandleChain方法。// 这种设计允许两个主要流程：// 1. 消息被排序到一个流中，流被切成块，块被提交(solo, kafka)// 2. 消息被切成块，对块进行排序，然后提交块(sbft)type Chain interface {    // 普通消息/交易排序    // Order accepts a message which has been processed at a given configSeq.    // If the configSeq advances, it is the responsibility of the consenter    // to revalidate and potentially discard the message    // The consenter may return an error, indicating the message was not accepted    Order(env *cb.Envelope, configSeq uint64) error    // 配置消息/交易排序    // Configure accepts a message which reconfigures the channel and will    // trigger an update to the configSeq if committed.  The configuration must have    // been triggered by a ConfigUpdate message. If the config sequence advances,    // it is the responsibility of the consenter to recompute the resulting config,    // discarding the message if the reconfiguration is no longer valid.    // The consenter may return an error, indicating the message was not accepted    Configure(config *cb.Envelope, configSeq uint64) error    // 等待排序集群可用    // WaitReady blocks waiting for consenter to be ready for accepting new messages.    // This is useful when consenter needs to temporarily block ingress messages so    // that in-flight messages can be consumed. It could return error if consenter is    // in erroneous states. If this blocking behavior is not desired, consenter could    // simply return nil.    WaitReady() error    // 当排序集群发送错误时，会关闭返回的通道    // Errored returns a channel which will close when an error has occurred.    // This is especially useful for the Deliver client, who must terminate waiting    // clients when the consenter is not up to date.    Errored() &lt;-chan struct{}    // 启动当前链    // Start should allocate whatever resources are needed for staying up to date with the chain.    // Typically, this involves creating a thread which reads from the ordering source, passes those    // messages to a block cutter, and writes the resulting blocks to the ledger.    Start()    // 停止当前链，并释放资源    // Halt frees the resources which were allocated for this Chain.    Halt()}</code></pre><h1 id="Consenter"><a href="#Consenter" class="headerlink" title="Consenter"></a>Consenter</h1><p>Consenter 也是接口，它只有1个功能用来创建 Chain。每种共识插件，都有自己单独的consenter实现，分别用来创建solo实例、kafka实例或etcdraft实例。</p><pre><code>// Consenter defines the backing ordering mechanism.type Consenter interface {    // HandleChain should create and return a reference to a Chain for the given set of resources.    // It will only be invoked for a given chain once per process.  In general, errors will be treated    // as irrecoverable and cause system shutdown.  See the description of Chain for more details    // The second argument to HandleChain is a pointer to the metadata stored on the `ORDERER` slot of    // the last block committed to the ledger of this Chain. For a new chain, or one which is migrated,    // this metadata will be nil (or contain a zero-length Value), as there is no prior metadata to report.    HandleChain(support ConsenterSupport, metadata *cb.Metadata) (Chain, error)}</code></pre><h1 id="ConsenterSupport"><a href="#ConsenterSupport" class="headerlink" title="ConsenterSupport"></a>ConsenterSupport</h1><p>ConsenterSupport 为 consenter 实现提供所需的资源，其实就是共识用来访问外部数据的接口。</p><pre><code>// ConsenterSupport provides the resources available to a Consenter implementation.type ConsenterSupport interface {    crypto.LocalSigner    msgprocessor.Processor    // 验证区块签名是否合法    // VerifyBlockSignature verifies a signature of a block with a given optional    // configuration (can be nil).    VerifyBlockSignature([]*cb.SignedData, *cb.ConfigEnvelope) error    // 提供把消息切成块的接口    // BlockCutter returns the block cutting helper for this channel.    BlockCutter() blockcutter.Receiver    // 当前链的orderer配置    // SharedConfig provides the shared config from the channel&#39;s current config block.    SharedConfig() channelconfig.Orderer    // 当前链的通道配置    // ChannelConfig provides the channel config from the channel&#39;s current config block.    ChannelConfig() channelconfig.Channel    // 生成区块    // CreateNextBlock takes a list of messages and creates the next block based on the block with highest block number committed to the ledger    // Note that either WriteBlock or WriteConfigBlock must be called before invoking this method a second time.    CreateNextBlock(messages []*cb.Envelope) *cb.Block    // 读区块    // Block returns a block with the given number,    // or nil if such a block doesn&#39;t exist.    Block(number uint64) *cb.Block    // 写区块    // WriteBlock commits a block to the ledger.    WriteBlock(block *cb.Block, encodedMetadataValue []byte)    // 写配置区块并更新配置    // WriteConfigBlock commits a block to the ledger, and applies the config update inside.    WriteConfigBlock(block *cb.Block, encodedMetadataValue []byte)    // 返回当前配置序列号    // Sequence returns the current config squence.    Sequence() uint64    // 返回 channel ID    // ChainID returns the channel ID this support is associated with.    ChainID() string    // 返回区块高度    // Height returns the number of blocks in the chain this channel is associated with.    Height() uint64    //以原始数据的格式追加区块，不像WriteBlock那样会修改元数据    // Append appends a new block to the ledger in its raw form,    // unlike WriteBlock that also mutates its metadata.    Append(block *cb.Block) error}</code></pre><h1 id="一图看懂-Orderer-核心数据结构"><a href="#一图看懂-Orderer-核心数据结构" class="headerlink" title="一图看懂 Orderer 核心数据结构"></a>一图看懂 Orderer 核心数据结构</h1><blockquote><p>建议点击图片查看大图</p></blockquote><p><img src="http://note.youdao.com/yws/res/296/WEBRESOURCE4045838a95b90333c47c17cc7a9bc01b" alt="orderer 核心数据结构"></p>]]></content>
      
      
      <categories>
          
          <category> fabric </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fabric </tag>
            
            <tag> 源码解析 </tag>
            
            <tag> orderer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fabric 1.4源码分析1：Orderer功能概述</title>
      <link href="/2020/07/25/orderer-functions-overview/"/>
      <url>/2020/07/25/orderer-functions-overview/</url>
      
        <content type="html"><![CDATA[<blockquote><p>从今天开始，正式启动Fabric 1.4 源码分析系列专题，本文是源码分析系列的第一篇，决定先从 Orderer 入手。由于Fabric源码涉及的模块、知识点的深度和广度非同一般，为了避免从一开始就落入细节，因此决定先采用模块分解 + 架构梳理 + 知识点细化的三步走战略进行。希望通过这样自顶向下，逐步细化的方式从整体上把握fabric的实现原理，涉及到具体开发工作时又能快速上手。</p></blockquote><h1 id="代码目录"><a href="#代码目录" class="headerlink" title="代码目录"></a>代码目录</h1><p>源码分析的宗旨是一切始于源码，终于源码。所以我们首先来看看orderer这块的代码目录。orderer相关的代码主要在 fabric/orderer文件夹中：</p><pre><code>➜  fabric git:(readCode) ✗ tree -L 2 ordererorderer├── README.md├── common│   ├── blockcutter 缓存待打包的交易，切块│   ├── bootstrap 启动时替换通道创世块│   ├── broadcast orderer的Broadcast接口│   ├── cluster （Raft）集群服务│   ├── localconfig 解析orderer配置文件orderer.yaml│   ├── metadata 区块元数据填写│   ├── msgprocessor 交易检查│   ├── multichannel 多通道支持：Registrar、chainSupport、写区块│   └── server Orderer节点的服务端程序├── consensus 共识插件│   ├── consensus.go 共识插件需要实现的接口等定义│   ├── etcdraft raft共识插件│   ├── inactive 未激活时的raft│   ├── kafka kafka共识插件│   ├── mocks 测试用的共识插件│   └── solo solo共识插件├── main.go orderer程序入口├── mocks│   ├── common│   └── util└── sample_clients orderer的客户端程序样例    ├── broadcast_config    ├── broadcast_msg    └── deliver_stdout23 directories, 3 files</code></pre><p>相信大家这样过了一遍心里有个大致印象，但还是一脸懵逼，不过没关系，我们接着往下看：</p><h1 id="功能概述"><a href="#功能概述" class="headerlink" title="功能概述"></a>功能概述</h1><p>Orderer排序节点管理着系统通道与所有应用通道，负责通道创建、通道配置更新等操作，并处理客户端提交的交易消息请求，对交易进行排序并按规则打包成新区块，提交账本并维护通道账本数据，为全网节点提供Broadcast交易广播服务、Orderer共识排序服务、Deliver区块分发服务等。</p><p><img src="http://note.youdao.com/yws/res/63/WEBRESOURCE0d039e7a4924db2b6d979c334fd14e9d" alt="orderer功能概述"></p><blockquote><p>图片源自《Hyperledger Fabric技术内幕 架构设计与实现原理》</p></blockquote><h2 id="一笔交易在Orderer中经历的过程"><a href="#一笔交易在Orderer中经历的过程" class="headerlink" title="一笔交易在Orderer中经历的过程"></a>一笔交易在Orderer中经历的过程</h2><p>还记得在上一篇中我们介绍了一笔交易在fabric中所经历的过程，那么这一节我们依旧以交易为切入点，聚焦于交易在orderer这部分到底经历了什么。</p><p><img src="http://note.youdao.com/yws/res/84/WEBRESOURCEb122473b5b7acef549a64630e6570d63" alt="一笔交易在 orderer 中的处理流程"></p><p>如图所示，orderer节点首先通过<strong>Broadcast广播交易服务</strong>从客户端获取经过背书的交易消息，然后将交易进行排序并打包成区块，最后通过<strong>Deliver区块分发服务</strong>向peer节点分发打包好的区块。</p><p>其中将交易进行排序和打包成区块的步骤又可以进一步分解为:</p><ol><li>对交易进行多项检查（<strong>MsgProcessor</strong>）</li><li>通过solo、kafka、raft等共识算法对交易进行排序（<strong>consensus共识插件</strong>）</li><li>根据切块策略进行切块（<strong>BlockCutter</strong>）</li><li>保存区块文件（<strong>BlockWriter</strong>）</li></ol><p>通过以上对一笔交易在orderer中所经历的过程进行分析，我们会发现其实orderer这块的源码可以拆分成以下几个主要模块：</p><ol><li>广播交易服务：Brodcast </li><li>交易检查：Msgprocessor</li><li>交易排序：Solo、Kafka、Etcdraft</li><li>切块：Blockcutter</li><li>写区块：BlockWriter</li><li>区块分发服务：Deliver 区块分发服务</li></ol><p>除此之外，在分析源码之前我们还需要了解 Ordrer 的核心数据结构以及 Orderer节点的启动流程。</p><p>综上所述，orderer源码解析的知识图谱就呼之欲出了。</p><p><img src="http://note.youdao.com/yws/res/70/WEBRESOURCE94ead357ff1974f130ca9b572e879016" alt="Orderer 知识图谱"></p><p>这张图描绘了 orderer 这块源码我们需要掌握的主要知识点，现在肯定还有很多地方看不懂，不过没关系，有个大致印象就好，等我们把所有的知识点都理一遍再回过头来看这张图，相信会有一种“一览众山小”的感觉。</p><p>接下来，我们就将以这种图为线索，正式开始我们的orderer源码分析之旅。</p>]]></content>
      
      
      <categories>
          
          <category> fabric </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fabric </tag>
            
            <tag> 源码解析 </tag>
            
            <tag> orderer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fabric交易处理流程</title>
      <link href="/2020/07/25/tx-flow/"/>
      <url>/2020/07/25/tx-flow/</url>
      
        <content type="html"><![CDATA[<blockquote><p>fabric 作为目前世界上最为知名的联盟链开源项目，所涉及的模块和概念很多，本文以交易作为一个切入点，通过分析一笔交易从发送到最终上链所经历的各个环节，将fabric的核心模块串联起来，为接下来更为深入的各个模块的源码分析奠定基础。</p></blockquote><p><img src="http://note.youdao.com/yws/res/57/WEBRESOURCE9b612bf71f717be93422441ce1cd1afb" alt="交易流程"></p><blockquote><p>此图来自《Hyperledger Fabric技术内幕 架构设计与实现原理》</p></blockquote><h3 id="1-发送签名提案消息到Endorser背书节点请求处理"><a href="#1-发送签名提案消息到Endorser背书节点请求处理" class="headerlink" title="1. 发送签名提案消息到Endorser背书节点请求处理"></a>1. 发送签名提案消息到Endorser背书节点请求处理</h3><p>Client节点构造签名提案消息<font color="blue">(SignedProposal类型)</font>，通过调用Endorser背书服务客户端的<font color="blue">ProcessProposal()接口</font>，提交该消息到Endorser背书节点，请求模拟执行交易提案并签名背书。</p><h3 id="2-Endorser背书节点模拟执行交易提案并签名背书Endorser背书"><a href="#2-Endorser背书节点模拟执行交易提案并签名背书Endorser背书" class="headerlink" title="2. Endorser背书节点模拟执行交易提案并签名背书Endorser背书"></a>2. Endorser背书节点模拟执行交易提案并签名背书Endorser背书</h3><p>节点收到签名提案消息之后，进行如下处理。</p><ol><li>检查签名提案消息的格式合法性与签名有效性，包括通道头部、签名头部、签名 域、交易ID、消息扩展域的Chaincodeld属性与PayloadVisibility可见性模式等；</li><li>检查提案消息的创建者是否满足指定通道上的通道访问权限，即/Channel/ Application/Writers 写权限；</li><li>检查并启动链码容器以模拟执行交易提案，并将模拟执行结果暂时保存在交易模拟器中，等待排序共识与交易验证，而不是直接更新到账本中。其中，<font color="blue">交易模拟执行结果釆用状态数据读写集（读数据的键和版本、写数据的键值）记录交易造成的状态变更结果；</font></li><li><font color="blue">调用ESCC系统链码对该提案消息的模拟结果读写集等进行签名背书</font>。</li></ol><h3 id="3-Endorser背书节点向客户端返回提案响应消息，并分发隐私数据明文"><a href="#3-Endorser背书节点向客户端返回提案响应消息，并分发隐私数据明文" class="headerlink" title="3. Endorser背书节点向客户端返回提案响应消息，并分发隐私数据明文"></a>3. Endorser背书节点向客户端返回提案响应消息，并分发隐私数据明文</h3><p>Endorser背书节点基于背书信息、模拟执行结果等构造提案响应消息（ProposalResponse 类型），并回复给请求客户端。</p><p>目前，模拟执行结果读写集包含公有数据（包括公共数据与隐私数据哈希值）与私有数据（或隐私数据）。</p><p>其中，公有数据交由0rderer节点进行排序出块，再提交到账本区块 数据文件，并广播到该通道上的所有节点。</p><p>如果模拟执行结果中还存在有效的隐私数据明文，则<font color="blue">Endorser背书节点通过Gossip消息协议将隐私数据发送给通道内授权的其他节点（由隐私数据集合配置的签名策略决定），交由transient隐私数据存储对象暂时保存到本地的transient隐私数据库（LevelDB）,并在提交账本时存储到隐私数据库（LevelDB）,同时清理transient隐私数据库中的过期数据</font>。</p><h3 id="4-处理提案响应消息"><a href="#4-处理提案响应消息" class="headerlink" title="4. 处理提案响应消息"></a>4. 处理提案响应消息</h3><p>Client节点解析Endorser背书节点回复的提案响应消息，获取背书结果并检查提案响应消息状态的合法性，以判断是否收集到了<font color="blue">足够多的符合要求的背书签名信息</font>。</p><h3 id="5-发送交易数据给Orderer服务节点请求排序"><a href="#5-发送交易数据给Orderer服务节点请求排序" class="headerlink" title="5. 发送交易数据给Orderer服务节点请求排序"></a>5. 发送交易数据给Orderer服务节点请求排序</h3><p>当收集到足够多数量的符合要求的Endorser背书签名之后（由背书策略决定），<font color="blue">Client节点基于模拟执行结果、背书签名等构造合法的签名交易消息（Envelope类型），通过Broadcast（）服务接口将该消息提交给Orderer节点</font>，请求交易排序处理。其中，配置交易消 息不需要经过Endorser节点处理。</p><h3 id="6-Orderer服务节点对交易进行排序并构造新区块"><a href="#6-Orderer服务节点对交易进行排序并构造新区块" class="headerlink" title="6. Orderer服务节点对交易进行排序并构造新区块"></a>6. Orderer服务节点对交易进行排序并构造新区块</h3><p>Orderer排序节点<font color="blue">提供Solo类型（用于单节点测试）、Kafka类型（支持CFT容错）等共识组件</font>，对符合通道处理要求的合法交易消息（普通交易消息、配置交易消息等）进行排序并达成一致观点，并对一段时间内接收的一批交易消息按照打包交易的岀块规则（出块周期 时间、区块字节数限制、配置交易单独出块等）构造新区块，创建应用通道或更新通道配置同时提交账本。</p><h3 id="7-Leader主节点请求Orderer服务节点发送通道账本区块"><a href="#7-Leader主节点请求Orderer服务节点发送通道账本区块" class="headerlink" title="7. Leader主节点请求Orderer服务节点发送通道账本区块"></a>7. Leader主节点请求Orderer服务节点发送通道账本区块</h3><p><font color="blue">Leader主节点通过Deliver()服务接口代表组织从Orderer节点请求通道账本上所有的区块数据，并通过Gossip消息协议分发到组织内的其他Peer节点</font>。如果请求的区块数据不 存在，则Orderer节点默认阻塞等待，直到指定区块创建完成并提交账本，再将该区块发送 给Leader主节点。</p><h3 id="8-Committer记账节点验证交易并提交账本"><a href="#8-Committer记账节点验证交易并提交账本" class="headerlink" title="8. Committer记账节点验证交易并提交账本"></a>8. Committer记账节点验证交易并提交账本</h3><p>Committer记账节点对区块与隐私数据（明文）执行如下检查，并提交至本地账本。如果不存在隐私数据明文，则跳过隐私数据的相关检查与提交账本的步骤。</p><ol><li>检查交易消息格式的正确性、签名合法性、交易内容是否篡改、消息头部的合法性等。</li><li><font color="blue">调用VSCC系统链码</font>，验证收集的签名背书结果是否符合指定的背书策略。</li><li>对模拟结果中公有数据（即区块数据，含有公共数据与隐私数据哈希值）的<font color="blue">读写集执行MVCC检查</font>，针对单个键查询、键范围查询、隐私数据哈希值三种情况，检查读数据版本与交易时的账本是否一致，即是否存在读写冲突，并将存在冲突的交易标记为无效交易。</li><li>验证模拟结果中隐私数据的正确性，遍历区块中有效交易的隐私数据读写集哈希值，取岀对应交易的原始隐私数据读写集明文，重新计算其哈希值并对两者进行比较。如果两者完全相同，则说明该交易的隐私数据是真实有效的。</li><li>保存所有的区块数据（即公有数据）到<font color="blue">区块数据文件</font>中，保存所有的私有数据（即隐私数据）读写集到<font color="blue">隐私数据库（LevelDB）</font>中，建立区块索引信息到<font color="blue">区块索引数据库</font>，将最新的有效交易数据（包含公共数据读写集、隐私数据读写集、隐私数据读写集哈希值）更新到<font color="blue">状态数据库</font>，最后将区块数据中经过Endorser背书的有效交易数据同步到<font color="blue">历史数据库</font>。同时，清理<font color="blue">transient隐私数据库中</font>的过期数据。</li></ol><h3 id="9-Leader主节点分发数据与状态同步"><a href="#9-Leader主节点分发数据与状态同步" class="headerlink" title="9. Leader主节点分发数据与状态同步"></a>9. Leader主节点分发数据与状态同步</h3><p>Leader主节点基于<font color="blue">Gossip消息协议</font>将区块数据分发到组织内的其他节点上。同时，<font color="blue">节点之间通过反嫡算法等机制主动拉取缺失的数据</font>（区块数据与隐私数据）、节点身份信息等,以确保组织内所有节点上的账本数据等信息保持同步。</p><h3 id="10-Committer记账节点验证交易并提交账本（同步骤8）"><a href="#10-Committer记账节点验证交易并提交账本（同步骤8）" class="headerlink" title="10. Committer记账节点验证交易并提交账本（同步骤8）"></a>10. Committer记账节点验证交易并提交账本（同步骤8）</h3><p>至此，Hyperledger Fabric系统上的一次完整交易处理流程即告结束。</p><h2 id="预告"><a href="#预告" class="headerlink" title="预告"></a>预告</h2><blockquote><p>从下一篇开始，我们就要正式开启fabric源码分析的专题了，本篇文章其实是一个知识准备。这里多说一句，就是我为什么要开启这个fabric源码分析的专题，其实这件事一直在我心中酝酿，但是由于前一段时间较忙，而且内心总是有一些否定的声音让我陷入自我怀疑，到底要不要做，因为现在网上已经有很多关于fabric源码分析的资料，而且质量也很高，为什么不直接抄“学霸”的作业呢，一定要自己搞一遍，不累吗？其实我是这样想的，“一千个读者就有一千个哈姆雷特”。那么我可不可以这么理解，“一千个开发者就有一千个fabric”。别人关于源码解读的文章都是基于其本人的知识架构下的，而如果我们一定要去灌输到自己的大脑中，可能会有些消化不良。而且我们也不能一味的迷信“权威”，学霸的作业也可能有疏漏的地方，别人的分析都是经过二次加工的产物，带有强烈的主观主义色彩，我们还是应该忠于源码，探索“属于我自己的fabric”。好了，废话有点多，接下来就进入正题吧。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> fabric </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fabric </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go vendor 使用</title>
      <link href="/2020/07/18/govendor/"/>
      <url>/2020/07/18/govendor/</url>
      
        <content type="html"><![CDATA[<blockquote><p>由于最近遇到个项目需要使用 go vendor 进行依赖管理，所以就简单学习了一下</p></blockquote><p>三步走</p><h4 id="第一步："><a href="#第一步：" class="headerlink" title="第一步："></a>第一步：</h4><p>进入项目</p><pre><code>cd [project name]</code></pre><p>执行 </p><pre><code>govendor init</code></pre><p>项目根目录下即会自动生成 vendor 目录和 vendor.json 文件</p><h4 id="第二步："><a href="#第二步：" class="headerlink" title="第二步："></a>第二步：</h4><p>将已被引用且在 $GOPATH 下的所有包复制到 vendor 目录</p><pre><code>govendor add +external</code></pre><h4 id="第三步："><a href="#第三步：" class="headerlink" title="第三步："></a>第三步：</h4><p>拉取所有依赖的包到 vendor 目录(包括 $GOPATH 存在或不存在的包)</p><pre><code>govendor fetch +out</code></pre><h4 id="其他常用命令"><a href="#其他常用命令" class="headerlink" title="其他常用命令"></a>其他常用命令</h4><p>从远程仓库添加或更新某个包(不会在 $GOPATH 也存一份)</p><pre><code>govendor fetch golang.org/x/net/context</code></pre><p>安装指定版本的包</p><pre><code>govendor fetch golang.org/x/net/context@a4bbce9fcae005b22ae5443f6af064d80a6f5a55</code></pre><p>包已在 vendor 目录，但想从 $GOPATH 更新</p><pre><code>govendor update +vendor</code></pre><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://lessisbetter.site/2018/11/17/An-introduction-to-Govendor/" target="_blank" rel="noopener">https://lessisbetter.site/2018/11/17/An-introduction-to-Govendor/</a></p><p><a href="https://shockerli.net/post/go-package-manage-tool-govendor/" target="_blank" rel="noopener">https://shockerli.net/post/go-package-manage-tool-govendor/</a></p>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>向 fabric 贡献代码</title>
      <link href="/2020/07/14/fabric-contribute/"/>
      <url>/2020/07/14/fabric-contribute/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文主要记录了向fabric开源社区贡献代码的过程</p></blockquote><h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><p>进入 fabric目录</p><p>cd fabric</p><h2 id="1-先获取对应分支"><a href="#1-先获取对应分支" class="headerlink" title="1. 先获取对应分支"></a>1. 先获取对应分支</h2><p>git fetch origin [目标分支]</p><h2 id="2-切到对应分支"><a href="#2-切到对应分支" class="headerlink" title="2. 切到对应分支"></a>2. 切到对应分支</h2><p>git checkout -b [目标分支]</p><h2 id="3-更新最新代码（此步骤可省略）"><a href="#3-更新最新代码（此步骤可省略）" class="headerlink" title="3. 更新最新代码（此步骤可省略）"></a>3. 更新最新代码（此步骤可省略）</h2><p>goland -&gt; vcs -&gt; git -&gt; Rebase my Github fork -&gt; 选择原代码仓库</p><p>参考：<a href="https://www.zhihu.com/question/28676261" target="_blank" rel="noopener">https://www.zhihu.com/question/28676261</a></p><p>或者：</p><pre><code>git remote add upstream https://github.com/hyperledger/fabricgit fetch upstreamgit checkout [目标分支]git rebase upstream/[目标分支]git push -f origin [目标分支]</code></pre><h2 id="4-新建一个用于开发的分支"><a href="#4-新建一个用于开发的分支" class="headerlink" title="4. 新建一个用于开发的分支"></a>4. 新建一个用于开发的分支</h2><p>名字格式为 FAB-XXXX （issue序号）</p><p>git checkout -b FAB-XXX</p><h2 id="5-正式干活"><a href="#5-正式干活" class="headerlink" title="5. 正式干活"></a>5. 正式干活</h2><p>愉快滴开发（此处省略一万字）</p><h2 id="6-提交-：-git-commit-a-s"><a href="#6-提交-：-git-commit-a-s" class="headerlink" title="6. 提交 ：$ git commit -a -s"></a>6. 提交 ：$ git commit -a -s</h2><p>-s 选项是用于在commit message中自动生成sign off签名的</p><h2 id="7-编辑commit信息"><a href="#7-编辑commit信息" class="headerlink" title="7. 编辑commit信息"></a>7. 编辑commit信息</h2><pre><code>[FAB-XXXX] &lt;标题,官方文档说本行不能超过72个字符，实测不能超过55个字符&gt;&lt;空行&gt;This fixes #FAB-XXXX&lt;内容：每行不超过80字符，其中应该包括- 你的提交做了什么？- 为何选用这种方式去进行改动- 为何这种改动能够成功，比如提交你成功的代码测试结果&gt;</code></pre><h2 id="8-推送代码"><a href="#8-推送代码" class="headerlink" title="8. 推送代码"></a>8. 推送代码</h2><p>vcs -&gt; git -&gt; push</p><h2 id="9-pull-request"><a href="#9-pull-request" class="headerlink" title="9. pull request"></a>9. pull request</h2><p>登录 github,找到刚刚push的分支，点击 compare and pull request</p><p>注意要推送的目标分支，一般默认是master，这里需要修改为要推送的分支</p><p>确认commit信息没问题后点击右下角 create pull request</p><h2 id="9-等待合并"><a href="#9-等待合并" class="headerlink" title="9.等待合并"></a>9.等待合并</h2><p>会跑一堆测试，所有测试都过了以后经过两个以上的人approve则会被merge</p><h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><h3 id="git-push-ERROR-You-must-verify-your-email-address"><a href="#git-push-ERROR-You-must-verify-your-email-address" class="headerlink" title="git push ERROR: You must verify your email address"></a>git push ERROR: You must verify your email address</h3><p>解决方法：<a href="https://www.jianshu.com/p/30ee5daf1327" target="_blank" rel="noopener">https://www.jianshu.com/p/30ee5daf1327</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://davidkhala.github.io/2017/08/30/fabric-contribute/" target="_blank" rel="noopener">https://davidkhala.github.io/2017/08/30/fabric-contribute/</a></p>]]></content>
      
      
      <categories>
          
          <category> fabric </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fabric </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitLab CICD 自动化部署</title>
      <link href="/2020/07/14/cicd/"/>
      <url>/2020/07/14/cicd/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文简单记录了自学使用GitLab CI进行自动化部署的过程</p></blockquote><h1 id="什么是-CI-CD-流水线？"><a href="#什么是-CI-CD-流水线？" class="headerlink" title="什么是 CI/CD 流水线？"></a>什么是 CI/CD 流水线？</h1><p>CI 代表持续集成（Continuous Integration），CD 代表持续交付（Continuous Delivery）和持续部署（Continuous Deployment）。也可以将它们看作是类似于软件开发生命周期的过程。</p><h4 id="持续集成"><a href="#持续集成" class="headerlink" title="持续集成"></a>持续集成</h4><p>持续集成指在和向远程仓库 push 代码后，在这次提交合并入主分支前进行一系列测试，构建等流程。假设现在有个应用的代码存储在 gitlab 上，每天开发者都 push 很多次提交，针对每次 push，你可以创建一系列脚本进行自动测试，降低往应用里引入错误的概率。这就是持续集成，它可应用在包括开发分支在内的多个分支上。</p><h4 id="持续部署"><a href="#持续部署" class="headerlink" title="持续部署"></a>持续部署</h4><p>持续部署在持续集成的基础上更进一步，指将推送指仓库默认分支的部署至产品环境。如果这部分需要手动触发，这就是一个持续交付（Continuous Delivery）环节</p><p><img src="https://static.geekbang.org/infoq/5cac03c74862e.png?imageView2/0/w/800" alt></p><p>如上图所示，该流水线展示了一个软件在其最终交付给客户或者投入上线之前，它在其生命周期内各个阶段中的移动过程。</p><p>我们可以看到软件从代码完成到最终交付先后会经历构建(build)、单元测试(unit test)、部署(deploy)、自动测试(auto test)、部署到生产环境(deploy to production)以及度量和验证(measure &amp; validate)等多个阶段。</p><p>具体阶段说明请参考 <a href="https://www.infoq.cn/article/WHt0wFMDRrBU-dtkh1Xp" target="_blank" rel="noopener">如何从零开始搭建 CI/CD 流水线</a></p><h1 id="部署方案"><a href="#部署方案" class="headerlink" title="部署方案"></a>部署方案</h1><p>目前与gitlab持续集成的比较流行的自动化部署解决方案主要有jenkins和GitLab CI/CD两种。</p><h2 id="Jenkins"><a href="#Jenkins" class="headerlink" title="Jenkins"></a>Jenkins</h2><p>Jenkins 是一款比较流行的持续化集成自动化工具，为我们提供了各种接口和工具，用以实现软件开发整个过程的自动化。</p><p>如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/20190110163723744.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NkYmRxbjAwMQ==,size_16,color_FFFFFF,t_70" alt></p><p>由客户端将代码push推送到git仓库，gitlab上配置了一个webHook的东西可以触发Jenkins的构建。</p><p>进入到Jenkins虚线范围内，它所做的事情非常多，从mvn构建代码，对代码进行静态分析，做单元测试，测试通过之后就可以build镜像，镜像构建成功后就把镜像push推送到Harbor镜像仓库中。</p><p>镜像push推送到镜像仓库后，我们就可以调用kubernetes集群的restAPI更新服务，而后kubernetes接收到了更新的指令，从Harbor镜像仓库pull拉取镜像，从而完成服务的更新与重启，最后我们从客户端来访问kubernetes集群的服务</p><p><big><strong>优点:</strong> </big> 编译服务和代码仓库分离，而且编译配置文件不需要在工程中配置，如果团队有开发、测试、配置管理员、运维、实施等完整的人员配置，那就采用jenkins，这样职责分明。jenkins依靠它丰富的插件，可以配置很多gitlab-ci不存在的功能，比如说看编译状况统计等。</p><p><big><strong>缺点:</strong> </big> 配置相对复杂，维护成本较高等</p><h2 id="GitLab-CI-CD"><a href="#GitLab-CI-CD" class="headerlink" title="GitLab CI/CD"></a>GitLab CI/CD</h2><p>GitLab CI/CD 是GitLab Continuous Integration（Gitlab持续集成）的简称。GitLab 自GitLab 8.0开始提供了持续集成的功能，且对所有项目默认开启。只要在项目仓库的根目录添加.gitlab-ci.yml文件，并且配置了Runner（运行器），那么每一次push或者合并请求（Merge Request）都会触发CI Pipeline。</p><p>如图所示，可以理解为GitLab CI/CD是Gitlab给开发者提供的一项功能，它在代码提交后自动触发一段开发者自定义的脚本，以此来完成诸如但不限于构建部署的工作。</p><p><img src="https://pic1.zhimg.com/80/v2-a91bb21049a0a797d4092789aa16b808_720w.jpg" alt></p><h3 id="关键概念"><a href="#关键概念" class="headerlink" title="关键概念"></a>关键概念</h3><h4 id="Pipelines"><a href="#Pipelines" class="headerlink" title="Pipelines"></a>Pipelines</h4><p>Pipelines 中文称为流水线，是分阶段执行的构建任务。如：安装依赖、运行测试、打包、部署开发服务器、部署生产服务器等流程。每一次push或者Merge Request都会触发生成一条新的Pipeline</p><h4 id="Stages"><a href="#Stages" class="headerlink" title="Stages"></a>Stages</h4><p>Stages 表示构建阶段，可以理解为上面所说“安装依赖”、“运行测试”等环节的流程。我们可以在一次 Pipeline 中定义多个 Stages，这些 Stages 会有以下特点：</p><ol><li>所有 Stages 会按照顺序运行，即当一个 Stage 完成后，下一个 Stage 才会开始（当然可以在.gitlab-ci.yml文件中配置上一阶段失败时下一阶段也执行）</li><li>只有当所有 Stages 完成后，该构建任务 (Pipeline) 才会成功</li><li>如果任何一个 Stage 失败，那么后面的 Stages 不会执行，该构建任务 (Pipeline) 失败</li></ol><h4 id="Jobs"><a href="#Jobs" class="headerlink" title="Jobs"></a>Jobs</h4><p>Jobs 表示构建的作业（或称之为任务），表示某个 Stage 里面执行的具体任务。我们可以在 Stages 里面定义多个 Jobs，这些 Jobs 会有以下特点：</p><ol><li>相同 Stage 中的 Jobs 无执行顺序要求，会并行执行</li><li>相同 Stage 中的 Jobs 都执行成功时，该 Stage 才会成功</li><li>如果任何一个 Job 失败，那么该 Stage 失败，即该构建任务 (Pipeline) 也失败（可以在.gitlab-ci.yml文件中配置允许某 Job 可以失败，也算该 Stage 成功）</li></ol><p><big> <strong>优点:</strong> </big>完美和gitlab进行集成，gitlab-ci已经集成进gitlab服务器中，在使用的时候只需要安装配置gitlab-runner即可。 gitlab-runner基本上提供了一个可以进行编译的环境，负责从gitlab中拉取代码，根据工程中配置的gitlab-ci.yml，执行相应的命令进行编译。</p><p><big> <strong>缺点:</strong> </big>功能相对少一些，没有web页面查看等</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>由于采用Jenkins进行自动化集成部署较为复杂，GitLab完美和GitLab集成，更为简单和方便，且对于我来说，GitLab CI/CD所提供等功能已足够使用，所以我更偏向于“小而精”的GitLab CI/CD而不是“大而全”的Jenkins。</p><h1 id="GitLab-CI-CD实战"><a href="#GitLab-CI-CD实战" class="headerlink" title="GitLab CI/CD实战"></a>GitLab CI/CD实战</h1><p>说了这么多，相信大家已经迫不及待地跃跃欲试了，下面就介绍一下GitLab CI/CD的使用步骤。</p><p>参考： <a href="http://192.168.9.251/help/ci/quick_start/README" target="_blank" rel="noopener">GitLab CI / CD入门</a></p><p>其实大体来说就两步：</p><ol><li>在项目的根目录下添加一个配置文件 .gitlab-ci.yaml</li><li>配置一个 GitLab Runner</li></ol><h2 id="配置-gitlab-ci-yml"><a href="#配置-gitlab-ci-yml" class="headerlink" title="配置 .gitlab-ci.yml"></a>配置 .gitlab-ci.yml</h2><p>GitLab 中默认开启了 Gitlab CI/CD 的支持，且使用YAML文件.gitlab-ci.yml来管理项目构建配置。该文件需要存放于项目仓库的根目录（默认路径，可在 GitLab 中修改），它定义该项目的 CI/CD 如何配置。所以，我们只需要在.gitlab-ci.yml配置文件中定义流水线的各个阶段，以及各个阶段中的若干作业（任务）即可。</p><p>下面是.gitlab-ci.yml文件的一个简单的Hello World示例：</p><pre><code># 定义 build 和 test 两个 Stages    stages:  - build  - test# 定义 build 阶段的一个 jobbuild_job:  stage: build  script:    - echo &quot;the project is being built&quot;# 定义 test 阶段的一个 jobtest_job:  stage: test  script:    - echo &quot;the project is being built&quot;</code></pre><p>以上配置中，用 stages 关键字来定义 Pipeline 中的各个构建阶段，然后用一些非关键字来定义 jobs。每个 job 中可以可以再用 stage 关键字来指定该 job 对应哪个 stage。job 里面的script关键字是每个 job 中必须要包含的，它表示每个 job 要执行的命令。</p><p>关于.gitlab-ci.yml的详细配置规则可参考官方文档 <a href="https://docs.gitlab.com/ce/ci/yaml/README.html" target="_blank" rel="noopener">GitLab CI/CD pipeline configuration reference</a></p><p>配置完就可以直接 commit &amp; push 这个配置文件了<br>一旦提交了这个 .gitlab-ci.yaml文件，那么下次在任何一次push到gitlab的操作，GitLab都会查找该.gitlab-ci.yml<br>文件并根据该文件的内容在 gitlab Runners上执行jobs。</p><p>此时再查看 CI/CD -&gt; popeline 可以发现会有一条pipeline 处于挂起阶段，这是因为我们没有注册gitlab runner的原因</p><p>导致无法运行 .gitlab-ci.yaml中的jobs，那么下面我们就来安装一下 gitlab runner</p><h2 id="安装GitLab-Runner"><a href="#安装GitLab-Runner" class="headerlink" title="安装GitLab Runner"></a>安装GitLab Runner</h2><p>gitlab runner 用于与git服务器进行通信，当有新的任务发布到当前runner时，runner会执行.gitlab-ci.yml所定义的CI指令。</p><p>如果你的操作系统和我一样是macOS，那么可以采用以下方式进行安装：</p><p>方式一：用homebrew进行安装，在命令行中直接执行</p><pre><code>brew install gitlab-runner</code></pre><p>方式二（官方）：Gitlab runner 10以上安装方式，若安装旧版本前往官网查看<br>（1）下载</p><pre><code>sudo curl --output /usr/local/bin/gitlab-runner https://gitlab-runner-downloads.s3.amazonaws.com/latest/binaries/gitlab-runner-darwin-amd64</code></pre><p>(2)设置权限</p><pre><code>sudo chmod +x /usr/local/bin/gitlab-runner</code></pre><p>其他安装方式可参考 <a href="https://docs.gitlab.com/runner/install/" target="_blank" rel="noopener">Install GitLab Runner</a></p><h2 id="注册-gitlab-runner"><a href="#注册-gitlab-runner" class="headerlink" title="注册 gitlab runner"></a>注册 gitlab runner</h2><p>命令的交互式的过程如下：</p><pre><code>➜  ~ git:(master) ✗ sudo gitlab-runner registerRuntime platform                                    arch=amd64 os=linux pid=17 revision=6fbc7474 version=13.1.1Running in system-mode.# 输入公司的 GitLab 网站地址，可以在 Settings -&gt; CI/CD -&gt; Runner 中找到Please enter the gitlab-ci coordinator URL (e.g. https://gitlab.com/):http://192.168.9.251/# 你项目仓库的token，token可以在 Settings -&gt; CI/CD -&gt; Runner 中找到Please enter the gitlab-ci token for this runner:ienceCevg-sdxqQhBaGZ# 输入描述这个 runner 的名称，这个字段没有特殊的作用，只是为了区分不同的runner，这里可设置为runner-serverPlease enter the gitlab-ci description for this runner:[1b6095f8f875]: runner-server# tags这个属性，job和runner都有，用来匹配任务和执行任务的runner。runner的tag可以有多个，注册时用逗号（comma）分隔即可。当某个job的tag是当前runner tags的一个子集时，这个job就可以被分配到当前runner上执行Please enter the gitlab-ci tags for this runner (comma separated):testRegistering runner... succeeded                     runner=ienceCev# executor就是执行job的环境，通常我们都会选择Shell，如果有其他需要的也可以自行查阅文档。需要注意的是，runner执行的环境是非常干净的，像类似ANDROID_HOME的变量都需要通过shell指令export xxx=xxx在执行时输入，而不是使用设备上的环境。Please enter the executor: docker, shell, ssh, docker+machine, docker-ssh+machine, custom, docker-ssh, parallels, virtualbox, kubernetes:shellRunner registered successfully. Feel free to start it, but if it&#39;s running already the config should be automatically reloaded!</code></pre><p>以上流程注册成功之后，就可以在你的项目仓库中 Settings -&gt; CI/CD -&gt; Runner看到这个 Runner 了。</p><p><img src="https://note.youdao.com/yws/public/resource/bc554143fcca768f52bf1354ffef92eb/xmlnote/EE6BA5A809BA4D5E8DE7A943D7A8EB14/2579?ynotemdtimestamp=1595666133983" alt></p><h2 id="安装共享runner"><a href="#安装共享runner" class="headerlink" title="安装共享runner"></a>安装共享runner</h2><p>安装共享runner与安装专有runner类似，主要区别在于共享runner需要gitlab的管理员权限，进入管理员界面，overview-&gt;runner，将runner的token和URL复制下来，在注册的时候添加进去就可以，此处不再赘述，详细步骤请参考<a href="https://cloud.tencent.com/developer/article/1411267" target="_blank" rel="noopener">此处</a></p><h1 id="GitLab-runner-常用命令"><a href="#GitLab-runner-常用命令" class="headerlink" title="GitLab runner 常用命令"></a>GitLab runner 常用命令</h1><p>下面表格列出了 Gitlab runner 的常用命令：</p><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>gitlab-runner run</td><td>运行一个runner服务</td></tr><tr><td>gitlab-runner register</td><td>注册一个新的runner</td></tr><tr><td>gitlab-runner start</td><td>启动服务</td></tr><tr><td>gitlab-runner stop</td><td>关闭服务</td></tr><tr><td>gitlab-runner restart</td><td>重启服务</td></tr><tr><td>gitlab-runner status</td><td>查看各个runner的状态</td></tr><tr><td>gitlab-runner unregister</td><td>注销掉某个runner</td></tr><tr><td>gitlab-runner list</td><td>显示所有运行着的runner</td></tr><tr><td>gitlab-runner verify</td><td>检查已注册的运行程序是否可以连接到GitLab，但它不验证GitLab Runner服务是否正在使用运行程序。</td></tr></tbody></table><p>更多命令请参考 <a href="https://docs.gitlab.com/runner/commands/README.html" target="_blank" rel="noopener">GitLab Runner commands</a></p><p>此时，再回 gitlab 仓库查看并重新运行之前刮起的pipeline，等待一会儿会发现运行通过了</p><p><img src="https://note.youdao.com/yws/public/resource/bc554143fcca768f52bf1354ffef92eb/xmlnote/6E07FADE32774BABB8735C787120F04B/2601?ynotemdtimestamp=1595666133983" alt="pipeline"></p><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ol><li><p>每次向 gitlab 推送完代码后，会自动触发一条 pipeline，可点击 gitlab 左侧边栏的 CI/ID 进行查看 pipeline 的运行情况。</p><p><img src="https://note.youdao.com/yws/public/resource/bc554143fcca768f52bf1354ffef92eb/xmlnote/221CC727BF154DC8B47E53D732299ED3/3030" alt></p></li><li><p>某些 job 运行失败可能是由于网络问题，比如 gcc 安装和更新失败，此时可点击重试。</p></li><li><p>目前跑完一条完整的 pipeline 需要时间较长， 为了保证开发效率，建议每次完成开发，推送代码前先在本地进行以下检查。</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">go</span> buildgolangci<span class="token operator">-</span>lint run<span class="token keyword">go</span> test <span class="token punctuation">.</span><span class="token operator">/</span><span class="token operator">...</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果存在问题先解决问题，确保没问题之后再向 gitlab 推送代码。</p></li><li><p>目前静态代码检查采用的 golangci-lint 为1.18.0版本，可从<a href="http://192.168.9.251:9000/software" target="_blank" rel="noopener">此处</a>下载。</p></li><li><p>编译镜像成功后会自动将镜像推送到 harbor 镜像仓库，如果有需要可直接从镜像仓库进行<a href="http://192.168.9.8/harbor/projects/17/repositories/crosschain%2Fcrossnet" target="_blank" rel="noopener">拉取</a>。</p></li><li><p>关于 GitLab CI/CD 的更多详细内容请参考<a href="ttps://docs.gitlab.com/ee/ci/" target="_blank" rel="noopener">官方文档</a>。</p></li></ol><h1 id="踩坑指南"><a href="#踩坑指南" class="headerlink" title="踩坑指南"></a>踩坑指南</h1><h2 id="安装-gitlab-runner-失败"><a href="#安装-gitlab-runner-失败" class="headerlink" title="安装 gitlab runner 失败"></a>安装 gitlab runner 失败</h2><p>在实际安装 gitlab runner 的过程中发现采用上面的方式二会特别慢，而采用方式一则在下一步注册 Gitlab Runner的时候会出现如下问题：</p><pre><code>➜  ~ git:(master) ✗ sudo gitlab-runner registerPassword:[1]    37431 killed     sudo gitlab-runner register</code></pre><p>在网上搜寻解决方案未果，于是决定采用docker进行安装，步骤如下：</p><p>执行以下命令创建容器并启动</p><pre><code>docker run -d --name gitlab-runner --restart always -v ~/gitlab-runner/config:/etc/gitlab-runner -v /var/run/docker.sock:/var/run/docker.sock  gitlab/gitlab-runner:latest</code></pre><p>执行完成后可以 docker ps 一下进行查看</p><pre><code>➜  ~ git:(master) ✗ docker psCONTAINER ID        IMAGE                         COMMAND                  CREATED             STATUS              PORTS               NAMES1b6095f8f875        gitlab/gitlab-runner:latest   &quot;/usr/bin/dumb-init …&quot;   5 seconds ago       Up 3 seconds                            gitlab-runner</code></pre><p>然后注册 gitlab runner，只需执行</p><pre><code>docker exec -it 1b6095f8f875 gitlab-runner register</code></pre><p>其中 1b6095f8f875 是上一步执行的返回的 ID</p><h2 id="安装完-gitlab-runner-显示-pipeline-stuck"><a href="#安装完-gitlab-runner-显示-pipeline-stuck" class="headerlink" title="安装完 gitlab runner 显示 pipeline stuck"></a>安装完 gitlab runner 显示 pipeline stuck</h2><ol><li><p>可能是没有设置为忽略tag的原因, 去设置-&gt; CICD界面下将 tag 那个选项打勾就行</p></li><li><p>可能是 gitlab-runner 容器挂掉了, 可以登录gitlab-runner所在服务器执行</p><pre><code>docker restart gitlab-runner</code></pre></li></ol><h2 id="pipeline-运行时报错【Permission-denied】"><a href="#pipeline-运行时报错【Permission-denied】" class="headerlink" title="pipeline 运行时报错【Permission denied】"></a>pipeline 运行时报错【Permission denied】</h2><p><img src="https://note.youdao.com/yws/public/resource/bc554143fcca768f52bf1354ffef92eb/xmlnote/C512459EDB3A41A7938D5DB227C26E61/2630?ynotemdtimestamp=1595666133983" alt></p><p>在跑 CICD的时候发现以上错误，一开始以为是权限的问题，但是加了dudo依然未能解决，后来通过复盘 gitlab runner安装、注册等全过程，发现在安装gitlab是采用的docker模式，但是注册gitlab时指定的运行环境是shell，于是换成了docker，重新跑了一下，原来的错误消失了</p><p>PS: 指定执行环境是docker后，还需指定 docker image 为 stable, 如下：</p><pre><code>Please enter the executor: virtualbox, docker+machine, docker-ssh, shell, parallels, ssh, docker-ssh+machine, kubernetes, custom, docker:dockerPlease enter the default Docker image (e.g. ruby:2.6):docker:stable</code></pre><h2 id="运行-docker-命令报错"><a href="#运行-docker-命令报错" class="headerlink" title="运行 docker 命令报错"></a>运行 docker 命令报错</h2><p>运行docker info命令时报错</p><p><img src="https://note.youdao.com/yws/public/resource/bc554143fcca768f52bf1354ffef92eb/xmlnote/5308331A5FF94826A5BFB66F128CF7CF/2644?ynotemdtimestamp=1595666133983" alt></p><p>查找资料<br><a href="https://gitlab.com/gitlab-org/gitlab-runner/-/issues/4566" target="_blank" rel="noopener">https://gitlab.com/gitlab-org/gitlab-runner/-/issues/4566</a></p><p>修改配置文件</p><pre><code>vim gitlab-runner/config/config.toml</code></pre><p>volumes 配置项</p><pre><code>volumes = [&quot;/cache&quot;, &quot;/var/run/docker.sock:/var/run/docker.sock&quot;]</code></pre><p>重新启动 gitlab runner </p><pre><code>docker restart 99451b349e7f</code></pre><p>其中 99451b349e7f 为容器ID</p><p>再重新跑pipeline，发现原来的错误消失了</p><h2 id="执行shell脚本报错"><a href="#执行shell脚本报错" class="headerlink" title="执行shell脚本报错"></a>执行shell脚本报错</h2><p><img src="https://note.youdao.com/yws/public/resource/bc554143fcca768f52bf1354ffef92eb/xmlnote/3B9F8F27F2A049CD92C6C92BB1A35B19/2664?ynotemdtimestamp=1595666133983" alt></p><p>通过搜寻资料发现</p><p>请注意，docker镜像是基于alpine的，默认不提供bash。<br>所以脚本应该使用sh，以便更加通用。</p><p>改成如下格式后经过测试通过</p><pre><code>sh scripts/fmt.sh</code></pre><h2 id="curl命令未找到-【curl-not-found】"><a href="#curl命令未找到-【curl-not-found】" class="headerlink" title="curl命令未找到 【curl: not found】"></a>curl命令未找到 【curl: not found】</h2><p><img src="https://note.youdao.com/yws/public/resource/bc554143fcca768f52bf1354ffef92eb/xmlnote/24C3D0434AB147BC80AE067140047D01/2671?ynotemdtimestamp=1595666133983" alt></p><p>搜寻资料<a href="https://stackoverflow.com/questions/46031069/curl-command-not-found-on-gitlab-ci-yml" target="_blank" rel="noopener">curl command not found on .gitlab-ci.yml</a></p><p>使用apk命令下载 curl 命令，而不是 apt-get</p><pre><code>services:  - name: docker:dind  before_script:    - apk add --update curl &amp;&amp; rm -rf /var/cache/apk/*</code></pre><h2 id="编译报错-not-found"><a href="#编译报错-not-found" class="headerlink" title="编译报错 not found"></a>编译报错 not found</h2><p>参考<br><a href="https://www.dyxmq.cn/uncategorized/installed-go-binary-not-found-in-path-on-alpine-linux-docker.html" target="_blank" rel="noopener">https://www.dyxmq.cn/uncategorized/installed-go-binary-not-found-in-path-on-alpine-linux-docker.html</a></p><p>编译时添加参数CGO_ENABLED=0</p><pre><code>CGO_ENABLED=0 go build</code></pre><h2 id="安装-go-环境失败"><a href="#安装-go-环境失败" class="headerlink" title="安装 go 环境失败"></a>安装 go 环境失败</h2><p>下载了 go 的安装包且配置好了 GOROOT 和 GOPATH 等，但执行 go version 依旧报错</p><p><img src="https://note.youdao.com/yws/public/resource/bc554143fcca768f52bf1354ffef92eb/xmlnote/F3FF604F026B45F38A44D48691D10B37/2694?ynotemdtimestamp=1595666133983" alt></p><p>查找资料<br><a href="https://stackoverflow.com/questions/34729748/installed-go-binary-not-found-in-path-on-alpine-linux-docker" target="_blank" rel="noopener">https://stackoverflow.com/questions/34729748/installed-go-binary-not-found-in-path-on-alpine-linux-docker</a></p><p>执行以下命令修复丢失的依赖项，解决</p><pre><code>mkdir /lib64 &amp;&amp; ln -s /lib/libc.musl-x86_64.so.1 /lib64/ld-linux-x86-64.so.2</code></pre><h2 id="执行-golangci-lint-run-报错：DecodeRuneInString-not-declared-by-package-utf8-typecheck"><a href="#执行-golangci-lint-run-报错：DecodeRuneInString-not-declared-by-package-utf8-typecheck" class="headerlink" title="执行 golangci-lint run 报错：DecodeRuneInString not declared by package utf8 (typecheck)"></a>执行 golangci-lint run 报错：DecodeRuneInString not declared by package utf8 (typecheck)</h2><p><a href="https://github.com/golangci/golangci-lint/issues/658" target="_blank" rel="noopener">https://github.com/golangci/golangci-lint/issues/658</a></p><p>替换 golangci-lint 版本由 v1.16.0 为 v1.18.0 解决问题</p><h2 id="跑-golangci-lint-报错【could-not-import-C-no-metadata-for-C-typecheck-】"><a href="#跑-golangci-lint-报错【could-not-import-C-no-metadata-for-C-typecheck-】" class="headerlink" title="跑 golangci-lint 报错【could not import C (no metadata for C) (typecheck)】"></a>跑 golangci-lint 报错【could not import C (no metadata for C) (typecheck)】</h2><p><img src="https://note.youdao.com/yws/public/resource/bc554143fcca768f52bf1354ffef92eb/xmlnote/7617F64AB4A84C01813E6514C27128CB/2882?ynotemdtimestamp=1595666133983" alt></p><p>搜索资料</p><p><a href="https://github.com/golangci/golangci-lint/issues/602" target="_blank" rel="noopener">https://github.com/golangci/golangci-lint/issues/602</a></p><p>需要安装 gcc，但由于 alpine-linux 环境不支持 apt-get 命令，只能用 apk 安装 gcc </p><p><a href="https://www.jianshu.com/p/30fa6448bb63" target="_blank" rel="noopener">https://www.jianshu.com/p/30fa6448bb63</a></p><p>alpine默认的安装源慢得要命</p><p>通过修改源加快安装速度</p><pre><code>echo &quot;https://mirror.tuna.tsinghua.edu.cn/alpine/v3.8/main&quot; &gt; /etc/apk/repositoriesecho &quot;https://mirror.tuna.tsinghua.edu.cn/alpine/v3.8/community&quot; &gt;&gt; /etc/apk/repositories</code></pre><p>然后再安装 gcc</p><pre><code>apk add build-base</code></pre><h2 id="跑-golangci-lint-遇到-【no-go-files-to-analyze】问题"><a href="#跑-golangci-lint-遇到-【no-go-files-to-analyze】问题" class="headerlink" title="跑 golangci-lint 遇到 【no go files to analyze】问题"></a>跑 golangci-lint 遇到 【no go files to analyze】问题</h2><p><img src="https://note.youdao.com/yws/public/resource/bc554143fcca768f52bf1354ffef92eb/xmlnote/B8CDA49BABF54CC093121CC9C0E92F51/2897?ynotemdtimestamp=1595666133983" alt></p><p>说明少了对应的包，需要去导入包</p><h1 id="gitlab-ci-yaml-样例"><a href="#gitlab-ci-yaml-样例" class="headerlink" title=".gitlab-ci.yaml 样例"></a>.gitlab-ci.yaml 样例</h1><pre><code>variables:  REGISTRY_USER: admin  REGISTRY_PASSWORD: yunphant  REGISTRY_ADDR: 192.168.9.8:80  TARGET_IMAGE: $REGISTRY_ADDR/$ORG_DIR/$PROJECT_DIR:latest  GOROOT: /home/centos/go  GOPATH: /home/centos/gopath  ORG_DIR: crosschain  PROJECT_DIR: crossnetbefore_script:#  - echo &quot;更换源&quot;  - echo &quot;https://mirror.tuna.tsinghua.edu.cn/alpine/v3.8/main&quot; &gt; /etc/apk/repositories  - echo &quot;https://mirror.tuna.tsinghua.edu.cn/alpine/v3.8/community&quot; &gt;&gt; /etc/apk/repositories#  - echo &quot;安装go环境&quot;  - mkdir -p $GOROOT  - mkdir -p $GOPATH  - tar -C /home/centos -zxvf ./util/go1.13.4.linux-amd64.tar.gz  - touch .bash_profile  - echo &#39;export GOROOT=/home/centos/go&#39;&gt;&gt;.bash_profile  - echo &#39;export GOPATH=/home/centos/gopath&#39;&gt;&gt;.bash_profile  - echo &#39;export PATH=$PATH:$GOPATH:$GOROOT/bin&#39;&gt;&gt;.bash_profile  - source .bash_profile#  - echo &quot;修复丢失的依赖项&quot;  - mkdir /lib64 &amp;&amp; ln -s /lib/libc.musl-x86_64.so.1 /lib64/ld-linux-x86-64.so.2  - go version#  - echo &quot;go环境安装完成&quot;#  - echo &quot;安装beego环境&quot;  - mkdir -p $GOPATH/src/github.com  - tar -xvf ./util/astaxie.tar.gz -C $GOPATH/src/github.com  - tar -xvf ./util/bee_1.10.0_linux_amd64.tar.gz#  - echo &quot;beego环境安装完成&quot;#  - echo &quot;设置工作目录&quot;  - WORK_DIR=&quot;$GOPATH/src/$ORG_DIR&quot;  - mkdir -p $WORK_DIR#  - echo &quot;将工作目录链接到当前目录&quot;  - ln -sfv &quot;$(pwd -P)&quot; &quot;$WORK_DIR&quot;#  - echo &quot;进入工作目录&quot;  - cd &quot;$WORK_DIR/$PROJECT_DIR&quot;stages:  - build  - lint  - test  - build_image  - push_image  - deploybuild:  stage: build  script:#    - echo &quot;构建项目&quot;    - CGO_ENABLED=0 go build#    - echo &quot;构建完成&quot;  allow_failure: truelint:  stage: lint  script:    #安装gcc    - apk update &amp;&amp; apk add gcc g++#    - echo &quot;安装 goalangci-lint 工具&quot;    - tar zxvf ./util/golangci-lint-1.18.0-linux-amd64.tar.gz -C /tmp/ &amp;&amp; cp  /tmp/golangci-lint-1.18.0-linux-amd64/golangci-lint $GOPATH/golangci-lint    - rm -rf /tmp/golangci-lint-1.18.0-linux-amd64 &amp;&amp; rm -rf /tmo/golangci-lint-1.18.0-linux-amd64.tar.gz#    - echo &quot;执行 golangci-lint 代码检查&quot;    - GL_DEBUG=linters_output GOPACKAGESPRINTGOLISTERRORS=1 golangci-lint run#    - echo &quot;golangci-lint 代码检查完成&quot;  allow_failure: truetest:  stage: test  script:    #安装gcc    - apk update &amp;&amp; apk add gcc g++#    - echo &quot;运行单元测试&quot;    - CGO_LDFLAGS_ALLOW=.* CGO_CFLAGS_ALLOW=.* go test ./... -v#    - echo &quot;单元测试通过&quot;  allow_failure: truebuild_image:  stage: build_image  script:#    - echo &quot;构建镜像&quot;    - docker build -t $TARGET_IMAGE .#    - echo &quot;镜像构建完成&quot;  allow_failure: truepush_image:  stage: push_image  script:#    - echo &quot;推送镜像到镜像仓库&quot;    - docker login -u $REGISTRY_USER -p $REGISTRY_PASSWORD $REGISTRY_ADDR    - docker push $TARGET_IMAGE#    - echo &quot;镜像推送完成&quot;  allow_failure: truedeploy:  stage: deploy  script:#    - echo &quot;开始部署&quot;#    - echo &quot;删除原有容器&quot;    - docker stop $CI_PROJECT_NAME    - docker rm $CI_PROJECT_NAME#    - echo &quot;启动容器&quot;    - docker run --name $CI_PROJECT_NAME -p 8080:8080  -v /home/centos/gopath/src/$ORG_DIR/$CI_PROJECT_NAME:/var/ $TARGET_IMAGE#    - echo &quot;部署成功&quot;  allow_failure: true</code></pre><h1 id="Dockerfile-样例"><a href="#Dockerfile-样例" class="headerlink" title="Dockerfile 样例"></a>Dockerfile 样例</h1><pre><code># 使用Go的官方镜像作为基础镜像FROM golang:1.12-alpineMAINTAINER xiongweigang xiongwg@yunphant.com# 设置环境变量ENV GOROOT=/usr/local/goENV GOPATH $HOME/goENV PATH $PATH:$GOPATH/binENV GOPROXY https://goproxy.cn,direct# 设置工作目录RUN mkdir -p /go/src/crosschain/crossnetRUN mkdir -p /go/src/github.comWORKDIR /go/src/crosschain/crossnet# 拷贝Dockerfile同级目录的所有文件到docker中的指定位置ADD ./ /go/src/crosschain/crossnet# 拷贝bee可执行命令到docker中的指定位置COPY ./bee_1.10.0_linux_amd64/bee /usr/local/go/bin/COPY ./bee_1.10.0_linux_amd64/bee $GOPATH/bin/# 安装beego源码RUN tar -xvf ./util/astaxie.tar.gz -C /go/src/github.com# 通过开放容器的8080端口暴露该应用程序EXPOSE 8080# 使用bee命令开始对应用程序进行实时重载CMD [&quot;bee&quot;, &quot;run&quot;]</code></pre><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://www.infoq.cn/article/WHt0wFMDRrBU-dtkh1Xp" target="_blank" rel="noopener">如何从零开始搭建 CI/CD 流水线</a></li><li><a href="https://docs.gitlab.com/ee/ci/" target="_blank" rel="noopener">GitLab CI/CD官方文档</a></li><li><a href="https://developer.aliyun.com/article/754508" target="_blank" rel="noopener">GitLab+Docker搭建CI/CD自动化部署</a></li><li><a href="https://www.cnblogs.com/jingtyu/p/9604317.html" target="_blank" rel="noopener">自动化部署方案CICD</a></li><li><a href="https://zhuanlan.zhihu.com/p/51163261" target="_blank" rel="noopener">Gitlab CI&amp;CD 实战经验分享</a></li><li><a href="https://blinkfox.github.io/2018/11/22/ruan-jian-gong-ju/devops/gitlab-ci-jie-shao-he-shi-yong/#alipay" target="_blank" rel="noopener">GitLab CI/CD 介绍和使用</a></li><li><a href="https://blog.csdn.net/qq_33591903/article/details/102460774" target="_blank" rel="noopener">浅谈CICD持续集成、持续部署的流程</a></li><li><a href="https://www.jianshu.com/p/30e3f2940078" target="_blank" rel="noopener">gitlab-ci的简易入门——runners</a></li><li><a href="https://juejin.im/post/5e741a5a518825490e4582b7" target="_blank" rel="noopener">GitLab CI/CD 自动部署构建</a></li><li><a href="https://cloud.tencent.com/developer/article/1411267" target="_blank" rel="noopener">Gitlab的第一个shared Runners配置(shared类型)</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> GitLab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GitLab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fabric国密改造全记录</title>
      <link href="/2020/06/29/fabric-gm/"/>
      <url>/2020/06/29/fabric-gm/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><blockquote><p>最近应公司项目需求，需要对fabric中的加密相关模块进行改造，主要目的是使fabric底层加密服务支持国密算法sm2、sm3以及sm4等。借这次机会，顺便熟悉一下fabric加密模块的源码实现，故此处简单记录了国密改造的整个过程。</p></blockquote><p>fabric tag: 1.4.1</p><h1 id="国密改造整体方案"><a href="#国密改造整体方案" class="headerlink" title="国密改造整体方案"></a>国密改造整体方案</h1><p>msp是基于数字证书的成员身份管理，会调用bccsp即证书服务完成签名验签等功能。Fabric提供国密算法服务，需要同时使用基于国密的数字证书服务，以便使用数字证书时，能验证国密的数字签名，辨别用户身份。</p><p>bccsp模块对上层抽象出了区块链密码服务，包含非对称加密、对称加密、数字签名算法、摘要计算，以及各种算法对于的密钥生成和导入。不同的加密算法需要实现bccsp中定义的接口，以向上层提供加密服务。目前，bccsp中支持标准加密的软实现和标准加密的硬实现。提供国密算法服务，就需要国密算法实现，实现bccsp模块中定义的接口。</p><p>设计gm接口实现国密库的可插拔，实现使用不同的国密库的目的，利用gm接口实现bccsp中的国密插件，在底层国密库更换时，国密插件和Fabric上层模块无需修改。</p><p>为每一个国密实现都进行一次封装，形成各自的gm adapter，满足gm接口。国密实现可以是C语言的动态链接库，可以是Go语言模块，甚至可以是基于加密机提供的RPC加密服务接口。</p><p>设计证书接口实现证书库的可插拔，实现使用不同证书库的目的。利用证书接口实现证书操作函数，fabric中所有证书操作，都调用封装的证书函数，在使用不同证书库时，fabric上层模块无需再适配证书库。</p><p>为每一个证书库都进行一次封装，形成各自的x509 cert adapter，为了让Fabric同时支持国密和标准加密，需要封装Go标准库中的证书操作，以及国密证书库，形成2个不同的插件。</p><h2 id="准备工作："><a href="#准备工作：" class="headerlink" title="准备工作："></a>准备工作：</h2><p>确定 base 分支</p><p>熟悉底层加密实现库</p><ol><li>C 语言的动态链接库</li><li>Go 语言实现</li><li>加密机提供的RPC加密服务接口</li></ol><h2 id="模块拆分"><a href="#模块拆分" class="headerlink" title="模块拆分"></a>模块拆分</h2><p>先来总体看一下fabric进行国密改造会涉及到的主要模块</p><p><img src="http://qlkvpxmsx.hd-bkt.clouddn.com/%E5%9B%BD%E5%AF%86%E6%94%B9%E9%80%A0.png" alt></p><p>如图所示，从上往下，首先是上层调用模块，这一块主要是msp等模块，为fabric提供成员加密服务，它的实现依赖于BCCSP模块和X509模块。</p><p>我们先看右边，BCCSP模块主要是实现四套接口，分别是BCCSP接口、opts接口、key接口以及keystore接口，其中以BCCSP接口为主，它包含了加解密、签名验签等主要方法，其他三套接口为辅，主要包含了用于密钥管理和存储的一些方法。</p><p>接着往下，BCCSP模块有两套实现，一套是标准加密，它直接依赖于Go SDK原生的加密库，另一套是国密实现，需要依赖于第三方的提供的底层加密库，分为硬实现和软实现，其中硬实现就是加密机，软实现现在主要有G语言实现和C语言动态链接库实现两种。</p><p>考虑到fabric定义的BCCSP接口并不直接兼容于第三方提供的加密接口，因此需要做一个国密适配器，主要用于适配上层的BCCSP模块和底层的第三方加密库，这个国密适配器主要包含了SM2、SM3以及SM4三种国密算法的适配。</p><p>然后我们看一下左边，X509模块主要提供的是有关证书的一系列方法。在这里fabric原先默认是使用标准X509的，底层直接调用的是Go SDK 原生的加密库。为了让X509支持国密的同时也兼容标准加密，这里我们就把证书相关的接口抽象出来，定义为X509接口。然后底层采用两套实现，标准加密和非国密实现，标准加密依旧是直接调用原生Go SDK标准加密库，而国密则是调用第三方的国密库。</p><p>需要说明的是，在调用BCCSP模块的加密服务时，如果选择国密算法，需要加载一个国密的插件，而如果是标准加密，则不需要加密国密插件；在调用X509模块的证书服务时，不管是国密X509证书还是标准X509证书均需要加密X509插件。具体选择国密还是标准加密算法可通在orderer、peer和cli的配置文件中的配置项进行指定。</p><h2 id="方法和接口一览"><a href="#方法和接口一览" class="headerlink" title="方法和接口一览"></a>方法和接口一览</h2><p>上面已经把fabirc国密改造整体涉及到的模块简单介绍了一下，下面我通过们一张图来看一下这些模块具体涉及到的接口和方法以及代码的调用逻辑等。</p><p><img src="http://qlkvpxmsx.hd-bkt.clouddn.com/fabric%20%E5%9B%BD%E5%AF%86%E6%94%B9%E9%80%A0.png" alt></p><h5 id="高清大图请戳这里"><a href="#高清大图请戳这里" class="headerlink" title="高清大图请戳这里"></a>高清大图请戳<a href="http://www.xmind.net/m/AimcSi" target="_blank" rel="noopener">这里</a></h5><h1 id="fabric-ca-国密改造"><a href="#fabric-ca-国密改造" class="headerlink" title="fabric ca 国密改造"></a>fabric ca 国密改造</h1><p>Fabric-ca国密支持改造，主要是指Fabric-ca端通过改造使其可以用以生成国密公私钥对、签发、吊销、查询国密类型的证书。证书申请和签发的流程如下图所示，所有改造工作都围绕证书申请和签发的流程展开的：</p><p><img src="https://note.youdao.com/yws/public/resource/bc554143fcca768f52bf1354ffef92eb/xmlnote/E0AD1345011E4AA194EDAB95D1A4DAE3/2719?ynotemdtimestamp=1595668120966" alt></p><p>Fabric-ca主要是调用Fabric的bccsp(blockchain cryptographic service provider,区块链加密服务提供者)模块来完成加解密及签名验签的工作。</p><p>Fabric-ca client端主要负责国密证书的请求签发以及存储国密证书链的工作。对于请求国密证书，client端首先生成国密的公私钥对，并把公钥编码到生成证书的请求中，发送生成国密证书的请求给Fabric-ca的server端。存储国密的证书链则需要使用支持国密适配的x509来解析证书，并写入到client端本地路径中。</p><p>Fabric-ca server端主要负责国密证书的签发、吊销、查询等功能。启动时加载自身的国密证书。在接收到签发请求时，调用国密的签名方法来对证书请求进行签名，并返回国密证书给client端。</p><h2 id="改造要点："><a href="#改造要点：" class="headerlink" title="改造要点："></a>改造要点：</h2><ol><li>Fabric-ca/lib：主要是接口的实现，主要在解析申请证书请求以及签发证书流程要替换为国密算法；</li><li>Fabric-ca/util：该包数据工具类，主要在证书的编解码等操作中扩展国密算法；</li><li>Fabric-ca/vendor：因为CA沿用Fabric中的BCCSP套件，所以需要替换对Fabric的包的引用，提供对国密算法的支持。</li></ol><h2 id="具体接口和方法一览"><a href="#具体接口和方法一览" class="headerlink" title="具体接口和方法一览"></a>具体接口和方法一览</h2><p><img src="http://qlkvpxmsx.hd-bkt.clouddn.com/fabric%20ca%20%E5%9B%BD%E5%AF%86%E6%94%B9%E9%80%A0.png" alt></p><h5 id="高清大图请戳这里-1"><a href="#高清大图请戳这里-1" class="headerlink" title="高清大图请戳这里"></a>高清大图请戳<a href="http://www.xmind.net/m/DpWJni" target="_blank" rel="noopener">这里</a></h5><h1 id="fabric-sdk-国密改造"><a href="#fabric-sdk-国密改造" class="headerlink" title="fabric sdk 国密改造"></a>fabric sdk 国密改造</h1><p>关于README可以参考<a href="https://github.com/hyperledger/fabric-sdk-go/blob/master/README.md" target="_blank" rel="noopener">此处</a></p><p>不过我觉得意义不大，无非是怎么下载下来这个项目，然后跑一下测试</p><p>因此我又自己写了个使用说明文档，可以参考<a href="http://note.youdao.com/s/Fu554jj4" target="_blank" rel="noopener">此处</a></p><p>在改造 SDK 之前，我们先来看一下SDK的目录结构</p><h2 id="2-SDK项目介绍"><a href="#2-SDK项目介绍" class="headerlink" title="2. SDK项目介绍"></a>2. SDK项目介绍</h2><p>首先介绍一下sdk项目的架构。</p><pre><code>├── internal├── pkg├── scripts├── test└── third_party</code></pre><p>其中internal和third_party包含fabric相关核心代码。pkg为sdk核心代码，对外提供接口进行服务。</p><p>internal文件夹</p><pre><code>└── github.com└── github.com    └── hyperledger        ├── fabric        │   ├── bccsp        │   ├── common        │   ├── core        │   ├── discovery        │   ├── gossip        │   ├── msp        │   ├── protoutil        │   ├── sdkinternal        │   └── sdkpatch        └── fabric-ca            ├── api            ├── lib            ├── sdkpatch            └── util</code></pre><p>third_party文件夹：</p><pre><code>└── github.com└── github.com    └── hyperledger        └── fabric            ├── common            ├── core            └── internal</code></pre><p>大概就是这样，废话不多说，直接开始改吧</p><p>添加国密底层实现库 mod</p><p>添加国密插件和X509插件</p><p>添加gmfactory及相关接口</p><p>定义公私钥基础类型并替换原有的公私钥</p><p>将原生的 X509 库替换为自定义的 x509 库</p><p>2.x 不再支持RSA、去掉了插件plugin实现方式</p><p>添加一个orderer字段，用于指定orderer配置</p><p>未完待续……</p>]]></content>
      
      
      <categories>
          
          <category> fabric </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fabric </tag>
            
            <tag> 密码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GoLand 类图生成工具 plantuml</title>
      <link href="/2020/06/29/plantuml/"/>
      <url>/2020/06/29/plantuml/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文介绍了如何使用 plantuml 工具自动生成Go项目的类图</p></blockquote><h2 id="克隆项目"><a href="#克隆项目" class="headerlink" title="克隆项目"></a>克隆项目</h2><p>在gopath路径下</p><pre><code>git clone git.oschina.net/jscode/go-package-plantuml</code></pre><h2 id="进入项目"><a href="#进入项目" class="headerlink" title="进入项目"></a>进入项目</h2><pre><code>go build</code></pre><p>在 GOPATH/bin 生成一个 二进制文件 plantuml</p><h2 id="用GoLand打开项目，终端输入生成类图命令"><a href="#用GoLand打开项目，终端输入生成类图命令" class="headerlink" title="用GoLand打开项目，终端输入生成类图命令"></a>用GoLand打开项目，终端输入生成类图命令</h2><pre><code>~/go/bin/go-package-plantuml --codedir /Users/xiongweigang/go/src/github.com/wasabi/backEnd --gopath /Users/xiongweigang/go --outputfile /tmp/uml.txt --ignoredir /Users/xiongweigang/go/src/github.com/wasabi/backEnd/vendor</code></pre><h2 id="生成png图片"><a href="#生成png图片" class="headerlink" title="生成png图片"></a>生成png图片</h2><pre><code>java -jar ～/plantuml.jar -verbose -graphvizdot /usr/local/bin/dot /tmp/uml.txt</code></pre><h2 id="生成svg图片-后边加上-tsvg"><a href="#生成svg图片-后边加上-tsvg" class="headerlink" title="生成svg图片 后边加上 -tsvg"></a>生成svg图片 后边加上 -tsvg</h2><pre><code>java -jar ～/plantuml.jar -verbose -graphvizdot /usr/local/bin/dot /tmp/uml.txt -tsvg</code></pre><p>生成后用浏览器打开</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/dwjpeng2/article/details/81667214" target="_blank" rel="noopener">https://blog.csdn.net/dwjpeng2/article/details/81667214</a></p><p><a href="https://yougg.github.io/2017/11/25/goland%E4%B8%AD%E4%BD%BF%E7%94%A8plantuml%E7%94%9F%E6%88%90go-uml%E5%9B%BE/" target="_blank" rel="noopener">https://yougg.github.io/2017/11/25/goland%E4%B8%AD%E4%BD%BF%E7%94%A8plantuml%E7%94%9F%E6%88%90go-uml%E5%9B%BE/</a></p><p><a href="https://juejin.im/post/5da9c00de51d4524cd3b3942" target="_blank" rel="noopener">https://juejin.im/post/5da9c00de51d4524cd3b3942</a></p><p><a href="https://studygolang.com/articles/9719" target="_blank" rel="noopener">https://studygolang.com/articles/9719</a></p>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fabric多机部署（raft共识）</title>
      <link href="/2020/06/21/fabric-deploy-raft/"/>
      <url>/2020/06/21/fabric-deploy-raft/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文介绍了如何搭建一个多机多节点的fabric区块链网络的过程，希望能为小伙伴提供帮助。</p></blockquote><h1 id="fabric多机部署-（raft共识）"><a href="#fabric多机部署-（raft共识）" class="headerlink" title="fabric多机部署 （raft共识）"></a>fabric多机部署 （raft共识）</h1><h2 id="0-准备工作"><a href="#0-准备工作" class="headerlink" title="0. 准备工作"></a>0. 准备工作</h2><h4 id="克隆项目"><a href="#克隆项目" class="headerlink" title="克隆项目"></a>克隆项目</h4><pre><code>git clone git@192.168.9.251:jilg/deployFabric_Raft.git</code></pre><h4 id="节点分配"><a href="#节点分配" class="headerlink" title="节点分配"></a>节点分配</h4><table><thead><tr><th>主机1</th><th>主机 2</th></tr></thead><tbody><tr><td>Org1 peer0 1</td><td>Org2 peer 0 1</td></tr><tr><td>Orderer 0 1 2</td><td>Orderer 0 1</td></tr></tbody></table><br>下面的步骤先在一台主机上操作<h2 id="1-修改证书，创始区块配置文件"><a href="#1-修改证书，创始区块配置文件" class="headerlink" title="1. 修改证书，创始区块配置文件"></a>1. 修改证书，创始区块配置文件</h2><p>先删除原有配置</p><pre><code>rm -rf crypto-configrm -rf channel-artifacts</code></pre><h4 id="crypto-config-yaml"><a href="#crypto-config-yaml" class="headerlink" title="crypto-config.yaml"></a>crypto-config.yaml</h4><pre><code>PeerOrgs:  - Name: Org1    Domain: org1.example.com    EnableNodeOUs: true    Template:      Count: 2    Users:      Count: 1    Specs:      - Hostname: orderer0      - Hostname: orderer1      - Hostname: orderer2  - Name: Org2    Domain: org2.example.com    EnableNodeOUs: true    Template:      Count: 2    Users:      Count: 1    Specs:      - Hostname: orderer0      - Hostname: orderer1</code></pre><h4 id="configtx-yaml"><a href="#configtx-yaml" class="headerlink" title="configtx.yaml"></a>configtx.yaml</h4><pre><code>SampleMultiNodeEtcdRaft:        &lt;&lt;: *ChannelDefaults        Capabilities:            &lt;&lt;: *ChannelCapabilities        Orderer:            &lt;&lt;: *OrdererDefaults            OrdererType: etcdraft            EtcdRaft:                Consenters:                - Host: orderer0.org1.example.com                  Port: 7050                  ClientTLSCert: crypto-config/peerOrganizations/org1.example.com/peers/orderer0.org1.example.com/tls/server.crt                  ServerTLSCert: crypto-config/peerOrganizations/org1.example.com/peers/orderer0.org1.example.com/tls/server.crt                - Host: orderer1.org1.example.com                  Port: 8050                  ClientTLSCert: crypto-config/peerOrganizations/org1.example.com/peers/orderer1.org1.example.com/tls/server.crt                  ServerTLSCert: crypto-config/peerOrganizations/org1.example.com/peers/orderer1.org1.example.com/tls/server.crt                - Host: orderer2.org1.example.com                  Port: 9050                  ClientTLSCert: crypto-config/peerOrganizations/org1.example.com/peers/orderer2.org1.example.com/tls/server.crt                  ServerTLSCert: crypto-config/peerOrganizations/org1.example.com/peers/orderer2.org1.example.com/tls/server.crt                - Host: orderer0.org2.example.com                  Port: 7050                  ClientTLSCert: crypto-config/peerOrganizations/org2.example.com/peers/orderer0.org2.example.com/tls/server.crt                  ServerTLSCert: crypto-config/peerOrganizations/org2.example.com/peers/orderer0.org2.example.com/tls/server.crt                - Host: orderer1.org2.example.com                  Port: 8050                  ClientTLSCert: crypto-config/peerOrganizations/org2.example.com/peers/orderer1.org2.example.com/tls/server.crt                  ServerTLSCert: crypto-config/peerOrganizations/org2.example.com/peers/orderer1.org2.example.com/tls/server.crt            Addresses:                - orderer0.org1.example.com:7050                - orderer1.org1.example.com:8050                - orderer2.org1.example.com:9050                - orderer0.org2.example.com:7050                - orderer1.org2.example.com:8050            Organizations:            - *Org1            - *Org2            Capabilities:                &lt;&lt;: *OrdererCapabilities        Application:            &lt;&lt;: *ApplicationDefaults            Organizations:            - &lt;&lt;: *Org1            - &lt;&lt;: *Org2        Consortiums:            SampleConsortium:                Organizations:                - *Org1                - *Org2</code></pre><p>1、生成公私钥和证书</p><pre><code>../bin/cryptogen generate --config=./crypto-config.yaml </code></pre><p>2、生成创世区块</p><pre><code>../bin/configtxgen -profile SampleMultiNodeEtcdRaft -outputBlock ./channel-artifacts/genesis.block</code></pre><p>3、生成Channel配置区块</p><pre><code>../bin/configtxgen -profile TwoOrgsChannel -outputCreateChannelTx ./channel-artifacts/channel.tx -channelID mychannel </code></pre><p>4、更新锚节点</p><pre><code>../bin/configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org1MSPanchors.tx -channelID mychannel -asOrg Org1MSP../bin/configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org2MSPanchors.tx -channelID mychannel -asOrg Org2MSP</code></pre><h2 id="3-修改peer配置"><a href="#3-修改peer配置" class="headerlink" title="3. 修改peer配置"></a>3. 修改peer配置</h2><h4 id="docker-compose-base-yaml"><a href="#docker-compose-base-yaml" class="headerlink" title="docker-compose-base.yaml"></a>docker-compose-base.yaml</h4><pre><code># Copyright IBM Corp. All Rights Reserved.## SPDX-License-Identifier: Apache-2.0#version: &#39;2&#39;services:  orderer.example.com:    container_name: orderer.example.com    extends:      file: peer-base.yaml      service: orderer-base    volumes:        - ../channel-artifacts/genesis.block:/var/hyperledger/orderer/orderer.genesis.block        - ../crypto-config/ordererOrganizations/example.com/orderers/orderer.example.com/msp:/var/hyperledger/orderer/msp        - ../crypto-config/ordererOrganizations/example.com/orderers/orderer.example.com/tls/:/var/hyperledger/orderer/tls    ports:      - 7050:7050  peer0.org1.example.com:    container_name: peer0.org1.example.com    extends:      file: peer-base.yaml      service: peer-base    environment:      - CORE_PEER_ID=peer0.org1.example.com      - CORE_PEER_ADDRESS=peer0.org1.example.com:7051      - CORE_PEER_LISTENADDRESS=0.0.0.0:7051      - CORE_PEER_CHAINCODEADDRESS=peer0.org1.example.com:7052      - CORE_PEER_CHAINCODELISTENADDRESS=0.0.0.0:7052      - CORE_PEER_GOSSIP_BOOTSTRAP=peer1.org1.example.com:8051      - CORE_PEER_GOSSIP_EXTERNALENDPOINT=peer0.org1.example.com:7051      - CORE_PEER_LOCALMSPID=Org1MSP      - CORE_PEER_ENBLKROUTER=true    volumes:        - /var/run/:/host/var/run/        - ../crypto-config/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/msp:/etc/hyperledger/fabric/msp        - ../crypto-config/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls:/etc/hyperledger/fabric/tls        - peer0.org1.example.com:/var/hyperledger/production    ports:      - 7051:7051      - 9099:9099  peer1.org1.example.com:    container_name: peer1.org1.example.com    extends:      file: peer-base.yaml      service: peer-base    environment:      - CORE_PEER_ID=peer1.org1.example.com      - CORE_PEER_ADDRESS=peer1.org1.example.com:8051      - CORE_PEER_LISTENADDRESS=0.0.0.0:8051      - CORE_PEER_CHAINCODEADDRESS=peer1.org1.example.com:8052      - CORE_PEER_CHAINCODELISTENADDRESS=0.0.0.0:8052      - CORE_PEER_GOSSIP_EXTERNALENDPOINT=peer1.org1.example.com:8051      - CORE_PEER_GOSSIP_BOOTSTRAP=peer0.org1.example.com:7051      - CORE_PEER_LOCALMSPID=Org1MSP      - CORE_PEER_ENBLKROUTER=true    volumes:        - /var/run/:/host/var/run/        - ../crypto-config/peerOrganizations/org1.example.com/peers/peer1.org1.example.com/msp:/etc/hyperledger/fabric/msp        - ../crypto-config/peerOrganizations/org1.example.com/peers/peer1.org1.example.com/tls:/etc/hyperledger/fabric/tls        - peer1.org1.example.com:/var/hyperledger/production    ports:      - 8051:8051      - 10099:9099  peer0.org2.example.com:    container_name: peer0.org2.example.com    extends:      file: peer-base.yaml      service: peer-base    environment:      - CORE_PEER_ID=peer0.org2.example.com      - CORE_PEER_ADDRESS=peer0.org2.example.com:9051      - CORE_PEER_LISTENADDRESS=0.0.0.0:9051      - CORE_PEER_CHAINCODEADDRESS=peer0.org2.example.com:9052      - CORE_PEER_CHAINCODELISTENADDRESS=0.0.0.0:9052      - CORE_PEER_GOSSIP_EXTERNALENDPOINT=peer0.org2.example.com:9051      - CORE_PEER_GOSSIP_BOOTSTRAP=peer1.org2.example.com:10051      - CORE_PEER_LOCALMSPID=Org2MSP      - CORE_PEER_ENBLKROUTER=true    volumes:        - /var/run/:/host/var/run/        - ../crypto-config/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/msp:/etc/hyperledger/fabric/msp        - ../crypto-config/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls:/etc/hyperledger/fabric/tls        - peer0.org2.example.com:/var/hyperledger/production    ports:      - 9051:9051      - 9099:9099  peer1.org2.example.com:    container_name: peer1.org2.example.com    extends:      file: peer-base.yaml      service: peer-base    environment:      - CORE_PEER_ID=peer1.org2.example.com      - CORE_PEER_ADDRESS=peer1.org2.example.com:10051      - CORE_PEER_LISTENADDRESS=0.0.0.0:10051      - CORE_PEER_CHAINCODEADDRESS=peer1.org2.example.com:10052      - CORE_PEER_CHAINCODELISTENADDRESS=0.0.0.0:10052      - CORE_PEER_GOSSIP_EXTERNALENDPOINT=peer1.org2.example.com:10051      - CORE_PEER_GOSSIP_BOOTSTRAP=peer0.org2.example.com:9051      - CORE_PEER_LOCALMSPID=Org2MSP      - CORE_PEER_ENBLKROUTER=true    volumes:        - /var/run/:/host/var/run/        - ../crypto-config/peerOrganizations/org2.example.com/peers/peer1.org2.example.com/msp:/etc/hyperledger/fabric/msp        - ../crypto-config/peerOrganizations/org2.example.com/peers/peer1.org2.example.com/tls:/etc/hyperledger/fabric/tls        - peer1.org2.example.com:/var/hyperledger/production    ports:      - 10051:10051      - 10099:9099</code></pre><h2 id="4-修改组织1配置"><a href="#4-修改组织1配置" class="headerlink" title="4. 修改组织1配置"></a>4. 修改组织1配置</h2><h4 id="docker-compose-org1-35-yaml"><a href="#docker-compose-org1-35-yaml" class="headerlink" title="docker-compose-org1-35.yaml"></a>docker-compose-org1-35.yaml</h4><pre><code>version: &#39;2&#39;volumes:  orderer0.org1.example.com:  orderer1.org1.example.com:  orderer2.org1.example.com:  peer0.org1.example.com:  peer1.org1.example.com:networks:  byfn:services:  orderer0.org1.example.com:    environment:      - ORDERER_GENERAL_LOCALMSPID=Org1MSP    extends:      file: base/peer-base.yaml      service: orderer-base    container_name: orderer0.org1.example.com    networks:      - byfn    volumes:      - ./channel-artifacts/genesis.block:/var/hyperledger/orderer/orderer.genesis.block      - ./crypto-config/peerOrganizations/org1.example.com/peers/orderer0.org1.example.com/msp:/var/hyperledger/orderer/msp      - ./crypto-config/peerOrganizations/org1.example.com/peers/orderer0.org1.example.com/tls/:/var/hyperledger/orderer/tls      - orderer0.org1.example.com:/var/hyperledger/production/orderer    ports:      - 7050:7050    extra_hosts:      - orderer0.org1.example.com:192.168.9.35      - orderer1.org1.example.com:192.168.9.35      - orderer2.org1.example.com:192.168.9.35      - orderer0.org2.example.com:192.168.9.28      - orderer1.org2.example.com:192.168.9.28  orderer1.org1.example.com:    environment:      - ORDERER_GENERAL_LOCALMSPID=Org1MSP    extends:      file: base/peer-base.yaml      service: orderer-base    container_name: orderer1.org1.example.com    networks:      - byfn    volumes:      - ./channel-artifacts/genesis.block:/var/hyperledger/orderer/orderer.genesis.block      - ./crypto-config/peerOrganizations/org1.example.com/peers/orderer1.org1.example.com/msp:/var/hyperledger/orderer/msp      - ./crypto-config/peerOrganizations/org1.example.com/peers/orderer1.org1.example.com/tls/:/var/hyperledger/orderer/tls      - orderer1.org1.example.com:/var/hyperledger/production/orderer    ports:      - 8050:7050    extra_hosts:      - orderer0.org1.example.com:192.168.9.35      - orderer1.org1.example.com:192.168.9.35      - orderer2.org1.example.com:192.168.9.35      - orderer0.org2.example.com:192.168.9.28      - orderer1.org2.example.com:192.168.9.28  orderer2.org1.example.com:    environment:      - ORDERER_GENERAL_LOCALMSPID=Org1MSP    extends:      file: base/peer-base.yaml      service: orderer-base    container_name: orderer2.org1.example.com    networks:      - byfn    volumes:      - ./channel-artifacts/genesis.block:/var/hyperledger/orderer/orderer.genesis.block      - ./crypto-config/peerOrganizations/org1.example.com/peers/orderer2.org1.example.com/msp:/var/hyperledger/orderer/msp      - ./crypto-config/peerOrganizations/org1.example.com/peers/orderer2.org1.example.com/tls/:/var/hyperledger/orderer/tls      - orderer2.org1.example.com:/var/hyperledger/production/orderer    ports:      - 9050:7050    extra_hosts:      - orderer0.org1.example.com:192.168.9.35      - orderer1.org1.example.com:192.168.9.35      - orderer2.org1.example.com:192.168.9.35      - orderer0.org2.example.com:192.168.9.28      - orderer1.org2.example.com:192.168.9.28  peer0.org1.example.com:    container_name: peer0.org1.example.com    extends:      file:  base/docker-compose-base.yaml      service: peer0.org1.example.com    networks:      - byfn    extra_hosts:      - orderer0.org1.example.com:192.168.9.35      - orderer1.org1.example.com:192.168.9.35      - orderer2.org1.example.com:192.168.9.35      - orderer0.org2.example.com:192.168.9.28      - orderer1.org2.example.com:192.168.9.28  peer1.org1.example.com:    container_name: peer1.org1.example.com    extends:      file:  base/docker-compose-base.yaml      service: peer1.org1.example.com    networks:      - byfn    extra_hosts:      - orderer0.org1.example.com:192.168.9.35      - orderer1.org1.example.com:192.168.9.35      - orderer2.org1.example.com:192.168.9.35      - orderer0.org2.example.com:192.168.9.28      - orderer1.org2.example.com:192.168.9.28  cli:    container_name: cli    image: 192.168.9.8:80/fabric1.4performance/hyperledger/fabric-tools:sles12sp3-latest    tty: true    stdin_open: true    environment:      - GOPATH=/opt/gopath      - CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock      #- FABRIC_LOGGING_SPEC=DEBUG      - FABRIC_LOGGING_SPEC=INFO      - CORE_PEER_BCCSP_DEFAULT=GM      - CORE_PEER_ID=cli      - CORE_PEER_ADDRESS=peer0.org1.example.com:7051      - CORE_PEER_LOCALMSPID=Org1MSP      - CORE_PEER_TLS_ENABLED=true      - CORE_PEER_TLS_CERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/server.crt      - CORE_PEER_TLS_KEY_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/server.key      - CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt      - CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp    working_dir: /opt/gopath/src/github.com/hyperledger/fabric/peer    command: /bin/bash    volumes:      - /var/run/:/host/var/run/      - ./../chaincode/:/opt/gopath/src/github.com/chaincode      - ./../unionbank/:/opt/gopath/src/unionbank      - ./crypto-config:/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/      - ./scripts:/opt/gopath/src/github.com/hyperledger/fabric/peer/scripts/      - ./channel-artifacts:/opt/gopath/src/github.com/hyperledger/fabric/peer/channel-artifacts    extra_hosts:      - orderer0.org1.example.com:192.168.9.35      - orderer1.org1.example.com:192.168.9.35      - orderer2.org1.example.com:192.168.9.35      - orderer0.org2.example.com:192.168.9.28      - orderer1.org2.example.com:192.168.9.28      - peer0.org1.example.com:192.168.9.35      - peer1.org1.example.com:192.168.9.35      - peer0.org2.example.com:192.168.9.28      - peer1.org2.example.com:192.168.9.28    networks:      - byfn</code></pre><h2 id="5-修改组织2配置"><a href="#5-修改组织2配置" class="headerlink" title="5. 修改组织2配置"></a>5. 修改组织2配置</h2><h4 id="docker-compose-org2-28-yaml"><a href="#docker-compose-org2-28-yaml" class="headerlink" title="docker-compose-org2-28.yaml"></a>docker-compose-org2-28.yaml</h4><pre><code>version: &#39;2&#39;volumes:  orderer0.org2.example.com:  orderer1.org2.example.com:  peer0.org2.example.com:  peer1.org2.example.com:networks:  byfn:services:  orderer0.org2.example.com:    environment:      - ORDERER_GENERAL_LOCALMSPID=Org2MSP    extends:      file: base/peer-base.yaml      service: orderer-base    container_name: orderer0.org2.example.com    networks:      - byfn    volumes:      - ./channel-artifacts/genesis.block:/var/hyperledger/orderer/orderer.genesis.block      - ./crypto-config/peerOrganizations/org2.example.com/peers/orderer0.org2.example.com/msp:/var/hyperledger/orderer/msp      - ./crypto-config/peerOrganizations/org2.example.com/peers/orderer0.org2.example.com/tls/:/var/hyperledger/orderer/tls      - orderer0.org2.example.com:/var/hyperledger/production/orderer    ports:      - 7050:7050    extra_hosts:      - orderer0.org1.example.com:192.168.9.35      - orderer1.org1.example.com:192.168.9.35      - orderer2.org1.example.com:192.168.9.35      - orderer0.org2.example.com:192.168.9.28      - orderer1.org2.example.com:192.168.9.28  orderer1.org2.example.com:    environment:      - ORDERER_GENERAL_LOCALMSPID=Org2MSP    extends:      file: base/peer-base.yaml      service: orderer-base    container_name: orderer1.org2.example.com    networks:      - byfn    volumes:      - ./channel-artifacts/genesis.block:/var/hyperledger/orderer/orderer.genesis.block      - ./crypto-config/peerOrganizations/org2.example.com/peers/orderer1.org2.example.com/msp:/var/hyperledger/orderer/msp      - ./crypto-config/peerOrganizations/org2.example.com/peers/orderer1.org2.example.com/tls/:/var/hyperledger/orderer/tls      - orderer1.org2.example.com:/var/hyperledger/production/orderer    ports:      - 8050:7050    extra_hosts:      - orderer0.org1.example.com:192.168.9.35      - orderer1.org1.example.com:192.168.9.35      - orderer2.org1.example.com:192.168.9.35      - orderer0.org2.example.com:192.168.9.28      - orderer1.org2.example.com:192.168.9.28  peer0.org2.example.com:    container_name: peer0.org2.example.com    extends:      file:  base/docker-compose-base.yaml      service: peer0.org2.example.com    networks:      - byfn    extra_hosts:      - orderer0.org1.example.com:192.168.9.35      - orderer1.org1.example.com:192.168.9.35      - orderer2.org1.example.com:192.168.9.35      - orderer0.org2.example.com:192.168.9.28      - orderer1.org2.example.com:192.168.9.28  peer1.org2.example.com:    container_name: peer1.org2.example.com    extends:      file:  base/docker-compose-base.yaml      service: peer1.org2.example.com    networks:      - byfn    extra_hosts:      - orderer0.org1.example.com:192.168.9.35      - orderer1.org1.example.com:192.168.9.35      - orderer2.org1.example.com:192.168.9.35      - orderer0.org2.example.com:192.168.9.28      - orderer1.org2.example.com:192.168.9.28</code></pre><p>以上步骤完成后，将项目拷贝到其他的主机上</p><h2 id="6-启动fabric网络"><a href="#6-启动fabric网络" class="headerlink" title="6. 启动fabric网络"></a>6. 启动fabric网络</h2><p>启动主机1</p><pre><code>docker-compose -f docker-compose-org1-35.yaml up -d</code></pre><p>启动主机2</p><pre><code>docker-compose -f docker-compose-org2-28.yaml up -d</code></pre><p>启动脚本</p><pre><code>#!/bin/bashexport CHANNEL_NAME=mychannelexport ORDERER_CA=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/orderer0.org1.example.com/msp/tlscacerts/tlsca.org1.example.com-cert.pem## Create channelpeer channel create -o orderer0.org1.example.com:7050 -c $CHANNEL_NAME -f ./channel-artifacts/channel.tx --tls $CORE_PEER_TLS_ENABLED --cafile $ORDERER_CA## Join all the peers to the channelpeer channel join -b $CHANNEL_NAME.block## Set the anchor peers for each org in the channelpeer channel update -o orderer0.org1.example.com:7050 -c $CHANNEL_NAME -f ./channel-artifacts/Org1MSPanchors.tx --tls $CORE_PEER_TLS_ENABLED --cafile $ORDERER_CA## Install chaincode on peer0.org1peer chaincode install -n mycc -v 1.0 -p github.com/chaincode/chaincode_example02peer chaincode install -n public -v 1.0 -p unionbank/chaincode/publicpeer chaincode install -n forfeiting -v 1.0 -p unionbank/chaincode/forfeitingsleep 5## pee1.org1export CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/mspexport CORE_PEER_ADDRESS=peer1.org1.example.com:8051export CORE_PEER_LOCALMSPID=&quot;Org1MSP&quot;export CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer1.org1.example.com/tls/ca.crtpeer channel join -b $CHANNEL_NAME.blockpeer chaincode install -n mycc -v 1.0 -p github.com/chaincode/chaincode_example02peer chaincode install -n public -v 1.0 -p unionbank/chaincode/publicpeer chaincode install -n forfeiting -v 1.0 -p unionbank/chaincode/forfeitingsleep 5## peer0.org2export CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/mspexport CORE_PEER_ADDRESS=peer0.org2.example.com:9051export CORE_PEER_LOCALMSPID=&quot;Org2MSP&quot;export CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crtpeer channel join -b $CHANNEL_NAME.blockpeer channel update -o orderer0.org1.example.com:7050 -c $CHANNEL_NAME -f ./channel-artifacts/Org2MSPanchors.tx --tls $CORE_PEER_TLS_ENABLED --cafile $ORDERER_CApeer chaincode install -n mycc -v 1.0 -p github.com/chaincode/chaincode_example02peer chaincode install -n public -v 1.0 -p unionbank/chaincode/publicpeer chaincode install -n forfeiting -v 1.0 -p unionbank/chaincode/forfeitingsleep 5## peer1.org2export CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/mspexport CORE_PEER_ADDRESS=peer1.org2.example.com:10051export CORE_PEER_LOCALMSPID=&quot;Org2MSP&quot;export CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer1.org2.example.com/tls/ca.crtpeer channel join -b $CHANNEL_NAME.blockpeer chaincode install -n mycc -v 1.0 -p github.com/chaincode/chaincode_example02peer chaincode install -n public -v 1.0 -p unionbank/chaincode/publicpeer chaincode install -n forfeiting -v 1.0 -p unionbank/chaincode/forfeitingsleep 5# Instantiate chaincode on peer0.org1echo &quot;Instantiating chaincode on peer0.org1...&quot;export CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/mspexport CORE_PEER_ADDRESS=peer0.org1.example.com:7051export CORE_PEER_LOCALMSPID=&quot;Org1MSP&quot;export CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crtsleep 5peer chaincode instantiate -o orderer0.org1.example.com:7050 --tls $CORE_PEER_TLS_ENABLED --cafile $ORDERER_CA -C $CHANNEL_NAME -n mycc -v 1.0 -c &#39;{&quot;Args&quot;:[&quot;init&quot;,&quot;a&quot;, &quot;100&quot;, &quot;b&quot;,&quot;200&quot;]}&#39;sleep 5peer chaincode instantiate -o orderer0.org1.example.com:7050 --tls $CORE_PEER_TLS_ENABLED --cafile $ORDERER_CA -C $CHANNEL_NAME -n public -v 1.0 -c &#39;{&quot;Args&quot;:[]}&#39;sleep 5peer chaincode instantiate -o orderer0.org1.example.com:7050 --tls $CORE_PEER_TLS_ENABLED --cafile $ORDERER_CA -C $CHANNEL_NAME -n forfeiting -v 1.0 -c &#39;{&quot;Args&quot;:[]}&#39;sleep 5# Query chaincode on peer0.org1peer chaincode query -C $CHANNEL_NAME -n mycc -c &#39;{&quot;Args&quot;:[&quot;query&quot;,&quot;a&quot;]}&#39;# Invoke chaincode on peer0.org1peer chaincode invoke -o orderer0.org1.example.com:7050 --tls $CORE_PEER_TLS_ENABLED --cafile $ORDERER_CA -C $CHANNEL_NAME -n mycc  -c &#39;{&quot;Args&quot;:[&quot;invoke&quot;,&quot;a&quot;,&quot;b&quot;,&quot;10&quot;]}&#39;sleep 5# Query chaincode on peer0.org1peer chaincode query -C $CHANNEL_NAME -n mycc -c &#39;{&quot;Args&quot;:[&quot;query&quot;,&quot;a&quot;]}&#39;</code></pre><p>注意清除原有不需要的容器和镜像，否则可能会用老的镜像，就比如某些链码的镜像</p><pre><code>docker rm -f $(docker ps -a|grep  dev|awk &#39;{print $1}&#39;)docker rmi -f $(docker images|grep  dev|awk &#39;{print $1}&#39;)docker volume rm -f $(docker volume ls -q)</code></pre><pre><code>version: &#39;2&#39;volumes:  orderer0.example.com:  orderer1.example.com:  orderer2.example.com:  peer0.org1.example.com:  peer1.org1.example.com:  peer0.org2.example.com:  peer1.org2.example.com:networks:  byfn:services:  orderer0.example.com:    environment:      - ORDERER_GENERAL_LOCALMSPID=OrdererMSP    extends:      file: base/peer-base.yaml      service: orderer-base    container_name: orderer0.example.com    networks:      - byfn    volumes:      - ./channel-artifacts/genesis.block:/var/hyperledger/orderer/orderer.genesis.block      - ./crypto-config/ordererOrganizations/example.com/orderers/orderer0.example.com/msp:/var/hyperledger/orderer/msp      - ./crypto-config/ordererOrganizations/example.com/orderers/orderer0.example.com/tls/:/var/hyperledger/orderer/tls      - orderer0.example.com:/var/hyperledger/production/orderer    ports:      - 7050:7050    extra_hosts:      - orderer0.example.com:192.168.9.108      - orderer1.example.com:192.168.9.17      - orderer2.example.com:192.168.9.117      - peer0.org1.example.com:192.168.9.105      - peer1.org1.example.com:192.168.9.13      - peer0.org2.example.com:192.168.9.55      - peer1.org2.example.com:192.168.9.88  orderer1.example.com:    environment:      - ORDERER_GENERAL_LOCALMSPID=OrdererMSP    extends:      file: base/peer-base.yaml      service: orderer-base    container_name: orderer1.example.com    networks:      - byfn    volumes:      - ./channel-artifacts/genesis.block:/var/hyperledger/orderer/orderer.genesis.block      - ./crypto-config/ordererOrganizations/example.com/orderers/orderer1.example.com/msp:/var/hyperledger/orderer/msp      - ./crypto-config/ordererOrganizations/example.com/orderers/orderer1.example.com/tls/:/var/hyperledger/orderer/tls      - orderer1.example.com:/var/hyperledger/production/orderer    ports:      - 8050:7050    extra_hosts:      - orderer0.example.com:192.168.9.108      - orderer1.example.com:192.168.9.17      - orderer2.example.com:192.168.9.117      - peer0.org1.example.com:192.168.9.105      - peer1.org1.example.com:192.168.9.13      - peer0.org2.example.com:192.168.9.55      - peer1.org2.example.com:192.168.9.88  orderer2.example.com:    environment:      - ORDERER_GENERAL_LOCALMSPID=OrdererMSP    extends:      file: base/peer-base.yaml      service: orderer-base    container_name: orderer2.example.com    networks:      - byfn    volumes:      - ./channel-artifacts/genesis.block:/var/hyperledger/orderer/orderer.genesis.block      - ./crypto-config/ordererOrganizations/example.com/orderers/orderer2.example.com/msp:/var/hyperledger/orderer/msp      - ./crypto-config/ordererOrganizations/example.com/orderers/orderer2.example.com/tls/:/var/hyperledger/orderer/tls      - orderer2.example.com:/var/hyperledger/production/orderer    ports:      - 9050:7050    extra_hosts:      - orderer0.example.com:192.168.9.108      - orderer1.example.com:192.168.9.17      - orderer2.example.com:192.168.9.117      - peer0.org1.example.com:192.168.9.105      - peer1.org1.example.com:192.168.9.13      - peer0.org2.example.com:192.168.9.55      - peer1.org2.example.com:192.168.9.88  peer0.org1.example.com:    container_name: peer0.org1.example.com    extends:      file:  base/docker-compose-base.yaml      service: peer0.org1.example.com    networks:      - byfn    extra_hosts:      - orderer0.example.com:192.168.9.108      - orderer1.example.com:192.168.9.17      - orderer2.example.com:192.168.9.117      - peer0.org1.example.com:192.168.9.105      - peer1.org1.example.com:192.168.9.13      - peer0.org2.example.com:192.168.9.55      - peer1.org2.example.com:192.168.9.88  peer1.org1.example.com:    container_name: peer1.org1.example.com    extends:      file:  base/docker-compose-base.yaml      service: peer1.org1.example.com    networks:      - byfn    extra_hosts:      - orderer0.example.com:192.168.9.108      - orderer1.example.com:192.168.9.17      - orderer2.example.com:192.168.9.117      - peer0.org1.example.com:192.168.9.105      - peer1.org1.example.com:192.168.9.13      - peer0.org2.example.com:192.168.9.55      - peer1.org2.example.com:192.168.9.88peer0.org2.example.com:    container_name: peer0.org2.example.com    extends:      file:  base/docker-compose-base.yaml      service: peer0.org2.example.com    networks:      - byfn    extra_hosts:      - orderer0.example.com:192.168.9.108      - orderer1.example.com:192.168.9.17      - orderer2.example.com:192.168.9.117      - peer0.org1.example.com:192.168.9.105      - peer1.org1.example.com:192.168.9.13      - peer0.org2.example.com:192.168.9.55      - peer1.org2.example.com:192.168.9.88peer1.org2.example.com:    container_name: peer1.org2.example.com    extends:      file:  base/docker-compose-base.yaml      service: peer1.org2.example.com    networks:      - byfn    extra_hosts:      - orderer0.example.com:192.168.9.108      - orderer1.example.com:192.168.9.17      - orderer2.example.com:192.168.9.117      - peer0.org1.example.com:192.168.9.105      - peer1.org1.example.com:192.168.9.13      - peer0.org2.example.com:192.168.9.55      - peer1.org2.example.com:192.168.9.88  cli:    container_name: cli    image: 192.168.9.8:80/fabric1.4performance/hyperledger/fabric-tools:sles12sp3-latest    tty: true    stdin_open: true    environment:      - GOPATH=/opt/gopath      - CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock      #- FABRIC_LOGGING_SPEC=DEBUG      - FABRIC_LOGGING_SPEC=INFO      #- CORE_PEER_BCCSP_DEFAULT=GM      - CORE_PEER_BCCSP_DEFAULT=SW      - CORE_PEER_ID=cli      - CORE_PEER_ADDRESS=peer0.org1.example.com:7051      - CORE_PEER_LOCALMSPID=Org1MSP      - CORE_PEER_TLS_ENABLED=true      - CORE_PEER_TLS_CERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/server.crt      - CORE_PEER_TLS_KEY_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/server.key      - CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt      - CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp    working_dir: /opt/gopath/src/github.com/hyperledger/fabric/peer    command: /bin/bash    volumes:      - /var/run/:/host/var/run/      - ./../chaincode/:/opt/gopath/src/github.com/chaincode      - ./../unionbank/:/opt/gopath/src/unionbank      - ./crypto-config:/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/      - ./scripts:/opt/gopath/src/github.com/hyperledger/fabric/peer/scripts/      - ./channel-artifacts:/opt/gopath/src/github.com/hyperledger/fabric/peer/channel-artifacts    extra_hosts:      - orderer0.example.com:192.168.9.108      - orderer1.example.com:192.168.9.17      - orderer2.example.com:192.168.9.117      - peer0.org1.example.com:192.168.9.105      - peer1.org1.example.com:192.168.9.13      - peer0.org2.example.com:192.168.9.55      - peer1.org2.example.com:192.168.9.88    networks:      - byfn</code></pre>]]></content>
      
      
      <categories>
          
          <category> fabric </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fabric部署 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
