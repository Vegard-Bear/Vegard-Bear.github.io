<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【leetcode-990】等式方程的可满足性</title>
      <link href="/2021/07/18/leetcode-990/"/>
      <url>/2021/07/18/leetcode-990/</url>
      
        <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/satisfiability-of-equality-equations/" target="_blank" rel="noopener">990. 等式方程的可满足性</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个由表示变量之间关系的字符串方程组成的数组，每个字符串方程 equations[i] 的长度为 4，并采用两种不同的形式之一：”a==b” 或 “a!=b”。在这里，a 和 b 是小写字母（不一定不同），表示单字母变量名。</p><p>只有当可以将整数分配给变量名，以便满足所有给定的方程时才返回 true，否则返回 false。</p><p>示例 1：</p><pre><code>输入：[&quot;a==b&quot;,&quot;b!=a&quot;]输出：false解释：如果我们指定，a = 1 且 b = 1，那么可以满足第一个方程，但无法满足第二个方程。没有办法分配变量同时满足这两个方程。</code></pre><p>示例 2：</p><pre><code>输入：[&quot;b==a&quot;,&quot;a==b&quot;]输出：true解释：我们可以指定 a = 1 且 b = 1 以满足满足这两个方程。</code></pre><p>示例 3：</p><pre><code>输入：[&quot;a==b&quot;,&quot;b==c&quot;,&quot;a==c&quot;]输出：true</code></pre><p>示例 4：</p><pre><code>输入：[&quot;a==b&quot;,&quot;b!=c&quot;,&quot;c==a&quot;]输出：false</code></pre><p>示例 5：</p><pre><code>输入：[&quot;c==c&quot;,&quot;b==d&quot;,&quot;x!=z&quot;]输出：true</code></pre><p>提示：</p><ul><li>1 &lt;= equations.length &lt;= 500</li><li>equations[i].length == 4</li><li>equations[i][0] 和 equations[i][3] 是小写字母</li><li>equations[i][1] 要么是 ‘=’，要么是 ‘!’</li><li>equations[i][2] 是 ‘=’</li></ul><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>动态连通性其实就是一种等价关系，具有“自反性”，“传递性”和对称性，其实==也是一种等价关系，具有这些性质，所以这个问题可以用Union-Find算法，也就是并查集解决。</p><p>核心思想是，将equations中的算式根据==和!=分成两部分，先处理==算式，使得他们通过相等关系互相连通，然后处理!=关系，检查不等关系是否破坏了相等关系的连通性。</p><p>具体解法如下：</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code>func equationsPossible(equations []string) bool {    uf := new(unionFind)    // 最多有26哥英文字母，也就是26个互不连通的节点    uf.UnionFind(26 + &#39;a&#39;)    // 先让相等的字母形成连通分量    for _, eq := range equations {        if eq[1] == &#39;=&#39; {            uf.union(int(eq[0]), int(eq[3]))        }    }    // 检查不等的关系是否打破相等关系的连通性    for _, eq := range equations {        if eq[1] == &#39;!&#39; {            // 如果连通，说明逻辑冲突            if uf.connected(int(eq[0]), int(eq[3])) {                return false            }        }    }    return true}type unionFind struct {    // 连通分量的个数    count int    // 存储每个节点的父节点    parent []int    // 记录每棵树的重量    size []int}// 构造函数，n为图的节点总数func (uf *unionFind) UnionFind(n int)  {    uf.count = n    // 初始化parent数组    uf.parent = make([]int, n)    // 初始化size数组    uf.size = make([]int, n)    // 初始状态下，每个节点互不连通，父节点指针指向自身，重量为1    for i := 0; i &lt; n; i++ {        uf.parent[i] = i        uf.size[i] = i    }}// 将p和q连接func (uf *unionFind) union (p, q int)  {    // 先找到各自的根节点    rootP := uf.find(p)    rootQ := uf.find(q)    if rootP == rootQ {        return    }    // 小树接到大树下面，较平衡，parent数组与size数组同步更新    if uf.size[rootP] &gt; uf.size[rootQ] {        uf.parent[rootQ] = rootP        uf.size[rootP] += uf.size[rootQ]    } else {        uf.parent[rootP] = rootQ        uf.size[rootQ] += uf.size[rootP]    }    // 连通分量的数量-1    uf.count--}// 找当前节点的根节点func (uf *unionFind) find(n int) int {    for uf.parent[n] != n {        // 进行路径压缩        uf.parent[n] = uf.parent[uf.parent[n]]        // 往父节点寻找        n = uf.parent[n]    }    return n}// 判断p和q是否连通，即根节点是否是同一个func (uf *unionFind) connected(p, q int) bool {    rootP := uf.find(p)    rootQ := uf.find(q)    return rootP == rootQ}</code></pre><h3 id="时间复杂度：O-n-ClogC"><a href="#时间复杂度：O-n-ClogC" class="headerlink" title="时间复杂度：O((n+ClogC))"></a>时间复杂度：O((n+ClogC))</h3><p>其中 n 是 equations 中的方程数量，C 是变量的总数，在本题中变量都是小写字母，C≤26。上面的并查集代码中使用了路径压缩优化，对于每个方程的合并和查找的均摊时间复杂度都是 O((logC))。由于需要遍历每个方程，因此总时间复杂度是 O((n+Clog C))。</p><h3 id="空间复杂度：O-C-。"><a href="#空间复杂度：O-C-。" class="headerlink" title="空间复杂度：O((C))。"></a>空间复杂度：O((C))。</h3><p>创建一个数组 parent 存储每个变量的连通分量信息，由于变量都是小写字母，因此 parent 是长度为 C。</p><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><p>Uninon算法，也就是并查集算法其实是DFS算法的延伸，使用并查集算法的关键在于如何把原问题转化为图的动态连通性问题，比如本题的算式合法性问题就可以直接利用等价关系。</p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【leetcode-20】有效的括号</title>
      <link href="/2021/07/17/leetcode-20/"/>
      <url>/2021/07/17/leetcode-20/</url>
      
        <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/valid-parentheses/" target="_blank" rel="noopener">20. 有效的括号</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</p><p>有效字符串需满足：</p><p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。</p><p>示例 1：</p><pre><code>输入：s = &quot;()&quot;输出：true</code></pre><p>示例 2：</p><pre><code>输入：s = &quot;()[]{}&quot;输出：true</code></pre><p>示例 3：</p><pre><code>输入：s = &quot;(]&quot;输出：false</code></pre><p>示例 4：</p><pre><code>输入：s = &quot;([)]&quot;输出：false</code></pre><p>示例 5：</p><pre><code>输入：s = &quot;{[]}&quot;输出：true</code></pre><p>提示：</p><ul><li>1 &lt;= s.length &lt;= 104</li><li>s 仅由括号 ‘()[]{}’ 组成</li></ul><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>我们先来设想一下一种最简单的情况，就是只有一种类型的括号，比如“（”，我们该如何判定合法性，很显然，对于每一个右括号的左边必须有一个左括号和它匹配。</p><p>那么根据这个思路，我们就可以写出算法：</p><pre><code>func isValid(s string) bool {    // 待匹配的括号数量    left := 0    for range _, c := s {        // 遇到左括号        if c == &#39;(&#39; {            left++        // 遇到右括号        } else {            left--        }        if left &lt; 0 {            return false        }    }    return left == 0}</code></pre><p>如果只有一种括号。就可以采用这种思路，但是如果是三种括号了就不行了。因为如果简单地用三个变量，多几个if else分支的话，会遇到这种情况 [(]) 显然是不能简单地用左右括号的个数进行判定，那么该怎么办呢？<br>很简单，遇到括号合法性的问题应该首先想到能不能用栈的思路进行解决。</p><p>我们这道题就可以用left的栈代替之前的那个left变量，遇到左括号就入栈，遇到右括号就去栈中寻找最近的左括号，看是否匹配。</p><p>具体解法如下：</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code>func isValid(s string) bool {    // 用一个栈存储所有的左括号    left := make([]byte, 0)    // 遍历字符串    for _, c := range s {        // 如果是左括号就直接入栈        if c == &#39;(&#39; || c == &#39;[&#39; || c == &#39;{&#39; {            left = append(left, byte(c))        // 如果有右括号就和栈顶元素做匹配        } else {            // 如果刚好配对，就弹出栈顶元素            if len(left) &gt; 0 &amp;&amp; left[len(left)-1] == leftOf(byte(c)) {                left = left[:len(left)-1]            } else {                // 如果不配对，则直接返回false                return false            }        }    }    // 最后检查一下是否所有的左括号都匹配了    return len(left) == 0}// 返回对应的左括号func leftOf(c byte) byte {    switch c {    case &#39;)&#39;:        return &#39;(&#39;    case &#39;]&#39;:        return &#39;[&#39;    default:        return &#39;{&#39;    }}</code></pre><h3 id="时间复杂度：O-n"><a href="#时间复杂度：O-n" class="headerlink" title="时间复杂度：O((n))"></a>时间复杂度：O((n))</h3><p>n是字符串的长度</p><h3 id="空间复杂度：O-n"><a href="#空间复杂度：O-n" class="headerlink" title="空间复杂度：O((n))"></a>空间复杂度：O((n))</h3><p>栈的深度最多为字符串的字符个数，也是O((n))</p><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><p>判定括号的合法性是一个非常实用的问题，而栈在处理这类问题时尤其有用。</p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leecode </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【leetcode-452】用最少数量的箭引爆气球</title>
      <link href="/2021/07/15/leetcode-452/"/>
      <url>/2021/07/15/leetcode-452/</url>
      
        <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/" target="_blank" rel="noopener">452. 用最少数量的箭引爆气球</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以纵坐标并不重要，因此只要知道开始和结束的横坐标就足够了。开始坐标总是小于结束坐标。</p><p>一支弓箭可以沿着 x 轴从不同点完全垂直地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。</p><p>给你一个数组 points ，其中 points [i] = [xstart,xend] ，返回引爆所有气球所必须射出的最小弓箭数。</p><p>示例 1：</p><pre><code>输入：points = [[10,16],[2,8],[1,6],[7,12]]输出：2解释：对于该样例，x = 6 可以射爆 [2,8],[1,6] 两个气球，以及 x = 11 射爆另外两个气球</code></pre><p>示例 2：</p><pre><code>输入：points = [[1,2],[3,4],[5,6],[7,8]]输出：4</code></pre><p>示例 3：</p><pre><code>输入：points = [[1,2],[2,3],[3,4],[4,5]]输出：2</code></pre><p>示例 4：</p><pre><code>输入：points = [[1,2]]输出：1</code></pre><p>示例 5：</p><pre><code>输入：points = [[2,3],[2,3]]输出：1</code></pre><p>提示：</p><ul><li>1 &lt;= points.length &lt;= 104<br>points[i].length == 2</li><li>-231 &lt;= xstart &lt; xend &lt;= 231 - 1</li></ul><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>这道题可以做一个转化，因为一个箭头可以将边界互相重叠的所有气球射穿，那么要保证射穿所有的气球就是求最多有多少个不重叠的区间。</p><p>然后就可以直接用<a href="https://leetcode-cn.com/problems/non-overlapping-intervals/" target="_blank" rel="noopener">435. 无重叠区间</a>中的方法，只是需要做一点微小的改动。因为在<a href="https://leetcode-cn.com/problems/non-overlapping-intervals/" target="_blank" rel="noopener">435. 无重叠区间</a>中如果两个边界触碰，不算重叠，而本题中箭头碰到气球的边界也会爆炸，相当于边界触碰也算重叠。</p><p>具体解法如下：</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code>func findMinArrowShots(points [][]int) int {    if len(points) == 0 {        return 0    }    // 按照end(结束时间)升序排序    sort.Slice(points, func(i, j int) bool {        return points[i][1] &lt; points[j][1]    })    // 至少有一个区间不相交    count := 1    // 排序后，第一个区间都是end最小的区间，记录下end    minEnd := points[0][1]    for _, interval := range points {        start := interval[0]        // 注意这里是大于，因为箭头碰到气球的边界也会爆炸，相当于边界触碰也算重叠        if start &gt; minEnd {            count++            // 新的区间的end将作为新的minEnd，继续寻找这个区间的不相交区间            minEnd = interval[1]        }    }    return count}</code></pre><h3 id="时间复杂度：O-NlogN"><a href="#时间复杂度：O-NlogN" class="headerlink" title="时间复杂度：O((NlogN))"></a>时间复杂度：O((NlogN))</h3><p>其中 n 是数组points的数量。我们需要 O((nlogn)) 的时间对所有的气球按照右端点进行升序排序（其实就是快速排序），并且需要 O((n)) 的时间进行遍历。由于前者在渐进意义下大于后者，因此总时间复杂度为 O((nlogn))。</p><h3 id="空间复杂度：O-logN"><a href="#空间复杂度：O-logN" class="headerlink" title="空间复杂度：O((logN))"></a>空间复杂度：O((logN))</h3><p>O((logN)) 即为排序需要使用的栈空间</p><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><p>只有具备贪心选择性质的问题才可以用贪心算法，贪心选择性质就是每一步都做出一个局部最优的选择，最终的结果就是全局最优。这是一种特殊性质，实际上只有一部分问题具有这个性质。</p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 贪心算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【leetcode-435】无重叠区间</title>
      <link href="/2021/07/14/leetcode-435/"/>
      <url>/2021/07/14/leetcode-435/</url>
      
        <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/non-overlapping-intervals/" target="_blank" rel="noopener">435. 无重叠区间</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。</p><p>注意:</p><p>可以认为区间的终点总是大于它的起点。<br>区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。</p><p>示例 1:</p><pre><code>输入: [ [1,2], [2,3], [3,4], [1,3] ]输出: 1解释: 移除 [1,3] 后，剩下的区间没有重叠。</code></pre><p>示例 2:</p><pre><code>输入: [ [1,2], [1,2], [1,2] ]输出: 2解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。</code></pre><p>示例 3:</p><pre><code>输入: [ [1,2], [2,3] ]输出: 0解释: 你不需要移除任何区间，因为它们已经是无重叠的了。</code></pre><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>本题可以先做一个转化，即求这些区间中最多有几个不相交的区间。思路如下：</p><ol><li>从区间集合intvs中选择一个区间x，这个区间是在当前所有区间中结束最早的（end最小）。</li><li>把所有区间与x区间相交的区间集合intvs中删除</li><li>重复步骤1和步骤2，直到invts为空。在这个过程中选出的的x就是最大的互不相交的区间子集。</li><li>最后总的区间数减去这个不相交的区间子集个数就是我们要的答案了。</li></ol><p>具体解法如下：</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code>func eraseOverlapIntervals(intervals [][]int) int {    // 总的区间个数减去不相交的区间个数就是需要去除的区间    return len(intervals) - intervalSchedule(intervals)}// 计算最多有几个不重复的区间func intervalSchedule(intvs [][]int) int {    if len(intvs) == 0 {        return 0    }    // 按照end(结束时间)升序排序    sort.Slice(intvs, func(i, j int) bool {        return intvs[i][1] &lt; intvs[j][1]    })    // 至少有一个区间不相交    count := 1    // 排序后，第一个区间都是end最小的区间，记录下end    minEnd := intvs[0][1]    for _, interval := range intvs {        start := interval[0]        // start大于等于end，说明找到第一个不相交的区间了，因为边界相同也算是不相交        if start &gt;= minEnd {            count++            // 新的区间的end将作为新的minEnd，继续寻找这个区间的不相交区间            minEnd = interval[1]        }    }    return count}</code></pre><h3 id="时间复杂度：O-NlogN"><a href="#时间复杂度：O-NlogN" class="headerlink" title="时间复杂度：O((NlogN))"></a>时间复杂度：O((NlogN))</h3><p>其中 n 是区间的数量。我们需要 O((nlogn)) 的时间对所有的区间按照右端点进行升序排序（其实就是快速排序），并且需要 O((n)) 的时间进行遍历。由于前者在渐进意义下大于后者，因此总时间复杂度为 O((nlogn))。</p><h3 id="空间复杂度：O-logN"><a href="#空间复杂度：O-logN" class="headerlink" title="空间复杂度：O((logN))"></a>空间复杂度：O((logN))</h3><p>O((logN)) 即为排序需要使用的栈空间</p><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><p>只有具备贪心选择性质的问题才可以用贪心算法，贪心选择性质就是每一步都做出一个局部最优的选择，最终的结果就是全局最优。这是一种特殊性质，实际上只有一部分问题具有这个性质。</p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 贪心算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【leetcode-45】跳跃游戏 II</title>
      <link href="/2021/07/10/leetcode-45/"/>
      <url>/2021/07/10/leetcode-45/</url>
      
        <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/jump-game-ii/" target="_blank" rel="noopener">45. 跳跃游戏 II</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个非负整数数组，你最初位于数组的第一个位置。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p><p>假设你总是可以到达数组的最后一个位置。</p><p>示例 1:</p><pre><code>输入: [2,3,1,1,4]输出: 2解释: 跳到最后一个位置的最小跳跃数是 2。     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。</code></pre><p>示例 2:</p><pre><code>输入: [2,3,0,1,4]输出: 2</code></pre><p>提示:</p><ul><li>1 &lt;= nums.length &lt;= 1000</li><li>0 &lt;= nums[i] &lt;= 105</li></ul><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>本题是<a href="https://leetcode-cn.com/problems/jump-game/" target="_blank" rel="noopener">55. 跳跃游戏</a>的进阶版。场景是一样，只不过问题换了一下，这次是保证你可以到达最后一个位置，求跳过最后一个位置所需要的最少跳跃数。碰到这种求最少次数的第一反应肯定是动态规划，但是如果真的用动态规划会发现时间复杂度是O((n^2))，因为动态规划需要递归。</p><p>为了减少时间复杂度，不用递归，我们还是选择贪心算法，之所以可以用贪心算法解决，是因为本题具有贪心选择性质，那什么是贪心选择性质呢？</p><h5 id="贪心选择性质就是不需要递归的计算出所有选择的具体结果然后比较求最值，而只需做出那个最有潜力、看起来最优的选择即可。"><a href="#贪心选择性质就是不需要递归的计算出所有选择的具体结果然后比较求最值，而只需做出那个最有潜力、看起来最优的选择即可。" class="headerlink" title="贪心选择性质就是不需要递归的计算出所有选择的具体结果然后比较求最值，而只需做出那个最有潜力、看起来最优的选择即可。"></a>贪心选择性质就是不需要递归的计算出所有选择的具体结果然后比较求最值，而只需做出那个最有潜力、看起来最优的选择即可。</h5><p>具体解法如下：</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code>func jump(nums []int) int {    n := len(nums)    // 站在索引i，最多能跳到索引end    end := 0    // 从索引[i...end]起跳，最远能跳到的距离    farthest := 0    // 记录跳跃次数    jumps := 0    // 对于每一个位置都计算一下能跳到的最远距离    for i := 0; i &lt; n - 1; i++ {        farthest = max(nums[i] + i, farthest)        // 说明从索引[i...end]起跳，所有能跳到的距离已经计算完毕，其中最远的就是farthest        if end == i {            // 往前跳一步，i直接跳到end+1，然后选择这个farthest作为新的可选最远边界end            // 相当于i更新为end+1，end更新为farthest            jumps++            end = farthest        }    }    return jumps}func max(a, b int) int {    if a &gt; b {        return a    }    return b}</code></pre><h3 id="时间复杂度：O-n"><a href="#时间复杂度：O-n" class="headerlink" title="时间复杂度：O((n))"></a>时间复杂度：O((n))</h3><p>其中 n 为数组的大小。只需要访问 nums 数组一遍，共 n 个位置。</p><h3 id="空间复杂度：O-1"><a href="#空间复杂度：O-1" class="headerlink" title="空间复杂度：O((1))"></a>空间复杂度：O((1))</h3><p>不需要额外的开销。</p><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><p>贪心算法是一类特殊的动态规划算法，它复杂度比动态规划更低，这是因为少了递归过程。如果一个问题具有贪心选择性质，那么他就可以用贪心算法解决，能用贪心算法解决的问题往往是最优解。</p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 贪心算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【leetcode-55】跳跃游戏 I</title>
      <link href="/2021/07/10/leetcode-55/"/>
      <url>/2021/07/10/leetcode-55/</url>
      
        <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/jump-game/" target="_blank" rel="noopener">55. 跳跃游戏</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个非负整数数组 nums ，你最初位于数组的第一个下标 。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个下标。</p><p>示例 1：</p><pre><code>输入：nums = [2,3,1,1,4]输出：true解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。</code></pre><p>示例 2：</p><pre><code>输入：nums = [3,2,1,0,4]输出：false解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。</code></pre><p>提示：</p><ul><li>1 &lt;= nums.length &lt;= 3 * 104</li><li>0 &lt;= nums[i] &lt;= 105</li></ul><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>在审题的过程中很容易发现，每两次跳跃之间是有联系的，也就是说下一次跳跃的结果是依赖于上一次跳跃的状态的，并且我们在同一个位置可以有不同的选择，这些选择决定了跳跃后不同的状态。由此我们可以从以上分析中提炼出两个关键点：</p><ol><li>不同的选择决定了不同状态</li><li>相邻状态之间是有联系的</li></ol><p>至此我们就马上可以联想到动态规划。然后，有关动态规划的问题，大部分都是让你求最值的，但是本题却好像不是。这没关系，我们可以对题意做一个转换，就成求最值问题了。</p><p>能否跳到最后一个位置其实就是在跳的最远的情况下，能否越过最后一个位置。</p><p>然后我们就可以用动态规划的思路求解，即对于nums[0…n-1]，计算当前能跳到的最远距离，最后得出能跳的最远的距离，这个巨苦可以越过n-1，就说明能够跳到最后一个位置。</p><p>具体解法如下：</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code>func canJump(nums []int) bool {    n := len(nums)    // 能跳到的最远距离    farthest := 0    // 对于每一个位置都计算一下能跳到的最远距离    for i := 0; i &lt; n - 1 ; i++ {        // 计算当前能跳到的最远距离        farthest = max(farthest, i + nums[i])        // 当前最远也就能调到这里了，无法再往下跳了（可能碰到了0，卡住就跳不动了）        if farthest &lt;= i {            return false        }    }    // 最远的距离是否超过最后一个位置    return farthest &gt;= n - 1}func max(a, b int) int {    if a &gt; b {        return a    }    return b}</code></pre><h3 id="时间复杂度：O-n"><a href="#时间复杂度：O-n" class="headerlink" title="时间复杂度：O((n))"></a>时间复杂度：O((n))</h3><p>其中 n 为数组的大小。只需要访问 nums 数组一遍，共 n 个位置。</p><h3 id="空间复杂度：O-1"><a href="#空间复杂度：O-1" class="headerlink" title="空间复杂度：O((1))"></a>空间复杂度：O((1))</h3><p>不需要额外的开销。</p><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><p>实际上我们可以看到本题用的是贪心算法，贪心算法的复杂度比动态规划更低，这是因为少了递归过程，只需要着眼于当下最优子结构的解决，局部最优解能决定全局最优解。</p><p>贪心算法与动态规划的不同在于它对每个子问题的解决方案都做出选择，不能回退。动态规划则会保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能。</p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 贪心算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【leetcode-5】最长回文子串</title>
      <link href="/2021/07/04/leetcode-5/"/>
      <url>/2021/07/04/leetcode-5/</url>
      
        <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">5. 最长回文子串水</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一个字符串 s，找到 s 中最长的回文子串。</p><p>示例 1：</p><pre><code>输入：s = &quot;babad&quot;输出：&quot;bab&quot;解释：&quot;aba&quot; 同样是符合题意的答案。</code></pre><p>示例 2：</p><pre><code>输入：s = &quot;cbbd&quot;输出：&quot;bb&quot;</code></pre><p>示例 3：</p><pre><code>输入：s = &quot;a&quot;输出：&quot;a&quot;</code></pre><p>示例 4：</p><pre><code>输入：s = &quot;ac&quot;输出：&quot;a&quot;</code></pre><p>提示：</p><ul><li>1 &lt;= s.length &lt;= 1000</li><li>s 仅由数字和英文字母（大写和/或小写）组成</li></ul><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>核心思想是：从左到右依次以s[i]为中心，向两边扩散来寻找回文串，并留下最长的那个。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code>func longestPalindrome(s string) string {    res := &quot;&quot;    // 从左到右依次以s[i]为中心，寻找回文串    for i := 0; i &lt; len(s); i++ {        // 寻找长度为奇数的回文子串        s1 := palindrome(s, i, i)        // 寻找长度为偶数的回文串        s2 := palindrome(s, i, i+1)        // 留下最长的那个        res = longestString(res, s1, s2)    }    return res}// 从s[l]和s[r]开始向两端扩散// 返回以s[l]和s[r]为中心的最长回文串func palindrome(s string, l, r int) string {    // 防止索引越界    for l &gt;= 0 &amp;&amp; r &lt; len(s) &amp;&amp; s[l] == s[r] {        l--        r++    }    return s[l+1:r]}func longestString(s1, s2, s3 string) string {    if len(s1) &gt; len(s2) {        if len(s1) &gt; len(s3) {            return s1        } else {            return s3        }    } else {        if len(s2) &lt; len(s3) {            return s3        } else {            return s2        }    }}</code></pre><h3 id="时间复杂度：O-n-2"><a href="#时间复杂度：O-n-2" class="headerlink" title="时间复杂度：O((n^2))"></a>时间复杂度：O((n^2))</h3><p>其中 n 是字符串的长度。长度为 1 和 2 的回文中心分别有 n 和 n-1 个，每个回文中心最多会向外扩展 O((n)) 次。</p><h3 id="空间复杂度：O-1"><a href="#空间复杂度：O-1" class="headerlink" title="空间复杂度：O((1))"></a>空间复杂度：O((1))</h3><p>维护两个指针即可，因此只需要使用常数的额外空间。</p><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><p>本题用到的依旧是双指针技巧，只不过不是快慢指针，而是左右指针。核心思想是：从中间开始向两边扩散来判断回文串。</p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【leetcode-26】删除有序数组中的重复项</title>
      <link href="/2021/07/04/leetcode-26/"/>
      <url>/2021/07/04/leetcode-26/</url>
      
        <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noopener">26. 删除有序数组中的重复项接雨水</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O((1)) 额外空间的条件下完成。</p><p>说明:</p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><pre><code>// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝int len = removeDuplicates(nums);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。for (int i = 0; i &lt; len; i++) {    print(nums[i]);}</code></pre><p>示例 1：</p><pre><code>输入：nums = [1,1,2]输出：2, nums = [1,2]解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。</code></pre><p>示例 2：</p><pre><code>输入：nums = [0,0,1,1,1,2,2,3,3,4]输出：5, nums = [0,1,2,3,4]解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。</code></pre><p>提示：</p><ul><li>0 &lt;= nums.length &lt;= 3 * 104</li><li>-104 &lt;= nums[i] &lt;= 104</li><li>nums 已按升序排列</li></ul><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>对于数组相关的算法问题，有一个通用的技巧：尽量避免在中间删除元素，而是想办法把这个元素换到最后。再一个个弹出，这样每次操作的时间复杂度也就降到O((1))了。按照这个思路，又可以衍生出双指针技巧：快慢指针。</p><p>本题就是采用了快慢指针的思想，让慢指针slow走在后面，快指针fast走在前面探路，找到一个不重复的元素，就填充到slow的位置，然后slow向前移动一步，这样slow就永远指向第一个重复的元素（换言之，slow之前的都是不重复的元素）。如果fast遇到的是重复的元素，则直接跳过，继续往前走，直到再找到一个不重复的元素。这样，当fast指针遍历完整个数组后，nums[0..slow]保存的就是不重复元素，之后的所有元素都是重复元素。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code>func removeDuplicates(nums []int) int {    n := len(nums)    if n == 0 {        return 0    }    // 快指针走前，慢指针走后    slow, fast := 0, 1    // 快指针没有走到头    for fast &lt; n {        // 发现了一个新元素（不和之前重复的元素）        if nums[fast] != nums[slow] {            // slow永远指向第一个重复的元素            slow++            // 用新元素覆盖重复的元素            nums[slow] = nums[fast]        }        // 走到这里，说明元素重复了，直接跳过        fast++    }    // 索引是从0开始的，所以长度=索引+1    return slow + 1}</code></pre><h3 id="时间复杂度：O-n"><a href="#时间复杂度：O-n" class="headerlink" title="时间复杂度：O((n))"></a>时间复杂度：O((n))</h3><p>其中 n 是数组的长度。快指针和慢指针最多各移动 n 次。</p><h3 id="空间复杂度：O-1"><a href="#空间复杂度：O-1" class="headerlink" title="空间复杂度：O((1))"></a>空间复杂度：O((1))</h3><p>维护两个指针即可，因此只需要使用常数的额外空间</p><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><p>快慢指针的应用相当广泛，建议做完本题，还可以顺手去把 <a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/" target="_blank" rel="noopener">83. 删除排序链表中的重复元素</a>做了，加深印象。</p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【leetcode-42】接雨水</title>
      <link href="/2021/07/04/leetcode-42/"/>
      <url>/2021/07/04/leetcode-42/</url>
      
        <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/trapping-rain-water/" target="_blank" rel="noopener">42. 接雨水</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png" alt></p><p>示例 1：</p><pre><code>输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]输出：6解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 </code></pre><p>示例 2：</p><pre><code>输入：height = [4,2,0,3,2,5]输出：9</code></pre><p>提示：</p><ul><li>n == height.length</li><li>0 &lt;= n &lt;= 3 * 104</li><li>0 &lt;= height[i] &lt;= 105</li></ul><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>本题难度较大，第一次看到这个问题时，读者可能毫无思路。但是我们先不要考虑总共能装多少水，只考虑对于某个位置i，能装下多少水。然后我们就可以很快得到位置i能装的水量之和它左右最高高度柱子的高度有关。两者中较低的那个减去当前位置的高度就是能装的最大水量（短板效应）。</p><p>然后我们就可以用伪代码表示位置i最多能装的水为：</p><pre><code>water[i] = min(# 左边最高的柱子max(height[0..i]),# 右边最高的柱子min(height[i..n-1])) - height[i]</code></pre><p>至此，我们就可以马上写出一个暴力算法：</p><pre><code>func trap(height []int) int {    n := len(height)    sum := 0    for(i := 1; i &lt; n-1; i++) {        l_max, r_max := 0, 0        // 找右边最高的柱子        for(j := i; j &lt; n-1; j++) {            r_max = max(r_max, height[j])        }        // 找左边最高的柱子        for(j := 0; j &lt; i; j++) {            l_max = max(l_max, height[j])        }        sum += min(l_max, r_max) - height[i]    }    return sum}</code></pre><p>整体思路就是对于每个位置i，求出它的左边柱子最高高度和右边柱子的最高高度，取两者较小值，然后再减去当前柱子高度值就是水量，最后把所有水量相加即可。</p><p>思路很好理解，但是这个算法有一个致命的缺陷，就是双层for循环，这就导致它的时间复杂度为O((n^2))，这显然不是我们可以接受的，因为对于每个位置都要遍历一遍求最大高度值，这显然是有很多重复的工作。</p><p>这里我们采用的优化策略就是双指针，不再每个都遍历了，而是边走边算当前位置左右两边的高度最值。这样只需要维护一个最值变量就好了。具体解法如下：</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code>func trap(height []int) int {    // 特例    n := len(height)    if n == 0 {        return 0    }    // 左右指针分别    left, right := 0, n -1    // 最终结果    sum := 0    // l_max 代表 height[0..left] 中（左指针以左）最高柱子的高度    // r_max 代表 height[right..n-1] 中（右指针以右）最高柱子的高度    l_max, r_max := height[0], height[n-1]    // 左右指针向中间逼近    for left &lt; right {        // 随着左右指针的移动，不断更新左右两边最高高度        l_max = max(l_max, height[left])        r_max = max(r_max, height[right])        // 比较左右两边的柱子高度，选择较低的那个减去当前柱子高度，即当前位置能装下的水        if l_max &lt; r_max {            sum += l_max - height[left]            left++        } else {            sum += r_max - height[right]            right--        }    }    return sum}func max(a, b int) int {    if a &gt; b {        return a    }    return b}</code></pre><h3 id="时间复杂度：O-n"><a href="#时间复杂度：O-n" class="headerlink" title="时间复杂度：O((n))"></a>时间复杂度：O((n))</h3><p>其中 n 是数组 height 的长度。两个指针的移动总次数不超过 n</p><h3 id="空间复杂度：O-1"><a href="#空间复杂度：O-1" class="headerlink" title="空间复杂度：O((1))"></a>空间复杂度：O((1))</h3><p>维护两个指针即可，因此只需要使用常数的额外空间</p><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><p>本题的暴力解法比较容易理解，但双指针就比较难想到了，也是通过双指针降低时间复杂度的经典题型。</p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【leetcode-1011】在 D 天内送达包裹的能力</title>
      <link href="/2021/07/03/leetcode-1011/"/>
      <url>/2021/07/03/leetcode-1011/</url>
      
        <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/capacity-to-ship-packages-within-d-days/" target="_blank" rel="noopener">1011. 在 D 天内送达包裹的能力</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>传送带上的包裹必须在 D 天内从一个港口运送到另一个港口。</p><p>传送带上的第 i 个包裹的重量为 weights[i]。每一天，我们都会按给出重量的顺序往传送带上装载包裹。我们装载的重量不会超过船的最大运载重量。</p><p>返回能在 D 天内将传送带上的所有包裹送达的船的最低运载能力。</p><p>示例 1：</p><pre><code>输入：weights = [1,2,3,4,5,6,7,8,9,10], D = 5输出：15解释：船舶最低载重 15 就能够在 5 天内送达所有包裹，如下所示：第 1 天：1, 2, 3, 4, 5第 2 天：6, 7第 3 天：8第 4 天：9第 5 天：10请注意，货物必须按照给定的顺序装运，因此使用载重能力为 14 的船舶并将包装分成 (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) 是不允许的。 </code></pre><p>示例 2：</p><pre><code>输入：weights = [3,2,2,4,1,4], D = 3输出：6解释：船舶最低载重 6 就能够在 3 天内送达所有包裹，如下所示：第 1 天：3, 2第 2 天：2, 4第 3 天：1, 4</code></pre><p>示例 3：</p><pre><code>输入：weights = [1,2,3,1,1], D = 4输出：3解释：第 1 天：1第 2 天：2第 3 天：3第 4 天：1, 1</code></pre><p>提示：</p><ul><li>1 &lt;= D &lt;= weights.length &lt;= 5 * 104</li><li>1 &lt;= weights[i] &lt;= 500</li></ul><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>这道题和 <a href="https://leetcode-cn.com/problems/koko-eating-bananas/" target="_blank" rel="noopener">875. 爱吃香蕉的珂珂</a> 是一样的，都是二分查找在实际问题中的应用。</p><p>首先需要确定最小载重的范围，最小值max((weights)，最大值sum((weights))。然后就是在这个范围内进行搜索，这里我们采用的是二分搜索。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code>func minEatingSpeed(piles []int, h int) int {    // 套用搜索左侧边界的算法框架，注意左右边界，每小时最少吃一个香蕉，最多吃一堆香蕉（最多的那堆）    left, right := 1, getMax(piles) + 1    for left &lt;  right {        // 防止溢出        mid := left + (right - left) / 2        if canFinish(piles, mid, h) {            right = mid        } else {            left = mid + 1        }    }    // 因为求的是最小速度，所以是搜索左侧边界    return left}// 在所有堆中找到最大的那堆func getMax(piles []int) int {    max := 0    for _, pile := range piles {        if pile &gt; max {             max = pile        }    }    return max}// 以speed的速度能不能在h小时内吃完所有的香蕉func canFinish(piles []int, speed, h int) bool {    time := 0    // 总时间等于吃完每堆香蕉的时间累加    for _, piles := range piles {        time += timeOf(piles, speed)    }    return time &lt;= h}// 吃完一堆香蕉所用的时间func timeOf(pile int, speed int) int {    // 如果不能刚好吃完，剩下的需要再多花一个小时吃    if pile % speed &gt; 0 {        return pile / speed + 1    } else {        return pile / speed    }}</code></pre><h3 id="时间复杂度：O-nlog-Σw"><a href="#时间复杂度：O-nlog-Σw" class="headerlink" title="时间复杂度：O((nlog((Σw))))"></a>时间复杂度：O((nlog((Σw))))</h3><p>其中 n 是数组 weights 的长度，Σw 是数组 weights 中元素的和。二分查找需要执行的 weights 进行依次遍历，时间为 O((n))，相乘即可得到总时间复杂度。</p><h3 id="空间复杂度：O-1"><a href="#空间复杂度：O-1" class="headerlink" title="空间复杂度：O((1))"></a>空间复杂度：O((1))</h3><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><p>这道题和 <a href="https://leetcode-cn.com/problems/koko-eating-bananas/" target="_blank" rel="noopener">875. 爱吃香蕉的珂珂</a> 是一样的，都是二分查找在实际问题中的应用。建议一起食用，效果更佳。</p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【leetcode-875】爱吃香蕉的珂珂</title>
      <link href="/2021/07/03/leetcode-875/"/>
      <url>/2021/07/03/leetcode-875/</url>
      
        <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/koko-eating-bananas/" target="_blank" rel="noopener">875. 爱吃香蕉的珂珂</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>珂珂喜欢吃香蕉。这里有 N 堆香蕉，第 i 堆中有 piles[i] 根香蕉。警卫已经离开了，将在 H 小时后回来。</p><p>珂珂可以决定她吃香蕉的速度 K （单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉 K 根。如果这堆香蕉少于 K 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉</p><p>珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。</p><p>返回她可以在 H 小时内吃掉所有香蕉的最小速度 K（K 为整数）。</p><p>示例 1：</p><pre><code>输入: piles = [3,6,7,11], H = 8输出: 4</code></pre><p>示例 2：</p><pre><code>输入: piles = [30,11,23,4,20], H = 5输出: 30</code></pre><p>示例 3：</p><pre><code>输入: piles = [30,11,23,4,20], H = 6输出: 23</code></pre><p>提示：</p><ul><li>1 &lt;= piles.length &lt;= 10^4</li><li>piles.length &lt;= H &lt;= 10^9</li><li>1 &lt;= piles[i] &lt;= 10^9</li></ul><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>本题如果直接求解最小速度会比较困难，因为涉及的场景较复杂。不妨先按照题目的意思假设在 H 小时内吃掉所有香蕉的最小速度为speed，然后我们可以思考一下这个speed的取值范围是多少。</p><p>显然，最小速度为1，也就是一个小时至少吃一个香蕉，最大速度为最大堆的香蕉个数 max((piles))，因为一个小时最多吃一堆香蕉，这个是在题目中规定好的。</p><p>然后我们就可以暴力搜索当speed从1到max((piles)) ，一旦发现某个值可以吃掉所有的香蕉，立刻返回答案。</p><p>因为是从1到max((piles))，连续的线性空间搜索，所以可以考虑二分查找，同时求的是最小速度，所以是搜索左侧边界的线性查找。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code>func minEatingSpeed(piles []int, h int) int {    // 套用搜索左侧边界的算法框架，注意左右边界，每小时最少吃一个香蕉，最多吃一堆香蕉（最多的那堆）    left, right := 1, getMax(piles) + 1    for left &lt;  right {        // 防止溢出        mid := left + (right - left) / 2        if canFinish(piles, mid, h) {            right = mid        } else {            left = mid + 1        }    }    // 因为求的是最小速度，所以是搜索左侧边界    return left}// 在所有堆中找到最大的那堆func getMax(piles []int) int {    max := 0    for _, pile := range piles {        if pile &gt; max {             max = pile        }    }    return max}// 以speed的速度能不能在h小时内吃完所有的香蕉func canFinish(piles []int, speed, h int) bool {    time := 0    // 总时间等于吃完每堆香蕉的时间累加    for _, piles := range piles {        time += timeOf(piles, speed)    }    return time &lt;= h}// 吃完一堆香蕉所用的时间func timeOf(pile int, speed int) int {    // 如果不能刚好吃完，剩下的需要再多花一个小时吃    if pile % speed &gt; 0 {        return pile / speed + 1    } else {        return pile / speed    }}</code></pre><h3 id="时间复杂度：O-NlogW"><a href="#时间复杂度：O-NlogW" class="headerlink" title="时间复杂度：O((NlogW))"></a>时间复杂度：O((NlogW))</h3><p>外层二分查找的范围时1～W（最大的香蕉堆的大小），所以复杂度是O((logW))<br>内层for循环需要遍历所有的堆，所以时间复杂度是 O((N))</p><h3 id="空间复杂度：O-1"><a href="#空间复杂度：O-1" class="headerlink" title="空间复杂度：O((1))"></a>空间复杂度：O((1))</h3><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><p>本题说穿了就是一个二分查找，但是有时会以这种应用题的形式出现，读者不一定能想到。</p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【leetcode-372】超级次方</title>
      <link href="/2021/06/27/leetcode-372/"/>
      <url>/2021/06/27/leetcode-372/</url>
      
        <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/super-pow/" target="_blank" rel="noopener">372. 超级次方</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>你的任务是计算 ab 对 1337 取模，a 是一个正整数，b 是一个非常大的正整数且会以数组形式给出。</p><p>示例 1：</p><pre><code>输入：a = 2, b = [3]输出：8</code></pre><p>示例 2：</p><pre><code>输入：a = 2, b = [1,0]输出：1024</code></pre><p>示例 3：</p><pre><code>输入：a = 1, b = [4,3,3,8,5,2]输出：1</code></pre><p>示例 4：</p><pre><code>输入：a = 2147483647, b = [2,0,0]输出：1198</code></pre><p>提示：</p><ul><li>1 &lt;= a &lt;= 231 - 1</li><li>1 &lt;= b.length &lt;= 2000</li><li>0 &lt;= b[i] &lt;= 9</li><li>b 不含前导 0</li></ul><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>本题主要有三个难点：</p><ul><li>一是如何处理用数组表示的指数</li></ul><p>现在 b 是一个数组，也就是说 b 可以非常大，没办法直接转成整型，否则可能溢出。你怎么把这个数组作为指数，进行运算呢？</p><ul><li>二是如何得到求模之后的结果？</li></ul><p>按道理，起码应该先把幂运算结果算出来，然后做 % 1337 这个运算。但问题是，指数运算你懂得，真实结果肯定会大得吓人，也就是说，算出来真实结果也没办法表示，早都溢出报错了。</p><ul><li>三是如何高效进行幂运算</li></ul><p>进行幂运算也是有算法技巧的，如果你不了解这个算法，后文会讲解。</p><p>那么对于这几个问题，我们分开思考，逐个击破。</p><h4 id="如何处理数组指数"><a href="#如何处理数组指数" class="headerlink" title="如何处理数组指数"></a>如何处理数组指数</h4><pre><code>  a^[1,5,6,4]= a^4 * a^[1,5,6,0]= a^4 * (a^[1,5,6])^10</code></pre><h4 id="如何处理-mod-运算"><a href="#如何处理-mod-运算" class="headerlink" title="如何处理 mod 运算"></a>如何处理 mod 运算</h4><p>对乘法的结果求模，等价于先对每个因子都求模，然后对因子相乘的结果再求模。</p><pre><code>(a * b) % k = (a % k)(b % k) % k</code></pre><h4 id="如何高效求幂"><a href="#如何高效求幂" class="headerlink" title="如何高效求幂"></a>如何高效求幂</h4><pre><code>         a * a ^ (b - 1)a ^ b =         (a ^ (b / 2)) ^ 2</code></pre><h1 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h1><pre><code>var base = 1337// 处理数组表示的指数func superPow(a int, b []int) int {    // 递归的 base case，任何数的0次方都是1    if len(b) == 0 {        return 1    }    // 取出最后一个数    last := b[len(b)-1]    b = b[:len(b)-1]    // 将原问题化简，也就是递归迭代    part1 := myPow(a, last)    part2 := myPow(superPow(a, b), 10)    return (part1 * part2) % base}// 计算a的k次方然后与base求模的结果func myPow(a, k int) int {    // 方法一：拆分求模    //// 对因子求模    //a %= base    //res := 1    //    //// 把a^k进行拆解，需要进行k次求模运算    //for i := 0; i &lt; k; i++ {    //    res *= a    //    res %= base    //}    //return res    // 方法二 递归求模    // 递归的 base case，任何数的0次方都是1    if k == 0 {        return 1    }    // 如果是奇数次方，a ^ b = a * a ^ (b - 1)    if k % 2 == 1 {        return (a * myPow(a, k - 1)) % base    } else {        // 如果是偶数次方，a ^ b = (a ^ (b / 2)) ^ 2        sub := myPow(a, k/2)        return (sub * sub) % base    }}</code></pre><h3 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h3><h3 id="空间复杂度："><a href="#空间复杂度：" class="headerlink" title="空间复杂度："></a>空间复杂度：</h3><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><p>本题的处理技巧包括递归、模运算、幂运算技巧，还是很有价值的</p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 递归 </tag>
            
            <tag> 幂运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【leetcode-560】和为K的子数组</title>
      <link href="/2021/06/27/leetcode-560/"/>
      <url>/2021/06/27/leetcode-560/</url>
      
        <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/" target="_blank" rel="noopener">560. 和为K的子数组</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。</p><p>示例 1 :</p><pre><code>输入:nums = [1,1,1], k = 2输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。</code></pre><p>说明 :</p><ul><li>数组的长度为 [1, 20,000]。</li><li>数组中元素的范围是 [-1000, 1000] ，且整数 k 的范围是 [-1e7, 1e7]。</li></ul><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>为了快速得到某个连续子数组的和（不是通过遍历子数组），这里用到了一个技巧，就是前缀和。</p><p>所谓的前缀和就是对一个给定的数组，额外开辟一个前缀和数组进行预处理</p><pre><code>n := len(nums)// 构造前缀和sum := make([]int, n + 1)sum[0] = 0for i := 0; i &lt; n; i++ {    sum[i + 1] = sum[i] + nums[i]}</code></pre><p>这样以来，如果我们想要知道子数组nums[i…j]的和，只需要进一步操作preSum[j+1]-preSum[i]即可，不需要重新遍历子数组了</p><p>然后我们就可以借助这个技巧快速写出一个解法。</p><h1 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h1><pre><code>func subarraySum(nums []int, k int) int {    n := len(nums)    // 构造前缀和    sum := make([]int, n + 1)    sum[0] = 0    for i := 0; i &lt; n; i++ {        sum[i + 1] = sum[i] + nums[i]    }    // 记录答案个数    cnt := 0    // 穷举所有子数组    for i := 0; i &lt;= n; i++ {        for j := 0; j &lt; i; j++ {            // 只要有两个子数组之差为k，意味着nums[i-j]中间这些数字之和为k            if sum[i] - sum[j] == k {                cnt++            }        }    }    return cnt}</code></pre><h3 id="时间复杂度：O-n-2"><a href="#时间复杂度：O-n-2" class="headerlink" title="时间复杂度：O((n^2))"></a>时间复杂度：O((n^2))</h3><p>双层for循环</p><h3 id="空间复杂度：O-n"><a href="#空间复杂度：O-n" class="headerlink" title="空间复杂度：O((n))"></a>空间复杂度：O((n))</h3><p>需要一个长度为n+1的前缀和数组</p><h1 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h1><p>然而以上解法虽然很好理解，但是通过对时间复杂度进行分析，含有两层for循环，性能受到严重影响，因此需要进行优化。</p><p>切入点当然就是针对双重for循环进行改造了，通过将if语句里的条件判断移项</p><pre><code>sum[j] = sum[i] - k</code></pre><p>也就是在计算前缀和的时候，直接记录一下有几个sum[j]和sum[i]-k相等，这样就避免了一层循环。而负责记录前缀和出现的次数则可以用哈希表。</p><p>优化后的代码如下</p><pre><code>// 优化版func subarraySum(nums []int, k int) int {    n := len(nums)    // 记录前缀和以及该前缀和出现的次数    preSum := make(map[int]int, 0)    // base case    preSum[0] = 1    // 记录答案个数    cnt := 0    // 初始化前缀和    sum0_i := 0    // 穷举所有子数组    for i := 0; i &lt; n; i++ {        sum0_i += nums[i]        // 这是我们想要找的前缀和        sum0_j := sum0_i - k        // 如果前面有这个前缀和，则直接更新答案        if times, ok := preSum[sum0_j] ; ok {            cnt += times        }        // 注意同步更新一下当前的前缀和        preSum[sum0_i] += 1    }    return cnt}</code></pre><h3 id="时间复杂度：O-n"><a href="#时间复杂度：O-n" class="headerlink" title="时间复杂度：O((n))"></a>时间复杂度：O((n))</h3><p>其中 n 为数组的长度。我们遍历数组的时间复杂度为 O((n))，中间利用哈希表查询删除的复杂度均为 O((1))，因此总时间复杂度为 O((n))。</p><h3 id="空间复杂度：O-n-1"><a href="#空间复杂度：O-n-1" class="headerlink" title="空间复杂度：O((n))"></a>空间复杂度：O((n))</h3><p>其中 n 为数组的长度。哈希表在最坏情况下可能有 nn 个不同的键值，因此需要 O((n))的空间复杂度。</p><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><p>前缀和的技巧在求解数组和问题的时候非常有用，此外，适当的运用哈希表能够在某些情况下优化时间复杂度，减少一层循环。</p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 前缀和 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【leetcode-969】煎饼排序</title>
      <link href="/2021/06/26/leetcode-969/"/>
      <url>/2021/06/26/leetcode-969/</url>
      
        <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/pancake-sorting/" target="_blank" rel="noopener">969. 煎饼排序</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一个整数数组 arr ，请使用 煎饼翻转 完成对数组的排序。</p><p>一次煎饼翻转的执行过程如下：</p><p>选择一个整数 k ，1 &lt;= k &lt;= arr.length<br>反转子数组 arr[0…k-1]（下标从 0 开始）<br>例如，arr = [3,2,1,4] ，选择 k = 3 进行一次煎饼翻转，反转子数组 [3,2,1] ，得到 arr = [1,2,3,4] 。</p><p>以数组形式返回能使 arr 有序的煎饼翻转操作所对应的 k 值序列。任何将数组排序且翻转次数在 10 * arr.length 范围内的有效答案都将被判断为正确。</p><p>示例 1：</p><pre><code>输入：[3,2,4,1]输出：[4,2,4,3]解释：我们执行 4 次煎饼翻转，k 值分别为 4，2，4，和 3。初始状态 arr = [3, 2, 4, 1]第一次翻转后（k = 4）：arr = [1, 4, 2, 3]第二次翻转后（k = 2）：arr = [4, 1, 2, 3]第三次翻转后（k = 4）：arr = [3, 2, 1, 4]第四次翻转后（k = 3）：arr = [1, 2, 3, 4]，此时已完成排序。</code></pre><p>示例 2：</p><pre><code>输入：[1,2,3]输出：[]解释：输入已经排序，因此不需要翻转任何内容。请注意，其他可能的答案，如 [3，3] ，也将被判断为正确。</code></pre><p>提示：</p><ul><li>1 &lt;= arr.length &lt;= 100</li><li>1 &lt;= arr[i] &lt;= arr.length</li><li>arr 中的所有整数互不相同（即，arr 是从 1 到 arr.length 整数的一个排列）</li></ul><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>这个问题可以分成两个部分：</p><ol><li><p>首先，我们需要先找到最大的那个煎饼，把它放到最下面，然后在剩下的n-1个煎饼中找打最大的那个，再放到最底下，这很明显可以用递归解决，因为解决问题是类似的，只是问题的规模在不断变小。</p></li><li><p>其次，就是具体怎么做才能将某块烧饼放到最下面呢？</p></li></ol><p>具体分为两步：</p><p>比如第3块烧饼是最大的，</p><ul><li>将前3块烧饼进行翻转，这样最大的烧饼就到了最上面</li><li>将前n块烧饼进行翻转，这样原来最上面的那个最大烧饼此时就到最下面</li></ul><p>至此，就实现了将某个烧饼翻转到最下面的操作。</p><p>具体代码如下：</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code>func pancakeSort(arr []int) []int {    // 先重置一下数组    res = []int{}    sortCakes(arr, len(arr))    return res}// 记录翻转操作序列var res []intfunc sortCakes(cakes []int, n int) {    // base case: 一块烧饼就不用翻了    if n == 1 {        return    }    // 寻找最大烧饼的索引    maxCake, maxCakeIndex := 0, 0    for i := 0; i &lt; n; i++ {        if cakes[i] &gt; maxCake {            maxCake = cakes[i]            maxCakeIndex = i        }    }    // 第一次翻转，将最大烧饼翻转到最上面    reverseCake(cakes, 0, maxCakeIndex)    // 记录这一次翻转，翻转前maxCakeIndex+1个    res = append(res, maxCakeIndex + 1)    // 第二次翻转，将最大烧饼翻转到最下面    reverseCake(cakes, 0, n - 1)    // 记录这一次翻转，翻转前n个    res = append(res, n)    // 递归调用，翻转剩下的烧饼    sortCakes(cakes, n - 1)}// 翻转arr[i]到arr[j]的元素func reverseCake(arr []int, i, j int)  {    for i &lt; j {        temp := arr[i]        arr[i] = arr[j]        arr[j] = temp        // 翻转下一对        i++        j--    }}</code></pre><h1 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h1><h3 id="时间复杂度：O-n-2"><a href="#时间复杂度：O-n-2" class="headerlink" title="时间复杂度：O((n^2))"></a>时间复杂度：O((n^2))</h3><p>因为递归的调用次数是n，最多处理n次将某个烧饼翻转到最下面的操作，而每次递归操作都需要寻找最大烧饼，调用一次翻转方法，所以复杂度也是n，所以总的复杂度就是O((n^2))</p><h3 id="空间复杂度：O-n-2"><a href="#空间复杂度：O-n-2" class="headerlink" title="空间复杂度：O((n^2))"></a>空间复杂度：O((n^2))</h3><p>由于用到了递归，空间复杂度就是 递归的次数 <em> 每次递归需要的栈空间，也就是 n </em> O((n)) = O((n^2))</p><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><p>这个操作结果并不是最优的，如果需要计算最短操作序列该怎么办呢？</p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【leetcode-772】基本计算器 III</title>
      <link href="/2021/06/20/leetcode-772/"/>
      <url>/2021/06/20/leetcode-772/</url>
      
        <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/basic-calculator-iii/" target="_blank" rel="noopener">772. 基本计算器 III</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>实现一个基本的计算器来计算简单的表达式字符串。</p><p>表达式字符串只包含非负整数，算符 +、-、*、/ ，左括号 ( 和右括号 ) 。整数除法需要 向下截断 。</p><p>你可以假定给定的表达式总是有效的。所有的中间结果的范围为 [-231, 231 - 1] 。</p><p>示例 1：</p><pre><code>输入：s = &quot;1+1&quot;输出：2</code></pre><p>示例 2：</p><pre><code>输入：s = &quot;6-4/2&quot;输出：4</code></pre><p>示例 3：</p><pre><code>输入：s = &quot;2*(5+5*2)/3+(6/2+8)&quot;输出：21</code></pre><p>示例 4：</p><pre><code>输入：s = &quot;(2+6*3+5-(3*14/7+2)*5)+3&quot;输出：-12</code></pre><p>示例 5：</p><pre><code>输入：s = &quot;0&quot;输出：0</code></pre><p>提示：</p><ul><li>1 &lt;= s &lt;= 104</li><li>s 由整数、’+’、’-‘、’*’、’/‘、’(‘ 和 ‘)’ 组成</li><li>s 是一个 有效的 表达式</li></ul><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>本题属于hard级别，关键在于层层拆解，化整为零，逐个击破。<br>通过拆解后需要解决以下几个问题：</p><ol><li>字符串如何转整数</li><li>如何处理加减法（栈）</li><li>如何处理乘除法（和栈顶元素结合）</li><li>如何处理括号（递归）</li></ol><p>这里值得注意的是，在处理括号的时候，需要将处理后的string和计算结果一并传回来，因为在Go语言中，string和普通变量一样是值传递，因此为了保证退出递归后，括号内的结果计算完毕后，原来字符串的整个括号部分也应该同步消掉，所以改变后的字符串也要传出来，否则会在外层会进行重复计算括号内的结果。这算是一个坑</p><p>具体代码如下：</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code>func calculate(s string) int {    res, _ := recursive(s)    return res}func recursive(s string) (int, string) {    // 用一个栈存储处理后的数字    stack := make([]int, 0)    // 初始状态默认sign是&#39;+&#39;,num是0    sign := byte(&#39;+&#39;)    num := 0    for len(s) &gt; 0 {        c := s[0]        s = s[1:]        // 如果是数字就直接转成int类型的数字        if isDigit(c) {            num = num * 10 + int(c - &#39;0&#39;)        }        // 如果是左括号就递归计算num        if c == &#39;(&#39; {            // 这里尤其需要注意的是string和普通变量一样是值传递，因此            // 为了保证退出递归后，括号内的结果计算完毕后，原来字符串的整个括号部分也应该同步消掉            // 所以改变后的字符串也要传出来，否则会在外层会进行重复计算括号内的结果            num, s = recursive(s)        }        // 如果不是数字也不是空格（说明是个运算符）或者已经走到了尽头，都将数字入栈        if !isDigit(c) &amp;&amp; c != &#39; &#39; || len(s) == 0 {            switch sign {            case &#39;+&#39;:                stack = append(stack, num)            case &#39;-&#39;:                stack = append(stack, -num)            case &#39;*&#39;:                pre := stack[len(stack)-1]                stack = stack[:len(stack)-1]                stack = append(stack, pre * num)            case &#39;/&#39;:                pre := stack[len(stack)-1]                stack = stack[:len(stack)-1]                stack = append(stack, pre  / num)            }            // 更新符号为当前符号，数字清零            num = 0            sign = c        }        // 遇到右括号返回递归结果        if c == &#39;)&#39; {            break        }    }    // 把栈中所有数字相加    return sum(stack), string(s)}func isDigit(c byte) bool {    return c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;}func sum(stack []int) int {    res := 0    for _, n := range stack {        res += n    }    return res}</code></pre><h1 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h1><h3 id="时间复杂度：O-n"><a href="#时间复杂度：O-n" class="headerlink" title="时间复杂度：O((n))"></a>时间复杂度：O((n))</h3><p>因为整个过程下来也就相当于把字符串完整遍历一遍，所以时间复杂度就是字符串的长度</p><h3 id="空间复杂度：O-n"><a href="#空间复杂度：O-n" class="headerlink" title="空间复杂度：O((n))"></a>空间复杂度：O((n))</h3><p>由于用到了递归，空间复杂度就是 递归的次数 <em> 每次递归需要的栈空间，也就是 K </em> O((n)) ，其中K是括号的个数，而每次递归开辟的栈最多也不会超过字符串的长度</p><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><p>本题属于hard类型，但是如果逐步拆解成单个问题，却又不是很难，属于非常经典的题目</p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【leetcode-15】三数之和</title>
      <link href="/2021/06/19/leetcode-15/"/>
      <url>/2021/06/19/leetcode-15/</url>
      
        <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/3sum/" target="_blank" rel="noopener">15. 三数之和</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。</p><p>注意：答案中不可以包含重复的三元组。</p><p>示例 1：</p><pre><code>输入：nums = [-1,0,1,2,-1,-4]输出：[[-1,-1,2],[-1,0,1]]</code></pre><p>示例 2：</p><pre><code>输入：nums = []输出：[]</code></pre><p>示例 3：</p><pre><code>输入：nums = [0]输出：[]</code></pre><p>提示：</p><ul><li>0 &lt;= nums.length &lt;= 3000</li><li>-105 &lt;= nums[i] &lt;= 105</li></ul><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>3sum问题其实是从2sum问题演变而来的，所以我们可以先考虑求解一个2sum问题，而对于2sum问题可以先对数组进行排序，然后利用双指针从两端逐渐向中间逼近就行了，并不难。而3Sum则可以先穷举一个数nums[i]，然后对nums[i]利用2Sum计算能得到target-nums[i]的两数组合，最后再加上nums[i]，就是我们要的三个数的组合了。</p><p>这里值得注意的是，计算2Sum的时候要把已经用掉的nums[i]排除在外，因为一个数字只能用一次。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code>// 先求两数之和func twoSum(nums []int, start, target int) [][]int {    // 用于存储结果组合    res := make([][]int, 0)    //// 先排序，确保数字有序    //sort.Ints(nums)    // 设置左右两个指针，注意这里左指针从start开始    l, r := start, len(nums) - 1    // 从左右两端向中间逼近，根据大小移动左右指针    for l &lt; r {        sum := nums[l] + nums[r]        // 记录索引l和r最初对应的值，这步很关键，下面会用到，为了避免重复        left, right := nums[l], nums[r]        if sum == target {            // 满足要求，加入集合            res = append(res, []int{nums[l], nums[r]})            // 左右指针都避开重复数字            for l &lt; r &amp;&amp; nums[l] == left  {                l++            }            for l &lt; r &amp;&amp; nums[r] == right {                r--            }        } else if sum &lt; target {            // 左指针避开重复数字            for l &lt; r &amp;&amp; nums[l] == left  {                l++            }        } else {            // 右指针避开重复数字            for l &lt; r &amp;&amp; nums[r] == right  {                r--            }        }    }    return res}func threeSum(nums []int) [][]int {    // 用于存储结果组合    res_3 := make([][]int, 0)    // 现将数组排个序    sort.Ints(nums)    // 穷举threeSum的第一个数    for i := 0; i &lt; len(nums); i++ {        // 利用twoSum计算两个数字之和为target-nums[i]的组合（这里的target为0）        // 注意，左指针从start开始，这是为了排除已经用掉的数字        res_2 := twoSum(nums, i + 1, 0 - nums[i])        // 如果存在这样的若干个二元组的话，那么把它加上nums[i]就有了若干个三元组        for _, res := range res_2 {            res = append(res, nums[i])            res_3 = append(res_3, res)        }        // 这里和twoSum一样，需要跳过重复的数字        for i &lt; len(nums) - 1 &amp;&amp; nums[i] == nums[i+1] {            i++        }    }    return res_3}</code></pre><h1 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h1><h3 id="时间复杂度：O-n-2"><a href="#时间复杂度：O-n-2" class="headerlink" title="时间复杂度：O((n^2))"></a>时间复杂度：O((n^2))</h3><p>因为2Sum使用的双指针是O((n))，然后再乘以3Sum外层的遍历O((n))就是O((n^2))</p><h3 id="空间复杂度：O-n"><a href="#空间复杂度：O-n" class="headerlink" title="空间复杂度：O((n!))"></a>空间复杂度：O((n!))</h3><p>最后的结果是一个二维数组，每个一维数组的大小都为3，最坏的情况下会有n!个这样的组合。</p><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><p>做完了这道题还可以尝试一下四数之和（4Sum），以及拓展到n个数字之和（nSum）</p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【leetcode-773】滑动谜题</title>
      <link href="/2021/06/16/leetcode-773/"/>
      <url>/2021/06/16/leetcode-773/</url>
      
        <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/sliding-puzzle/" target="_blank" rel="noopener">773. 滑动谜题</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>在一个 2 x 3 的板上（board）有 5 块砖瓦，用数字 1~5 来表示, 以及一块空缺用 0 来表示.</p><p>一次移动定义为选择 0 与一个相邻的数字（上下左右）进行交换.</p><p>最终当板 board 的结果是 [[1,2,3],[4,5,0]] 谜板被解开。</p><p>给出一个谜板的初始状态，返回最少可以通过多少次移动解开谜板，如果不能解开谜板，则返回 -1 。</p><p>示例：</p><pre><code>输入：board = [[1,2,3],[4,0,5]]输出：1解释：交换 0 和 5 ，1 步完成</code></pre><pre><code>输入：board = [[1,2,3],[5,4,0]]输出：-1解释：没有办法完成谜板</code></pre><pre><code>输入：board = [[4,1,2],[5,0,3]]输出：5解释：最少完成谜板的最少移动次数是 5 ，一种移动路径:尚未移动: [[4,1,2],[5,0,3]]移动 1 次: [[4,1,2],[0,5,3]]移动 2 次: [[0,1,2],[4,5,3]]移动 3 次: [[1,0,2],[4,5,3]]移动 4 次: [[1,2,0],[4,5,3]]移动 5 次: [[1,2,3],[4,5,0]]</code></pre><pre><code>输入：board = [[3,2,4],[1,5,0]]输出：14</code></pre><p>提示：</p><ul><li>board 是一个如上所述的 2 x 3 的数组.</li><li>board[i][j] 是一个 [0, 1, 2, 3, 4, 5] 的排列.</li></ul><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>对于求最小步数的问题，我们要敏锐得想到BFS算法，也就是层序遍历，也就是从一个起点出发，一层层地向外扩张，第一次到达终点的时候，扩张的层数就是最小步数。</p><p>只不过这道题稍微有些特殊，就是每次不是向外走一步，而是和相邻的数字交换一下。这就需要我们将和相邻数字交换这个操作转化成向相邻路径走一步。</p><p>我们这里的 board 仅仅是 2x3 的二维数组，所以可以压缩成一个一维字符串。其中比较有技巧性的点在于，二维数组有「上下左右」的概念，压缩成一维后，如何得到某一个索引上下左右的索引？</p><p>很简单，我们只要手动写出来这个映射就行了：</p><pre><code>vector&lt;vector&lt;int&gt;&gt; neighbor = {    { 1, 3 },    { 0, 4, 2 },    { 1, 5 },    { 0, 4 },    { 3, 1, 5 },    { 4, 2 }};</code></pre><p>这个含义就是，在一维字符串中，索引 i 在二维数组中的的相邻索引为 neighbor[i]，至此，我们就把这个问题完全转化成标准的 BFS 问题了，借助前文 BFS 算法框架的代码框架，直接就可以套出解法代码了。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code>func slidingPuzzle(board [][]int) int {    // 将2*3的数组转化为字符串    m, n := 2,3    start := []byte(&quot;&quot;)    target := &quot;123450&quot;    for i := 0; i &lt; m; i++ {        for j := 0; j &lt; n;j++ {            start = append(start , byte(board[i][j] + &#39;0&#39;))        }    }    // 记录一堆字符串的相邻索引    neighbor := [][]int{{1,3},{0,4,2},{1,5},{0,4},{3,1,5},{4,2}}    // 开始BFS遍历    // 定义一个队列记录当前的排列状态    q := make([][]byte, 0)    // 用一个map记录访问过的路径    visited := make(map[string]bool, 0)    // 先把当前的排列加入队列，作为起点    q = append(q, start)    visited[string(start)] = true    // 初始化步数    step := 0    for len(q) &gt; 0 {        // 注意要提前取好长度，如果在循环中len(q)，则q一直在增长，不固定        length := len(q)        for i := 0; i &lt; length; i++ {            // 取队头，判断当前排列是否达到目标            cur := q[0]            q = q[1:]            // 如果已经符合，直接返回步数            if string(cur) == target {                return step            }            // 找到当前排列中数字0的位置index            var index int            for index = 0; cur[index] != &#39;0&#39;; index++ {            }            // 依次两两交换和0相邻数字，构造新的拼图，相当于BFS向下遍历一层            for _, adj := range neighbor[index] {                // 注意需要用一个新的切片进行拷贝，否则由于Go的切片共用内存，当前的cur也会随着new_board的改变而改变                tmp_board := make([]byte,len(cur))                copy(tmp_board, cur)                new_board := tmp_board                // 交换和0相邻的数字                tmp_adj := new_board[adj]                new_board[adj] = new_board[index]                new_board[index] = tmp_adj                // 防止走回头路                if _, ok := visited[string(new_board)]; !ok {                    // 将新的拼图插入队列，用于下一次BFS遍历                    tmp := make([]byte,len(new_board))                    copy(tmp, new_board)                    q = append(q, tmp)                    visited[string(tmp)] = true                }            }        }        // 向下遍历了一层，记录步数+1        step++    }    return -1}</code></pre><h1 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h1><h3 id="时间复杂度：O-R∗C∗-R∗C"><a href="#时间复杂度：O-R∗C∗-R∗C" class="headerlink" title="时间复杂度：O(R∗C∗(R∗C)!)"></a>时间复杂度：O(R∗C∗(R∗C)!)</h3><p>BFS的时间复杂度即可能存在的状态数。</p><p>R, C 为棋盘的行数和列数。最多有 O((R∗C)!) 种可能的棋盘状态。</p><p>对于每种状态都需要进行一次append操作，而一次操作的开销就是状态的长度，也就是O(R * C)</p><h3 id="空间复杂度：O-R∗C∗-R∗C"><a href="#空间复杂度：O-R∗C∗-R∗C" class="headerlink" title="空间复杂度：O(R∗C∗(R∗C)!)"></a>空间复杂度：O(R∗C∗(R∗C)!)</h3><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><p>本题的关键在于将题目转化成BFS的条件</p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BFS </tag>
            
            <tag> leecode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【leetcode-22】括号生成</title>
      <link href="/2021/06/06/leetcode-22/"/>
      <url>/2021/06/06/leetcode-22/</url>
      
        <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/generate-parentheses/" target="_blank" rel="noopener">22. 括号生成</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。</p><p>示例 1：</p><pre><code>输入：n = 3输出：[&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;]</code></pre><p>示例 2：</p><pre><code>输入：n = 1输出：[&quot;()&quot;]</code></pre><p>提示：</p><ul><li>1 &lt;= n &lt;= 8</li></ul><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>关于括号问题，需要记住以下性质：</p><ol><li>一个“合法”括号组合的左括号数量一定等于右括号数量</li><li>对于一个“合法”的括号字符串P，从左往右算的话，肯定是左括号的数量大于等于右括号的数量，到最后左括号和右括号的数量相等。</li></ol><p>明白了以上性质，就可以把这道题转化以下问题：</p><ul><li>现在有2n个位置，每个位置可以放置字符（或者），组成的所有括号组合中，有多少个是合法的？</li></ul><p>然后我们就可以对回溯算法模版进行改造，得到以下解法：</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code>var res []stringfunc generateParenthesis(n int) []string {    // 特例直接返回    if n == 0 {        return []string{&quot;&quot;}    }    // 重置一下结果    res = []string{}    // 保存一条路径    var track string    // 回溯剪枝    backTrack(n, n, track)    return res}func backTrack(left, right int, track string)  {    // 数量小于0肯定不合法    if left &lt; 0 || right &lt; 0 {        return    }    // 如果剩下的左括号剩下的多肯定不合法，因为意味着已经用的右括号比左括号多    if left &gt; right {        return    }    // 如果左括号和右括号都恰好用完，说明得到一个合法的括号组合    if left == 0 &amp;&amp; right == 0 {        res = append(res, track)        return    }    // 尝试添加一个左括号    track += &quot;(&quot;    // 继续往下走    backTrack(left - 1, right, track)    // 撤销选择    track = track[:len(track)-1]    // 尝试添加一个右括号    track += &quot;)&quot;    // 继续往下走    backTrack(left, right - 1, track)    // 撤销选择    track = track[:len(track)-1]}</code></pre><h1 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h1><h1 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h1><p>我们的复杂度分析依赖于理解 generateParenthesis((n)) 中有多少个元素。这个分析超出了本文的范畴。</p><h1 id="空间复杂度：O-n"><a href="#空间复杂度：O-n" class="headerlink" title="空间复杂度：O((n))"></a>空间复杂度：O((n))</h1><p>除了答案数组之外，我们所需要的空间取决于递归栈的深度，每一层递归函数需要 O((1)) 的空间，最多递归 2n 层，因此空间复杂度为 O((n))。</p><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><p>括号生成也是一道非常经典的题目，关键是要知道一个合法括号组合的性质，那么问题就迎刃而解了。</p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leecode </tag>
            
            <tag> 回溯剪枝 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【leetcode-37】解数独</title>
      <link href="/2021/06/06/leetcode-37/"/>
      <url>/2021/06/06/leetcode-37/</url>
      
        <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/sudoku-solver/" target="_blank" rel="noopener">37. 解数独</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>编写一个程序，通过填充空格来解决数独问题。</p><p>数独的解法需遵循如下规则：</p><p>数字1-9在每一行只能出现一次。<br>数字1-9在每一列只能出现一次。<br>数字1-9在每一个以粗实线分隔的3x3宫内只能出现一次。（请参考示例图）<br>数独部分空格内已填入了数字，空白格用’.’表示。</p><p>示例：</p><pre><code>输入：board = [[&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],[&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],[&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],[&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],[&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]输出：[[&quot;5&quot;,&quot;3&quot;,&quot;4&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot;,&quot;1&quot;,&quot;2&quot;],[&quot;6&quot;,&quot;7&quot;,&quot;2&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;3&quot;,&quot;4&quot;,&quot;8&quot;],[&quot;1&quot;,&quot;9&quot;,&quot;8&quot;,&quot;3&quot;,&quot;4&quot;,&quot;2&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;],[&quot;8&quot;,&quot;5&quot;,&quot;9&quot;,&quot;7&quot;,&quot;6&quot;,&quot;1&quot;,&quot;4&quot;,&quot;2&quot;,&quot;3&quot;],[&quot;4&quot;,&quot;2&quot;,&quot;6&quot;,&quot;8&quot;,&quot;5&quot;,&quot;3&quot;,&quot;7&quot;,&quot;9&quot;,&quot;1&quot;],[&quot;7&quot;,&quot;1&quot;,&quot;3&quot;,&quot;9&quot;,&quot;2&quot;,&quot;4&quot;,&quot;8&quot;,&quot;5&quot;,&quot;6&quot;],[&quot;9&quot;,&quot;6&quot;,&quot;1&quot;,&quot;5&quot;,&quot;3&quot;,&quot;7&quot;,&quot;2&quot;,&quot;8&quot;,&quot;4&quot;],[&quot;2&quot;,&quot;8&quot;,&quot;7&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;6&quot;,&quot;3&quot;,&quot;5&quot;],[&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;2&quot;,&quot;8&quot;,&quot;6&quot;,&quot;1&quot;,&quot;7&quot;,&quot;9&quot;]]解释：输入的数独如上图所示，唯一有效的解决方案如下所示：</code></pre><p>提示：</p><ul><li>board.length == 9</li><li>board[i].length == 9</li><li>board[i][j] 是一位数字或者 ‘.’</li><li>题目数据 保证 输入数独仅有一个解</li></ul><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>数独也是典型的回溯剪枝算法，与N皇后问题非常类似，主要不同可能就在于一个是判断棋子合法性的方法不同，还有就是N皇后需要得到所有的解，而本题只要找到符合要求的一个解即可，因此最终返回的判定条件也有所不同。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code>func solveSudoku(board [][]byte)  {    backtrack(board, 0,0)}// 规定好边界 9*9的棋盘var m,n = 9,9func backtrack(board [][]byte, i, j int) bool {    // 如果穷举到最后一列，就换一行重新开始    if j == n {        return backtrack(board, i+1, 0)    }    // 如果找到一个可行解，直接返回    if i == m {        return true    }    // 如果当前位置已经有数字了，直接跳过    if board[i][j] != &#39;.&#39; {        return backtrack(board, i, j+1)    }    // 将1-9依次进行穷举    for ch := byte(&#39;1&#39;); ch &lt;= byte(&#39;9&#39;); ch++ {        // 尝试填入一个数字，检查填入后是否符合要求        if !isValid(board, i, j, ch) {            // 不合法，就跳过，换个数字试试            continue        }        // 走到这里说明合法了，就直接填入        board[i][j] = ch        // 继续向下遍历，如果找到一个可行解，立即结束        if backtrack(board, i, j+1) {            return true        }        // 走到这里说明填满了格子仍旧没找到可行解，回退一格        board[i][j] = &#39;.&#39;    }    // 穷举完1-9，仍旧没有找到可行解    // 需要前面的格子换个数字穷举    return false}// 判断board[i][j]是否可以填入数字chfunc isValid(board [][]byte, row, col int, ch byte) bool {    for i := 0; i &lt; 9; i++ {        // 判断同行是否重复        if board[row][i] == ch {            return false        }        // 判断同列是否重复        if board[i][col] == ch {            return false        }        // 判断同单元（3*3）是否重复        // 这里需要一点技巧，需要找到当前格子所在单元的起始格子，然后依次遍历        // [0,0]、[0,1]、[0,2]、[1,0]、[1,1]、[1,2]、[2,0]、[2,1]、[2,2]、        if board[(row/3)*3+i/3][(col/3)*3+i%3] == ch {            return false        }    }    return true}</code></pre><h1 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h1><h3 id="时间复杂度：O-9-M"><a href="#时间复杂度：O-9-M" class="headerlink" title="时间复杂度：O((9^M))"></a>时间复杂度：O((9^M))</h3><p>在最坏的情况下，需要对每个空着的格子枚举9个数，所以时间复杂度就是O((9^M))，其中M是棋盘中空着的格子数量。</p><p>当然在实际情况下复杂度并没有这么高，因为很多数字不需要穷举所有可能，因为当我们找到一个可行的解的时候就结束了，后续的递归都没有展开。所以这个O((9^M))的时间复杂度实际上是完全穷举，或者说是找到所有可行解的时间复杂度。</p><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><p>数独也是典型的回溯剪枝算法，与N皇后问题非常类似，建议一起做，对比着看。</p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leecode </tag>
            
            <tag> 回溯剪枝 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【leetcode-77】组合</title>
      <link href="/2021/06/06/leetcode-77/"/>
      <url>/2021/06/06/leetcode-77/</url>
      
        <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/combinations/" target="_blank" rel="noopener">78. 子集</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。</p><p>示例:</p><pre><code>输入: n = 4, k = 2输出:[  [2,4],  [3,4],  [2,3],  [1,2],  [1,3],  [1,4],]</code></pre><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>这道题其实与 <a href="https://leetcode-cn.com/problems/subsets/" target="_blank" rel="noopener">78.子集</a> 非常相似，也是属于回溯算法，主要不同在于遍历决策树的时候子集是所有节点都算是子集，都需要更新res，而组合则是只有在到达叶子节点时才算是一种组合，才需要更新res。实际上77、78和46三道题可以一起看，感受其中的相同与不同，因为这三道都是典型的回溯算法。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code>// 记录所有组合var res [][]intfunc combine(n int, k int) [][]int {    // 先重置一下结果    res = [][]int{}    // 特殊情况直接返回    if k &lt;= 0 || n &lt;= 0 {        return res    }    // 记录一条路径    track := make([]int, 0)    // 开始回溯    backtrack(n, k, 1, track)    return res}func backtrack(n, k, start int, track []int) {    // 如果已经到达叶子节点，说明已经有了一种组合，记录下来    if len(track) == k {        temp := make([]int, len(track))        copy(temp, track)        res = append(res, temp)        return    }    // 从start开始继续遍历    for i := start; i &lt;= n; i++ {        // 选择把节点i加入        track = append(track, i)        // 继续向下遍历        backtrack(n, k, i+1,track)        // 回退一层        track = track[:len(track)-1]    }}</code></pre><h1 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h1><h3 id="时间复杂度：O-n-2-n"><a href="#时间复杂度：O-n-2-n" class="headerlink" title="时间复杂度：O((n * 2^n))"></a>时间复杂度：O((n * 2^n))</h3><p>时间复杂度就是决策树节点总数，因为每个节点至少遍历一次，也就是2^n，但是由于每次遍历到叶子节点都需要把当前路径track做一次append操作，也是O((n))的时间复杂度，所以总的时间复杂度就是O((n * 2^n))</p><h3 id="空间复杂度：O-n-2-n"><a href="#空间复杂度：O-n-2-n" class="headerlink" title="空间复杂度：O((n * 2^n))"></a>空间复杂度：O((n * 2^n))</h3><p>空间复杂度就是最后返回的结果res所占的空间也就是所有的状态树，对应决策树的所有状态所占的空间：</p><p>O((2^n)) <em> n = O((n </em> 2^n))</p><p>最多有2^((n-1))个状态，每个状态最多占用大小为n的空间（相当于全集）</p><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><p>实际上<strong>78.子集</strong>、<strong>77.组合</strong>、和<strong>46.排列</strong>三道题可以一起看，感受其中的相同与不同，因为这三道都是典型的回溯算法。</p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leecode </tag>
            
            <tag> 回溯剪枝 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【leetcode-78】子集</title>
      <link href="/2021/06/05/leetcode-78/"/>
      <url>/2021/06/05/leetcode-78/</url>
      
        <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/subsets/" target="_blank" rel="noopener">78. 子集</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。</p><p>解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。</p><p>示例 1：</p><pre><code>输入：nums = [1,2,3]输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</code></pre><p>示例 2：</p><pre><code>输入：nums = [0]输出：[[],[0]]</code></pre><p>提示：</p><ul><li>1 &lt;= nums.length &lt;= 10</li><li>-10 &lt;= nums[i] &lt;= 10</li><li>nums 中的所有元素 互不相同</li></ul><h1 id="解体思路"><a href="#解体思路" class="headerlink" title="解体思路"></a>解体思路</h1><p>对于子集问题可以采用穷举的方式解决，而回溯算法本质就是进行穷举，可以认为是暴力穷举的一种优化。所以本题我们可以采取回溯算法。</p><p>回溯算法无非就是构造一棵决策树，而对于本题的决策树如下：</p><p><img src="https://vegard-bear.github.io/images/leetcode-78.png" alt></p><p>然后我们根据这个改造回溯算法的模版就好了</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code>// 保存所有子集合var res [][]intfunc subsets(nums []int) [][]int {    // 上来先重置一下集合    res = [][]int{}    // 记录一条路径    track := make([]int, 0)    // 回溯剪枝    backTrack(nums, 0, track)    return res}func backTrack(nums []int, start int, track []int)  {    // 上来就放一条路径，因为这个决策树比较特殊，不只是到叶子节点才算一条完整路径，    // 而是从根节点出发到每一个节点的路径都算一个子集    //res := append(res, track)    // 注意：这里不能直接append，因为切片底层共用数据，    // 这意味着下面切片path一旦改变了，res也会随之改变，而这不是我们希望看到的    // 所以只能重新开辟一个新的切片将内容拷贝过去    tmp := make([]int, len(track))    copy(tmp, track)    res = append(res, tmp)    // 依次开始做选择，注意从上一层遍历走到位置出发    for i := start; i &lt; len(nums); i++ {        // 把当前这个节点加入路径        track = append(track, nums[i])        // 继续向下层遍历，注意i+1        backTrack(nums, i + 1, track)        // 回退一层，把刚刚做的选择拿掉，相当于剪枝        track = track[:len(track)-1]    }}</code></pre><h1 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h1><h3 id="时间复杂度：O-n-2-n"><a href="#时间复杂度：O-n-2-n" class="headerlink" title="时间复杂度：O((n * 2^n))"></a>时间复杂度：O((n * 2^n))</h3><p>时间复杂度就是决策树节点总数因为每个节点至少遍历一次，也就是2^n，但是由于每次遍历一个节点都需要把当前路径track做一次append操作，也是O((n))的时间复杂度，所以总的时间复杂度就是O((n * 2^n))</p><h3 id="空间复杂度：O-n-2-n"><a href="#空间复杂度：O-n-2-n" class="headerlink" title="空间复杂度：O((n * 2^n))"></a>空间复杂度：O((n * 2^n))</h3><p>空间复杂度就是最后返回的结果res所占的空间也就是所有的状态树，对应决策树的所有状态所占的空间：</p><p>O((2^n)) <em> n = O((n </em> 2^n))</p><p>最多有2^n个状态，每个状态最多占用大小为n的空间（相当于全集）</p><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><p>所有的穷举问题都可以采取回溯算法解决，比如子集问题，然后我们根据题意改造回溯算法的模版就好了。</p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leecode </tag>
            
            <tag> 回溯剪枝 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【leetcode-234】回文链表</title>
      <link href="/2021/05/30/leetcode-234/"/>
      <url>/2021/05/30/leetcode-234/</url>
      
        <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/palindrome-linked-list/" target="_blank" rel="noopener">234. 回文链表</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>请判断一个链表是否为回文链表。</p><p>示例 1:</p><pre><code>输入: 1-&gt;2输出: false</code></pre><p>示例 2:</p><pre><code>输入: 1-&gt;2-&gt;2-&gt;1输出: true</code></pre><ul><li>进阶：<br>你能否用O((n)) 时间复杂度和 O((1)) 空间复杂度解决此题？</li></ul><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>这道题我们用两种解法，第一种是采用借助递归的堆栈把链表节点放入一个栈，然后再拿出来，这时候元素的顺序是反的，空间复杂度是O((n))，类似于二叉树的后序遍历。</p><p>第二种则进一步优化了空间复杂度为O((1))，具体采用同三步走：</p><ol><li>先通过“双指针技巧”中的快、慢指针来找到链表的中点</li><li>从链表的中点开始反转后面的链表</li><li>设置两个指针分别指向头节点和反转后子链表的头节点，两两比较回文串</li></ol><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="解法一-利用递归函数堆栈"><a href="#解法一-利用递归函数堆栈" class="headerlink" title="解法一: 利用递归函数堆栈"></a>解法一: 利用递归函数堆栈</h2><pre><code>// 左侧指针var left *ListNodefunc isPalindrome(head *ListNode) bool {    // 左侧指针初始指向头节点    left = head    return traverse(head)}// 利用递归，倒序遍历单链表func traverse(right *ListNode) bool {    // 右指针已经到了链表结尾，也就是最右边，可以直接返回了    if right == nil {        return true    }    // 有指针没到结尾，继续向右寻找    res := traverse(right.Next)    // 开始头尾两两成对比较，注意当前比较要带上上一次比较的结果    res = res &amp;&amp; (left.Val == right.Val)    // 继续比较下一组    // 注意left要向右边移动，right则是利用递归返回，相当于向左移动    left = left.Next    return res}</code></pre><h2 id="解法二-快慢指针-反转链表"><a href="#解法二-快慢指针-反转链表" class="headerlink" title="解法二: 快慢指针 + 反转链表"></a>解法二: 快慢指针 + 反转链表</h2><pre><code>func isPalindrome(head *ListNode) bool {    // 第一步先利用快慢指针找到链表中点    slow, fast := head, head    for fast != nil &amp;&amp; fast.Next != nil {        slow = slow.Next        fast = fast.Next.Next    }    // slow 指针此时指向链表中点    // 对于奇数个节点的链表，中间那个节点不需要做匹配，直接跳过    // 而如果fast指针没有指向nil，说明链表长度为奇数    if fast != nil {        slow = slow.Next    }    // 第二步是从slow开始反转后面的链表，然后就可以两两配对了    left := head    right := reverse(slow)    // 此时right指向反转后子链表的头节点    for right != nil {        // 依次两两比较        if left.Val != right.Val {            return false        }        left = left.Next        right = right.Next    }    return true}// 反转以head为头的链表，返回反转后的头节点func reverse(head *ListNode) *ListNode  {    // 设置前驱节点和当前节点，原来的前驱节点会作为新的后继节点，所以初始设置为nil    var pre, cur *ListNode    pre, cur = nil, head    // 开始依次反转    for cur != nil {        // 先暂存后继节点        next := cur.Next        // 原来的前驱节点会作为新的后继节点        cur.Next = pre        // 当前节点作为前驱节点，后继节点作为新的当前节点，相当于整体向后移动一位        pre = cur        cur = next    }    return pre}</code></pre><h1 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h1><h3 id="时间复杂度：O-N"><a href="#时间复杂度：O-N" class="headerlink" title="时间复杂度：O((N))"></a>时间复杂度：O((N))</h3><p>解法一和解法二都需要遍历整个链表，所以时间复杂度都是O((n))</p><h3 id="空间复杂度：O-1-O-n"><a href="#空间复杂度：O-1-O-n" class="headerlink" title="空间复杂度：O((1))/O((n))"></a>空间复杂度：O((1))/O((n))</h3><ul><li><p>解法一利用的是递归函数的堆栈，堆栈的深度即链表的长度，所以是O((n))。</p></li><li><p>解法二不需要开辟额外的空间，采用的是就地反转链表，空间复杂度是O((1))</p></li></ul><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><p>寻找回文串是从中间向两端扩展，判断回文串是从两端向中间收缩。对于单链表，无法直接倒序遍历，因此可以考虑对链表进行反转。比如用栈结构倒序处理链表。</p><p>对于回文链表，由于回文的特殊性，可以不完全反转链表，而是仅仅反转部分链表，将空间复杂度降到O(1)</p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【leetcode-239】滑动窗口最大值</title>
      <link href="/2021/05/23/leetcode-239/"/>
      <url>/2021/05/23/leetcode-239/</url>
      
        <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/sliding-window-maximum/" target="_blank" rel="noopener">239. 滑动窗口最大值</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p><p>返回滑动窗口中的最大值。</p><p>示例 1：</p><pre><code>输入：nums = [1,3,-1,-3,5,3,6,7], k = 3输出：[3,3,5,5,6,7]解释：滑动窗口的位置                最大值---------------               -----[1  3  -1] -3  5  3  6  7       3 1 [3  -1  -3] 5  3  6  7       3 1  3 [-1  -3  5] 3  6  7       5 1  3  -1 [-3  5  3] 6  7       5 1  3  -1  -3 [5  3  6] 7       6 1  3  -1  -3  5 [3  6  7]      7</code></pre><p>示例 2：</p><pre><code>输入：nums = [1], k = 1输出：[1]示例 3：输入：nums = [1,-1], k = 1输出：[1,-1]示例 4：输入：nums = [9,11], k = 2输出：[11]示例 5：输入：nums = [4,-2], k = 2输出：[4]</code></pre><p>提示：</p><ul><li>1 &lt;= nums.length &lt;= 105</li><li>-104 &lt;= nums[i] &lt;= 104</li><li>1 &lt;= k &lt;= nums.length</li></ul><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>这道题不复杂，难点在于如何在 O(1) 时间算出每个「窗口」中的最大值，使得整个算法在线性时间完成。</p><p>在一堆数字中，已知最值，如果给这堆数添加一个数，那么比较一下就可以很快算出最值；但如果减少一个数，就不一定能很快得到最值了，而要遍历所有数重新找最值。</p><p>回到这道题的场景，每个窗口前进的时候，要添加一个数同时减少一个数，所以想在 O(1) 的时间得出新的最值，就需要「单调队列」这种特殊的数据结构来辅助了。</p><p>单调队列的最大的特性在于队列内的元素全部是单调递增或者单调递减的。这个主要通过每次在队尾插入新元素的时候做一些额外的操作来实现。</p><p>也就是将队列传统的push方法做一些小的改动就可以</p><pre><code>// 实现单调队列的push方法，注意传引用func (mq *MonotonicQueue) push(n int)  {    // 依旧是从队尾插入，但注意需要把前面比自己小的元素都删掉    for len(mq.q) &gt; 0 &amp;&amp; mq.q[len(mq.q)-1] &lt; n {        // 只要当前队尾元素比要插入的元素小，就删掉        mq.q = mq.q[:len(mq.q)-1]    }    // 直到所有小的元素都删掉后再插入元素    mq.q = append(mq.q, n)}</code></pre><p>此外，我们还需要补充max和pop方法</p><pre><code>// 获取单调队列的最大值func (mq MonotonicQueue) max() int {    // 因为是单调队列，所以最大元素就是队首元素，直接取出来就好了    return mq.q[0]}// 实现单调队列的pop方法，注意传引用func (mq *MonotonicQueue) pop(n int)  {    // 因为队要删除的素可能在push的时候为了保持单调性已经被删掉，所以要确认有再pop    if mq.q[0] == n {        mq.q = mq.q[1:]    }}</code></pre><p>至此，我们就实现了本题中单调队列所需的所有方法，然后就可以借助这个单调队列完成题目了，完整代码如下</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code>// 用切片模拟单调队列type MonotonicQueue struct {    q []int}// 实现单调队列的push方法，注意传引用func (mq *MonotonicQueue) push(n int)  {    // 依旧是从队尾插入，但注意需要把前面比自己小的元素都删掉    for len(mq.q) &gt; 0 &amp;&amp; mq.q[len(mq.q)-1] &lt; n {        // 只要当前队尾元素比要插入的元素小，就删掉        mq.q = mq.q[:len(mq.q)-1]    }    // 直到所有小的元素都删掉后再插入元素    mq.q = append(mq.q, n)}// 获取单调队列的最大值func (mq MonotonicQueue) max() int {    // 因为是单调队列，所以最大元素就是队首元素，直接取出来就好了    return mq.q[0]}// 实现单调队列的pop方法，注意传引用func (mq *MonotonicQueue) pop(n int)  {    // 因为队要删除的素可能在push的时候为了保持单调性已经被删掉，所以要确认有再pop    if mq.q[0] == n {        mq.q = mq.q[1:]    }}func maxSlidingWindow(nums []int, k int) []int {    // 用单调队列维护一个滑动窗口    window := MonotonicQueue{}    // 存放结果    res := make([]int, 0)    // 先填满窗口的前k-1个元素    i := 0    for ;i &lt; k-1; i++ {        window.push(nums[i])    }    // 开始遍历数组，依次加入新数字    for  ;i &lt; len(nums); i++ {        // 窗口向前滑动，加入新数字        window.push(nums[i])        // 获取当前滑动窗口的最大值也就是单调队列的最大值        res = append(res, window.max())        // 左边界向前移动一位        // 注意因为当前新的右边界数字下标是i，而窗口大小是k，所以左边界的数字下标是i-k+1，        window.pop(nums[i-k+1])    }    // 返回结果    return res}</code></pre><h1 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h1><h3 id="时间复杂度：O-N"><a href="#时间复杂度：O-N" class="headerlink" title="时间复杂度：O((N))"></a>时间复杂度：O((N))</h3><p>单独看 push 操作的复杂度确实不是 O((1))，但是算法整体的复杂度依然是 O((N)) 线性时间。要这样想，nums 中的每个元素最多被 push_back 和 pop_back 一次，没有任何多余操作，所以整体的复杂度还是 O((N))</p><h3 id="空间复杂度：O-K"><a href="#空间复杂度：O-K" class="headerlink" title="空间复杂度：O((K))"></a>空间复杂度：O((K))</h3><p>空间复杂度就很简单了，就是窗口的大小 O((k))。</p><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><p>滑动窗口问题是一个非常经典的问题，并且难度是Hard，但是通过引入一个单调队列，维护一个滑动窗口，本题就引刃而解。</p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> queue </tag>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【leetcode-236】二叉树的最近公共祖先</title>
      <link href="/2021/05/22/leetcode-236/"/>
      <url>/2021/05/22/leetcode-236/</url>
      
        <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/" target="_blank" rel="noopener">236. 二叉树的最近公共祖先</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p>示例 1：</p><pre><code>输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1输出：3解释：节点 5 和节点 1 的最近公共祖先是节点 3 。</code></pre><p>示例 2：</p><pre><code>输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4输出：5解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。</code></pre><p>示例 3：</p><pre><code>输入：root = [1,2], p = 1, q = 2输出：1</code></pre><p>提示：</p><ul><li>树中节点数目在范围 [2, 105] 内。</li><li>-109 &lt;= Node.val &lt;= 109</li><li>所有 Node.val 互不相同 。</li><li>p != q</li><li>p 和 q 均存在于给定的二叉树中。</li></ul><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>对于二叉树问题，最常用的就是前中后序遍历。所以我们上来先把这个框架写出来：</p><pre><code>func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {    left := lowestCommonAncestor(root.left, p, q)    right := lowestCommonAncestor(root.right, p, q)}</code></pre><p>这里我们选择的是后序遍历，因为后续遍历是从上往下走，就好比是从p和q出发往上走，第一次相交的节点就是这个root，那么这个root必定是公共祖先。</p><p>接下来我们就要分情况讨论了。</p><ul><li><p>情况一：<br>如果根节点本身就是p或者q节点，那么另一个节点必定在其子树中，所以公共节点就是根节点。</p></li><li><p>情况二：<br>如果p和q都在以root为根的树中，那么left和right一定分别是p和q，此时他们的最近公共祖先就是根节点。这个是由后序遍历的特点决定的，在上文中已经有说明。</p></li><li><p>情况三：<br>如果p和q都在左子树或者右子树中，那么直接返回左子树或者右子树遍历的结果。</p></li></ul><p>想清楚这几种情况，就可以开始直接写题解了。另外插一句，就是在解题的时候我们其实很难把所有细节都想得明明白白，而是心中有了个大致的思路其实就可以开始动手写代码，先确定框架，再补充细节，先保证写出一个能够AC的代码，后面再想着怎么去进一步优化细节，提高时间复杂度和空间复杂度，而不是上来就要做一个完美的解法，先从无到有，在从有到优，这也比较符合实际生产环境中敏捷开发，快速迭代的思想。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code>/** * Definition for a binary tree node. * type TreeNode struct { *     Val int *     Left *TreeNode *     Right *TreeNode * } */func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {    // base case    if root == nil {        return nil    }    // 如果根节点本身就是p或者q节点，那么另一个节点必定在其子树中，所以公共节点就是根节点    if root == p || root == q {        return root    }    // 遍历左右子树    left := lowestCommonAncestor(root.Left, p, q)    right := lowestCommonAncestor(root.Right, p, q)    // 如果p和q都在以root为根的树中，那么left和right一定分别是p和q，此时他们的最近公共祖先就是根节点    if left != nil &amp;&amp; right != nil {        return root    }    // p和q都在右子树中    if left == nil {        return right    }    // p和q都在左子树中    return left}</code></pre><h1 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h1><h3 id="时间复杂度：O-N"><a href="#时间复杂度：O-N" class="headerlink" title="时间复杂度：O((N))"></a>时间复杂度：O((N))</h3><p>其中 N 是二叉树的节点数。二叉树的所有节点有且只会被访问一次，因此时间复杂度为 O((N))。</p><h3 id="空间复杂度：O-N"><a href="#空间复杂度：O-N" class="headerlink" title="空间复杂度：O((N))"></a>空间复杂度：O((N))</h3><p>其中 N 是二叉树的节点数。递归调用的栈深度取决于二叉树的高度，二叉树最坏情况下为一条链，此时高度为 N，因此空间复杂度为 O((N))。</p><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><p>本题难度不大，但是非常经典，值得反复练习。</p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【leetcode-297】二叉树的序列化和反序列化</title>
      <link href="/2021/05/16/leetcode-297/"/>
      <url>/2021/05/16/leetcode-297/</url>
      
        <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/" target="_blank" rel="noopener">297. 二叉树的序列化与反序列化</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。</p><p>请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p><p>提示: 输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。</p><p>示例 1：</p><p><img src="https://assets.leetcode.com/uploads/2020/09/15/serdeser.jpg" alt></p><pre><code>输入：root = [1,2,3,null,null,4,5]输出：[1,2,3,null,null,4,5]</code></pre><p>示例 2：</p><pre><code>输入：root = []输出：[]</code></pre><p>示例 3：</p><pre><code>输入：root = [1]输出：[1]</code></pre><p>示例 4：</p><pre><code>输入：root = [1,2]输出：[1,2]</code></pre><p>提示：</p><ul><li>树中结点数在范围 [0, 104] 内</li><li>-1000 &lt;= Node.val &lt;= 1000</li></ul><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>这道题我们将用前序、后序、层序遍历三种方式进行解答。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>共用数据结构</p><pre><code>const SEP = &quot;,&quot;const NULL = &quot;#&quot;// 序列化后的二叉树用一个字符串切片暂存type Codec struct {    List []string}// 构造方法func Constructor() Codec {    return Codec{}}</code></pre><h2 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h2><pre><code>// Serializes a tree to a single string.func (this *Codec) serialize(root *TreeNode) string {    this.serializeList(root)    // 将字符化的节点用分隔符拼接成字符串    return strings.Join(this.List, SEP)}// 前序遍历func (this *Codec) serializeList(root *TreeNode)  {    // 遍历根    if root == nil {        this.List = append(this.List, NULL)        return    }    // 注意别忘了append    this.List = append(this.List, strconv.Itoa(root.Val))    // 遍历左右子树    this.serializeList(root.Left)    this.serializeList(root.Right)}// Deserializes your encoded data to tree.func (this *Codec) deserialize(data string) *TreeNode {    // 用一个字符串切片暂存    this.List = []string{}    // 按照分隔符拆分切片    for _, v := range strings.Split(data, SEP) {        this.List = append(this.List, v)    }    return this.deserializeList()}//func (this *Codec) deserializeList() *TreeNode {    if len(this.List) == 0 {        return nil    }    // 前序遍历，第一个节点必定是根节点    first := this.List[0]    this.List = this.List[1:]    if first == NULL {        return nil    }    // 构造根节点    root := new(TreeNode)    root.Val, _ = strconv.Atoi(first)    // 遍历左右子树    root.Left = this.deserializeList()    root.Right = this.deserializeList()    return  root}</code></pre><h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h2><pre><code>// Serializes a tree to a single string.func (this *Codec) serialize(root *TreeNode) string {    this.serializeList(root)    // 将字符化的节点用分隔符拼接成字符串    return strings.Join(this.List, SEP)}// 后序遍历与前序遍历比序列化只需变换一下次序就行func (this *Codec) serializeList(root *TreeNode)  {    // 遍历根，注意先判空，否则会报空指针异常    if root == nil {        this.List = append(this.List, NULL)        return    }    // 遍历左右子树    this.serializeList(root.Left)    this.serializeList(root.Right)    // 注意别忘了append    this.List = append(this.List, strconv.Itoa(root.Val))}// Deserializes your encoded data to tree.func (this *Codec) deserialize(data string) *TreeNode {    // 用一个字符串切片暂存    this.List = []string{}    // 按照分隔符拆分切片    for _, v := range strings.Split(data, SEP) {        this.List = append(this.List, v)    }    return this.deserializeList()}//func (this *Codec) deserializeList() *TreeNode {    if len(this.List) == 0 {        return nil    }    // 后序遍历，最后一个节点必定是根节点    first := this.List[len(this.List)-1]    this.List = this.List[:len(this.List)-1]    if first == NULL {        return nil    }    // 构造根节点    root := new(TreeNode)    root.Val, _ = strconv.Atoi(first)    // 遍历左右子树，注意先右后左    root.Right = this.deserializeList()    root.Left = this.deserializeList()    return  root}</code></pre><h2 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h2><pre><code>// Serializes a tree to a single string.func (this *Codec) serialize(root *TreeNode) string {    // 层序遍历需要用一个队列记录遍历顺序    var queue []*TreeNode    // 将根节点入队    queue = append(queue, root)    // 记录节点    var list []string    // 只要队列不为空    for len(queue) &gt; 0 {        // 取出队首元素        node := queue[0]        queue = queue[1:]        if node == nil {            list = append(list, NULL)            // 如果是空节点直接返回            continue        }        // 将节点值转成string加入字符串        list = append(list, strconv.Itoa(node.Val))        // 将当前节点的左右子节点依次加入队列        queue = append(queue, node.Left, node.Right)    }    // 最后把所有字符拼起来    return strings.Join(list, SEP)}// Deserializes your encoded data to tree.func (this *Codec) deserialize(data string) *TreeNode {    // 先按照分隔符拆成node切片    nodes := strings.Split(data, SEP)    // 根节点为空，直接返回    if nodes[0] == NULL {        return nil    }    // 先初始化根节点    root := new(TreeNode)    root.Val, _ = strconv.Atoi(nodes[0])    // 创建队列，加入根节点，开始层序遍历    var queue []*TreeNode    queue = append(queue, root)    // 只要队列不为空    for i := 0; len(queue) &gt; 0; {        // 取出队头        parent := queue[0]        queue = queue[1:]        // 构建左子树        i++        left := nodes[i]        if left != NULL {            // 不是空节点则创建新的子节点            node := new(TreeNode)            node.Val, _ = strconv.Atoi(left)            parent.Left = node            // 将左儿子加入队列            queue = append(queue, parent.Left)        }        // 构建右子树        i++        right := nodes[i]        if right != NULL {            // 不是空节点则创建新的子节点            node := new(TreeNode)            node.Val, _ = strconv.Atoi(right)            parent.Right = node            // 将左儿子加入队列            queue = append(queue, parent.Right)        }    }    return root}</code></pre><h1 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h1><h3 id="时间复杂度：O-n"><a href="#时间复杂度：O-n" class="headerlink" title="时间复杂度：O((n))"></a>时间复杂度：O((n))</h3><p>每个节点均访问一次，所以时间复杂度就是O((n))</p><h3 id="空间复杂度：O-n"><a href="#空间复杂度：O-n" class="headerlink" title="空间复杂度：O((n))"></a>空间复杂度：O((n))</h3><p>需要开辟一个栈或者队列空间，最坏情况下栈和队列的长度为节点个数。</p><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><ul><li>注意前序遍历喝后序遍历的区别，后序遍历与前序遍历很像，只需要对遍历顺序进行一些调整即可</li><li>层序遍历本质就是队列，出队和入队</li><li>判断空节点是非常频繁的操作</li><li>本题无法使用中序，因为要进行反序列化首先要找到根节点，而中序遍历的根节点无法确定具体位置</li></ul>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【leetcode-222】完全二叉树的节点个数</title>
      <link href="/2021/04/18/leetcode-222/"/>
      <url>/2021/04/18/leetcode-222/</url>
      
        <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/count-complete-tree-nodes/" target="_blank" rel="noopener">222. 完全二叉树的节点个数</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。</p><p>完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。</p><p>示例 1：</p><pre><code>输入：root = [1,2,3,4,5,6]输出：6</code></pre><p>示例 2：</p><pre><code>输入：root = []输出：0</code></pre><p>示例 3：</p><pre><code>输入：root = [1]输出：1</code></pre><p>提示：</p><ul><li>树中节点的数目范围是[0, 5 * 104]</li><li>0 &lt;= Node.val &lt;= 5 * 104</li><li>题目数据保证输入的树是完全二叉树</li></ul><p>进阶：遍历树来统计节点是一种时间复杂度为 O(n) 的简单解决方案。你可以设计一个更快的算法吗？</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>完全二叉树是一类特殊的二叉树，它介于满二叉树和普通二叉树之间。如果是满二叉树的话，很简单，直接计算出它的<strong>高度</strong>就行了，然后节点数就等于2^<strong>高度</strong>-1。但如果不是一棵满二叉树，则可以直接按照普通二叉树的方法求解。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code>func countNodes(root *TreeNode) int {    // 先通过比较左右子树的高度判断是否是一棵满二叉树    l, r := root, root    hl, hr := 0, 0    for l != nil {        l = l.Left        hl++    }    for r != nil {        r = r.Right        hr++    }    // 左子树高度等于右子树高度，则是一棵满二叉树    // 满二叉树的节点数 = 2^高度 - 1    if hl == hr {        return int(math.Pow(2, float64(hl))) - 1    }    // 如果不是一棵满二叉树，则按普通二叉树的逻辑计算    return 1 + countNodes(root.Left) + countNodes(root.Right)}</code></pre><h1 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h1><h3 id="时间复杂度：O-1"><a href="#时间复杂度：O-1" class="headerlink" title="时间复杂度：O((1))"></a>时间复杂度：O((1))</h3><p>首先计算树的高度的时间复杂度是logN，然后对树进行递归的话，表面上是N，但实际上是logN，因为最多只有其中一棵子树的递归会真正进行下去，而另一棵一定会触发hl=hr，然后直接返回，这是因为一棵完全二叉树的两棵子树，至少又一棵是满二叉树。<br>综上，时间复杂度就是logNlogN</p><h3 id="空间复杂度：O-n"><a href="#空间复杂度：O-n" class="headerlink" title="空间复杂度：O((n))"></a>空间复杂度：O((n))</h3><p>递归的空间复杂度为<strong>递归的次数</strong> <em> <strong>每次递归的空间复杂度</strong>，<br>也就是 n </em> O((1)) = O((n))</p><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><p>一棵完全二叉树的两棵子树，至少又一棵是满二叉树。</p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> tree </tag>
            
            <tag> 完全二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【leetcode】二叉搜索树系列</title>
      <link href="/2021/04/18/leetcode-bst/"/>
      <url>/2021/04/18/leetcode-bst/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本节是一个系列，包括二叉树几种常用的算法操作（判断、搜索、插入，删除）。除了删除操作之外，其他操作都比较简单，这里就不给出具体的解题思路了，直接上代码应该也能看懂。为了方便理解，这里给出的题目顺序是从难到易的。</p></blockquote><h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/search-in-a-binary-search-tree/" target="_blank" rel="noopener">700. 二叉搜索树中的搜索</a></p><p><a href="https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/" target="_blank" rel="noopener">701. 二叉搜索树中的插入操作</a></p><p><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener">98. 验证二叉搜索树</a></p><p><a href="https://leetcode-cn.com/problems/delete-node-in-a-bst/" target="_blank" rel="noopener">450. 删除二叉搜索树中的节点</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>见leetcode。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>略。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><pre><code>func searchBST(root *TreeNode, val int) *TreeNode {    if root == nil {        return nil    } else if root.Val == val {        return root    }    if root.Val &lt; val {        return searchBST(root.Right, val)    } else {        return searchBST(root.Left, val)    }}</code></pre><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><pre><code>func insertIntoBST(root *TreeNode, val int) *TreeNode {    // 找到空位置插入新节点    if root == nil {        return &amp;TreeNode{val,nil, nil}    }    // val小，则插入左子树    if val &lt; root.Val {        root.Left = insertIntoBST(root.Left, val)    } else {        root.Right = insertIntoBST(root.Right, val)    }    return root}</code></pre><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><pre><code>var pre = math.MinInt32-1func isValidBST(root *TreeNode) bool  {    // 初始化前驱节点的值，设置为最小    pre = math.MinInt32-1    return ValidBST(root)}// 搜索二叉树按照左-根-右的顺序遍历得到一定是一个有序数组func ValidBST(root *TreeNode) bool {    // 节点为空，默认符合条件    if root == nil {        return true    }    // 判断左子树    if !ValidBST(root.Left) {        return false    }    // 如果当前节点的值比前驱节点的值小，则不合法    if root.Val &lt;= pre {        return false    }    // 更新pre的值    pre = root.Val    // 判断右子树    return ValidBST(root.Right)}</code></pre><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><pre><code>func deleteNode(root *TreeNode, key int) *TreeNode {    // 如果节点是空，直接返回    if root == nil {        return nil    }    // 假设已经找到了要删除的节点，执行删除操作    if root.Val == key {        // 如果左子树为空或者右子树为空，则用另一个孩子直接接替自己的位置        if root.Left == nil {            return root.Right        }        if root.Right == nil {            return root.Left        }        // 左右子树都不为空，需要找到左子树中最大或者右子树中最小的节点替换自己        // 这里我们选择右子树中最小的节点        minNode := getMin(root.Right)        // 用最小节点替换自己        root.Val = minNode.Val        // 替换完成后把用于替换的节点删掉，防止重复        root.Right = deleteNode(root.Right, minNode.Val)    } else if root.Val &gt; key {        // 目标值小于根节点的值，去左子树中找        root.Left = deleteNode(root.Left, key)    } else {        // 右子树中找        root.Right = deleteNode(root.Right, key)    }    return root}// 二叉搜索树中最小的节点一定是最左侧的节点func getMin(root *TreeNode) *TreeNode {    for root.Left != nil {        root = root.Left    }    return root}</code></pre><h1 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h1><p>略。</p><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><p>删除操作需要考虑的情况相对较复杂，需要多多练习。</p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> tree </tag>
            
            <tag> 二叉搜索树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Go 源码解析14】调度器</title>
      <link href="/2021/04/05/go-sourcecode-gmp/"/>
      <url>/2021/04/05/go-sourcecode-gmp/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Go 语言在并发编程方面有强大的能力，这离不开语言层面对并发编程的支持。本节会介绍 Go 语言运行时调度器的实现原理，其中包含调度器的设计与实现原理、演变过程以及与运行时调度相关的数据结构。</p></blockquote><p><img src="https://vegard-bear.github.io/images/%E8%B0%83%E5%BA%A6%E5%99%A8GMP.png" alt></p><blockquote><p>点击图片查看高清大图</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> 源码解析 </tag>
            
            <tag> GMP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【leetcode-460】LFU 缓存</title>
      <link href="/2021/04/04/leetcode-460/"/>
      <url>/2021/04/04/leetcode-460/</url>
      
        <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/lfu-cache/" target="_blank" rel="noopener">460. LFU 缓存</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>请你为 最不经常使用（LFU）缓存算法设计并实现数据结构。</p><p>实现 LFUCache 类：</p><ul><li>LFUCache（int capacity） - 用数据结构的容量 capacity 初始化对象</li><li>int get（int key） - 如果键存在于缓存中，则获取键的值，否则返回 -1。</li><li>void put（int key, int value） - 如果键已存在，则变更其值；如果键不存在，请插入键值对。当缓存达到其容量时，则应该在插入新项之前，使最不经常使用的项无效。在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，应该去除 最久未使用 的键。<br>注意「项的使用次数」就是自插入该项以来对其调用 get 和 put 函数的次数之和。使用次数会在对应项被移除后置为 0 。</li></ul><p>为了确定最不常使用的键，可以为缓存中的每个键维护一个 使用计数器 。使用计数最小的键是最久未使用的键。</p><p>当一个键首次插入到缓存中时，它的使用计数器被设置为 1（由于 put 操作）。对缓存中的键执行 get 或 put 操作，使用计数器的值将会递增。</p><p>示例：</p><pre><code>输入：[&quot;LFUCache&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;get&quot;][[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]]输出：[null, null, null, 1, null, -1, 3, null, -1, 3, 4]解释：// cnt(x) = 键 x 的使用计数// cache=[] 将显示最后一次使用的顺序（最左边的元素是最近的）LFUCache lFUCache = new LFUCache(2);lFUCache.put(1, 1);   // cache=[1,_], cnt(1)=1lFUCache.put(2, 2);   // cache=[2,1], cnt(2)=1, cnt(1)=1lFUCache.get(1);      // 返回 1                      // cache=[1,2], cnt(2)=1, cnt(1)=2lFUCache.put(3, 3);   // 去除键 2 ，因为 cnt(2)=1 ，使用计数最小                      // cache=[3,1], cnt(3)=1, cnt(1)=2lFUCache.get(2);      // 返回 -1（未找到）lFUCache.get(3);      // 返回 3                      // cache=[3,1], cnt(3)=2, cnt(1)=2lFUCache.put(4, 4);   // 去除键 1 ，1 和 3 的 cnt 相同，但 1 最久未使用                      // cache=[4,3], cnt(4)=1, cnt(3)=2lFUCache.get(1);      // 返回 -1（未找到）lFUCache.get(3);      // 返回 3                      // cache=[3,4], cnt(4)=1, cnt(3)=3lFUCache.get(4);      // 返回 4                      // cache=[3,4], cnt(4)=2, cnt(3)=3</code></pre><p>提示：</p><ul><li>0 &lt;= capacity, key, value &lt;= 104</li><li>最多调用 105 次 get 和 put 方法</li></ul><ul><li>进阶：你可以为这两种操作设计时间复杂度为 O((1)) 的实现吗？</li></ul><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>LFU缓存淘汰算法是非常经典的算法，它其实是LRU算法的增强版本，关于LRU算法，可参考考<a href="https://leetcode-cn.com/problems/lru-cache/solution/lru-ce-lue-xiang-jie-he-shi-xian-by-labuladong/" target="_blank" rel="noopener">LRU 策略详解和实现</a></p><h3 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h3><p>在解这道题的时候首先需要重点关注LFU算法和LRU算法的主要不同：</p><p><strong>LRU算法只是简单地将数据按照时间进行排序，借助链表就很容易实现，因为缓存淘汰的时候只要将链表尾部的元素淘汰就行了；而LFU算法则是先把数据按照访问次数进行排序，优先删除访问次数少的数据，当访问次数相同时，则删除最早插入的数据</strong></p><h3 id="逐步细化"><a href="#逐步细化" class="headerlink" title="逐步细化"></a>逐步细化</h3><p>然后，我们根据这个LFU算法的特点对需求进行进一步拆解和细化：</p><ol><li>需要快速知道当前的最小频次（用一个变量minfreq表示）</li><li>需要访问频次freq到key的映射（采用哈希表进行存储）</li><li>可能有多个key拥有相同的频次freq，所以freq对key是一对多的关系（一个freq对应一个key列表）</li><li>希望freq对应的列表是存在时序的，这样能够快速删除最旧的key（key列表可以采用链表的结构进行存储）</li><li>希望能够快速删除key列表中的任何一个key，因为频次为freq的某个key被访问后，它的频次将会+1，也就是说需要从当前的freq列表中删除，加入到对应频次为freq+1的列表中。</li></ol><p>除此之外，LFU算法还应该保留LRU算法中的key到value的映射关系，用一个哈希表表示就可以。</p><h3 id="定义数据结构"><a href="#定义数据结构" class="headerlink" title="定义数据结构"></a>定义数据结构</h3><p>搞清楚了以上需求，我们就可以定义一下数据结构了：</p><pre><code>// 定义节点类型type Node struct {    key  int    val  int    freq int}type LFUCache struct {    // key 到val的映射, 一个Element代表一个双向链表节点    keyToVal map[int]*list.Element    // freq到key列表的映射，一个List代表一个双向链表    freqTokeys map[int]*list.List    // 记录最小的访问频次    minFreq    int    // 记录LFU缓存的最大容量    cap        int}</code></pre><h3 id="关键逻辑"><a href="#关键逻辑" class="headerlink" title="关键逻辑"></a>关键逻辑</h3><p>然后就是实现get和put两个方法了:</p><h4 id="get"><a href="#get" class="headerlink" title="get"></a>get</h4><ul><li>get的逻辑很简单，返回key对应的value，然后增加key对应的freq就好了</li></ul><pre><code>// Get// 获取值func (this *LFUCache) Get(key int) int {    // 不存在时则返回-1    ele, ok := this.keyToVal[key]    if !ok {        return -1    }    // 增加key对应的freq    return this.updateFreq(ele)}</code></pre><p>更新freq的操作是LFU算法的核心，我们这里单独封装一个updateFreq实现，这样get的逻辑就会显得比较清晰。</p><h4 id="put"><a href="#put" class="headerlink" title="put"></a>put</h4><p>对于put方法，逻辑略微复杂，这里我们通过画张图进行整理：</p><p><img src="https://vegard-bear.github.io/images/LFU_put.png" alt></p><p>根据图可以直接写出put的逻辑：</p><pre><code>// Put// 存入新的值func (this *LFUCache) Put(key int, value int) {    // 特殊情况处理    if this.cap &lt;= 0 {        return    }    // 如果key已存在，修改对应的val即可    if ele, ok := this.keyToVal[key]; ok {        data := ele.Value.(*Node)        data.val = value        // 调整key的freq次数        this.updateFreq(ele)        return    }    // key不存在则需要插入    // 容量已满的话需要淘汰一个freq最小的key    if this.cap == len(this.keyToVal) {        this.removeMinFreqKey()    }    // 创建新的节点    newNode := &amp;Node{        key:  key,        val:  value,        freq: 1,    }    // 更新freq to key的链表    newList, ok := this.freqTokeys[newNode.freq]    if !ok {        // 不存在则创建一个链表        newList = list.New()        this.freqTokeys[newNode.freq] = newList    }    // 更新KeyToVal表    newEle := newList.PushBack(newNode)    this.keyToVal[key] = newEle    this.minFreq = newNode.freq}</code></pre><h4 id="updateFreq"><a href="#updateFreq" class="headerlink" title="updateFreq"></a>updateFreq</h4><p>更新freq的方法简单来说就是按照以下步骤走：</p><ol><li>找到key所在的freq列表</li><li>将key从当前freq列表中删除</li><li>更新key的freq = freq+1</li><li>将更新后的元素插入到对应freq+1的列表中</li><li>同步更新keyToVal列表</li></ol><p>至此在补充一下淘汰一个freq最小的key方法removeMinFreqKey就行了，完整代码如题解所示。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code>// 定义节点类型type Node struct {    key  int    val  int    freq int}type LFUCache struct {    // key 到val的映射, 一个Element代表一个双向链表节点    keyToVal map[int]*list.Element    // freq到key列表的映射，一个List代表一个双向链表    freqTokeys map[int]*list.List    // 记录最小的访问频次    minFreq    int    // 记录LFU缓存的最大容量    cap        int}// Constructor// 初始化LFU缓存func Constructor(capacity int) LFUCache {    return LFUCache{        keyToVal:   map[int]*list.Element{},        freqTokeys: map[int]*list.List{},        minFreq:    0,        cap:        capacity,    }}// Get// 获取值func (this *LFUCache) Get(key int) int {    // 不存在时则返回-1    ele, ok := this.keyToVal[key]    if !ok {        return -1    }    // 增加key对应的freq    return this.updateFreq(ele)}// updateFreq// 访问key的同时需要增加对应freq的次数func (this *LFUCache) updateFreq(ele *list.Element) int {    // 这里需要根据输入先造一个节点    data := ele.Value.(*Node)    // 处理freq to key的映射关系    // 先找到这个freq对应的节点链表，如果没有，直接返回-1    curList, ok := this.freqTokeys[data.freq]    if !ok {        return -1    }    // FK表中删除原有的记录    curList.Remove(ele)    // 如果当前要更新的频率已经是最小频率了，那么最小频率也顺带更新了    if curList.Len() == 0 {        if data.freq == this.minFreq {            this.minFreq++        }    }    // 更新key与freq的关系，当key对应的freq增加时候，则存储到对应的链表中    data.freq++    newList, ok := this.freqTokeys[data.freq]    // 如果不存在链表则创建    if !ok {        newList = list.New()        this.freqTokeys[data.freq] = newList    }    // 在链表后追加，注意返回值    newEle := newList.PushBack(data)    // 更新keyToVal表中元素的freq    this.keyToVal[data.key] = newEle    return data.val}// Put// 存入新的值func (this *LFUCache) Put(key int, value int) {    // 特殊情况处理    if this.cap &lt;= 0 {        return    }    // 如果key已存在，修改对应的val即可    if ele, ok := this.keyToVal[key]; ok {        data := ele.Value.(*Node)        data.val = value        // 调整key的freq次数        this.updateFreq(ele)        return    }    // key不存在则需要插入    // 容量已满的话需要淘汰一个freq最小的key    if this.cap == len(this.keyToVal) {        this.removeMinFreqKey()    }    // 创建新的节点    newNode := &amp;Node{        key:  key,        val:  value,        freq: 1,    }    // 更新freq to key的链表    newList, ok := this.freqTokeys[newNode.freq]    if !ok {        // 不存在则创建一个链表        newList = list.New()        this.freqTokeys[newNode.freq] = newList    }    // 更新KeyToVal表    newEle := newList.PushBack(newNode)    this.keyToVal[key] = newEle    this.minFreq = newNode.freq}// removeMinFreqKey// 淘汰一个freq最小的keyfunc (this *LFUCache) removeMinFreqKey() {    // 先根据最小频率找到对应链表    minList, ok := this.freqTokeys[this.minFreq]    if !ok {        return    }    // 链表中的第一个元素自然就是最长时间未被使用的元素    delE := minList.Front()    minList.Remove(delE)    data := delE.Value.(*Node)    // 同步更新KeyToVal表    delete(this.keyToVal, data.key)}</code></pre><h1 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h1><h3 id="时间复杂度：O（1）"><a href="#时间复杂度：O（1）" class="headerlink" title="时间复杂度：O（1）"></a>时间复杂度：O（1）</h3><p>get 时间复杂度 O（1），put 时间复杂度 O（1）。由于两个操作从头至尾都只利用了哈希表的插入删除还有链表的插入删除，且它们的时间复杂度均为 O（1），所以保证了两个操作的时间复杂度均为 O（1）。</p><h3 id="空间复杂度：O（capacity）"><a href="#空间复杂度：O（capacity）" class="headerlink" title="空间复杂度：O（capacity）"></a>空间复杂度：O（capacity）</h3><p>其中capacity为LFU的缓存容量。哈希表中不会存放超过缓存容量的键值对。</p><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><p>LFU 的逻辑不难理解，但是写代码实现并不容易，因为要同时维护多个哈希表。</p><ol><li>不要企图上来就实现算法的所有细节，而应该自顶向下，逐步求精，先写清楚主函数的逻辑框架，然后再一步步实现细节。</li><li>搞清楚映射关系，如果我们更新了某个 key 对应的 freq，那么就要同步修改 KF 表和 FK 表，这样才不会出问题。</li><li>画图，画图，画图，重要的话说三遍，把逻辑比较复杂的部分用流程图画出来，然后根据图来写代码，可以极大减少出错的概率。</li></ol>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> LFU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【leetcode-146】LRU 缓存机制</title>
      <link href="/2021/03/29/leetcode-146/"/>
      <url>/2021/03/29/leetcode-146/</url>
      
        <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/lru-cache/" target="_blank" rel="noopener">146. LRU 缓存机制</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>运用你所掌握的数据结构，设计和实现一个  LRU ((最近最少使用)) 缓存机制 。<br>实现 LRUCache 类：</p><ul><li>LRUCache((int capacity)) 以正整数作为容量 capacity 初始化 LRU 缓存</li><li>int get((int key)) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。</li><li>void put((int key, int value)) 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</li></ul><p>进阶：你是否可以在 O((1)) 时间复杂度内完成这两种操作？</p><p>示例：</p><p>输入</p><pre><code>[&quot;LRUCache&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;get&quot;][[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]</code></pre><p>输出</p><pre><code>[null, null, null, 1, null, -1, null, -1, 3, 4]</code></pre><p>解释</p><pre><code>LRUCache lRUCache = new LRUCache(2);lRUCache.put(1, 1); // 缓存是 {1=1}lRUCache.put(2, 2); // 缓存是 {1=1, 2=2}lRUCache.get(1);    // 返回 1lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}lRUCache.get(2);    // 返回 -1 (未找到)lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}lRUCache.get(1);    // 返回 -1 (未找到)lRUCache.get(3);    // 返回 3lRUCache.get(4);    // 返回 4</code></pre><p>提示：</p><ul><li>1 &lt;= capacity &lt;= 3000</li><li>0 &lt;= key &lt;= 3000</li><li>0 &lt;= value &lt;= 104</li><li>最多调用 3 * 104 次 get 和 put</li></ul><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>LRU缓存淘汰算法本质就是双向链表+哈希表，具体题解可参考<a href="https://leetcode-cn.com/problems/lru-cache/solution/lru-ce-lue-xiang-jie-he-shi-xian-by-labuladong/" target="_blank" rel="noopener">LRU 策略详解和实现</a></p><p>整体难度倒不是很大，主要是同时考察了双向链表和哈希表的性质，需要注意的细节和坑比较多：</p><ul><li>每次更新链表((插入和删除))的同时，需要注意同步更新哈希表</li><li>双向链表自带头节点和尾节点，删除节点的时候注意不能直接删除tail节点，而是删除tail.pre</li><li>对于key相同，value不同的情况在put的时候需要特别注意</li></ul><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code>// 定义双向链表节点type LinkNode struct {    // key用作哈希表中的键，val是节点的实际值    key, val  int    // 前驱和后趋节点    pre, next *LinkNode}type LRUCache struct {    // 哈希表    m map[int]*LinkNode    // 记录一下容量，防止超出    cap int    // 用于标记头尾节点    head, tail *LinkNode}func Constructor(capacity int) LRUCache {    // 初始化双向链表的数据    head := &amp;LinkNode{0,0, nil, nil}    tail := &amp;LinkNode{0, 0, nil, nil}    // 连接指针    head.next = tail    tail.pre = head    // 返回构造好的实例    return LRUCache{make(map[int]*LinkNode), capacity, head, tail}}func (this *LRUCache) Get(key int) int {    // 先检查该元素是否存在    if v, ok := this.m[key]; ok {        // 如果存在，直接将该节点移动到队头        this.moveToHead(v)        return v.val    }    // 不存在直接返回-1    return -1}// 增加一个节点func (this *LRUCache) addNode(node *LinkNode) {    // 修改新增节点前后指针    node.next = this.head.next    node.pre = this.head    // 将相邻节点指针指向新增节点    this.head.next = node    node.next.pre = node    // 注意需要同步更新map    this.m[node.key] = node}// 删除一个节点func (this *LRUCache) removeNode(node *LinkNode)()  {    // 修改相邻节点指针    node.pre.next = node.next    node.next.pre = node.pre    // 注意需要在map中同步删除key才算完全删除    delete(this.m, node.key)}// 将节点移动到队头func (this *LRUCache) moveToHead(node *LinkNode)  {    // 先删除这个节点    this.removeNode(node)    // 再在队头新增这个节点    this.addNode(node)}func (this *LRUCache) Put(key int, value int)  {    // 先检查该元素是否存在    if v, ok := this.m[key]; ok  {        // 如果存在，先将该节点移动到队头，表示最近访问        this.moveToHead(v)        // 这里需要特别注意key相同，但是value不同的情况        // 这种情况意味着更新了key对应的value        // 当然也可以先删掉原来的key，再重新插入，经测试，直接更新value值时间开销更小        if v.val != value {            v.val = value        }        return    }    // 不存在则新增一个节点    node := &amp;LinkNode{key, value, nil, nil}    // 新增前需要考虑容量是否已满    if len(this.m) == this.cap {        // 删除最后一个节点，要删除的实际有价值节点是tail.pre        this.removeNode(this.tail.pre)    }    // 增加节点    this.addNode(node)    // 注意需要更新map    this.m[key] = node}</code></pre><h1 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h1><h3 id="时间复杂度：O-1"><a href="#时间复杂度：O-1" class="headerlink" title="时间复杂度：O((1))"></a>时间复杂度：O((1))</h3><p>链表增删和哈希表查找的时间复杂度都是O((1))，因此对于put和get都是O((1))</p><h3 id="空间复杂度：O-capacity"><a href="#空间复杂度：O-capacity" class="headerlink" title="空间复杂度：O((capacity))"></a>空间复杂度：O((capacity))</h3><p>O((capacity))，因为哈希表和双向链表最多存储 capacity+1 个元素</p><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><p>LRU缓存淘汰算法原理不难，它同时考察了双向链表+哈希表两个知识点，因此需要对这两种数据结构的操作比较熟悉，一些细节问题尤其需要注意。</p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> LRU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Go源码解析13】上下文context</title>
      <link href="/2021/03/15/go-sourcecode-context/"/>
      <url>/2021/03/15/go-sourcecode-context/</url>
      
        <content type="html"><![CDATA[<p>上下文 context.Context 是 Go 语言中用来设置截止日期、同步信号，传递请求相关值的结构体。上下文与 Goroutine 有比较密切的关系，是 Go 语言中独特的设计，在其他编程语言中我们很少见到类似的概念。</p><p><img src="https://vegard-bear.github.io/images/%E4%B8%8A%E4%B8%8B%E6%96%87context.png" alt></p><blockquote><p>点击图片查看高清大图</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> 源码解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【leetcode-494】目标和</title>
      <link href="/2021/03/15/leetcode-494/"/>
      <url>/2021/03/15/leetcode-494/</url>
      
        <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/target-sum/" target="_blank" rel="noopener">494. 目标和</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个非负整数数组，a1, a2, …, an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。</p><p>返回可以使最终数组和为目标数 S 的所有添加符号的方法数。</p><p>示例：</p><pre><code>输入：nums: [1, 1, 1, 1, 1], S: 3输出：5解释：-1+1+1+1+1 = 3+1-1+1+1+1 = 3+1+1-1+1+1 = 3+1+1+1-1+1 = 3+1+1+1+1-1 = 3一共有5种方法让最终目标和为3。</code></pre><p>提示：</p><ul><li>数组非空，且长度不会超过 20 。</li><li>初始的数组的和不会超过 1000 。</li><li>保证返回的最终结果能被 32 位整数存下。</li></ul><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>这道题我们将给出两个题解决，第一种是常规的动态规划（第一反应应该想到的），第二种是将题意转化成【子集背包问题】，然后再套用背包算法框架解决。</p><p>动态规划首先需要确定状态和选择，在这道题中，状态就是遍历到第几个数（数组的下标），选择就是给每个数字选择“+”还是“-”号。此外还可以通过设置备忘录消除重叠子问题。</p><p>具体题解可参考<a href="https://leetcode-cn.com/problems/target-sum/solution/dong-tai-gui-hua-he-hui-su-suan-fa-dao-di-shui-shi/" target="_blank" rel="noopener">动态规划和回溯算法对比</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="传统动态规划"><a href="#传统动态规划" class="headerlink" title="传统动态规划"></a>传统动态规划</h2><pre><code>// 利用备忘录消除重叠子问题var memo = map[string]int{}func findTargetSumWays(nums []int, S int) int {    memo = map[string]int{}    // 如果数组为空，直接返回    if len(nums) == 0 {        return 0    }    // 从nums[0]开始选择，初始状态需要凑的数字为S    return dp(nums, 0, S)}func dp(nums []int, i, rest int) int {    // 定义base case    // 如果已经遍历完所有的数字    if i == len(nums) {        // 此时刚好凑成需要的数字        if rest == 0 {            // 那么说明已经找到了一种符合要求的组合，直接返回1            return 1        }        // 用了所有的数字仍然没刚好凑足数字，返回0        return 0    }    // 如果已经计算过，直接返回    // 这里采用拼凑的方法得到key，memo[key]表示遍历到nums[i]开始算，有多少种组合可以凑成rest    // 注意这里将int转成string不能直接用string()，否则会转成空    key := strconv.Itoa(i) + &quot;,&quot; + strconv.Itoa(rest)    if n, ok := memo[key]; ok {        return n    }    // 推导状态转移方程，其实就是选择&quot;+&quot;还是&quot;-&quot;    // 注意这里是将两个组合相加而不是选最优    result := dp(nums, i + 1, rest - nums[i]) + dp(nums, i + 1, rest + nums[i])    // 将计算过的结果添加到备忘录中    memo[key] = result    return result}</code></pre><h2 id="背包问题解法"><a href="#背包问题解法" class="headerlink" title="背包问题解法"></a>背包问题解法</h2><pre><code>func findTargetSumWays(nums []int, S int) int {    // 转化为背包问题，重新定义target    sum := 0    for _, num := range nums {        sum += num    }    target := (S + sum)/2    // 注意，这两种情况没法进行子集划分，不符合背包问题，需要排除    if sum &lt; S || (S + sum)%2 == 1 {        return 0    }    // 定义dp数组，dp[i][j]表示对于前i个物品，恰好装满容量为j的背包有几种组合    n := len(nums)    dp := make([][]int, n + 1)    for i := 0; i &lt;= n; i++ {        dp[i] = make([]int, target + 1)    }    // 定义base case    // dp[0][...]=0表示物品个数为0时没有能装满背包的方法    // dp[...][0]=1表示背包容量为0时，什么都不用做也算一种组合    for i := 0; i &lt;= n; i++ {        dp[i][0] = 1    }    // 推导状态转移方程，注意这里的i是从1开始算的，那么nums[i-1]就表示第i个物品    // 注意，这道题和常规的背包问题有所不同，j是从0开始的    // 因为dp[...][0]不能简单的认为就是1，就是说可能存在x个物品，这x个物品的重量都为0，    // 那么当背包的承重为0的时候，是可以在这x个物品中任选来实现的，所以在求dp数组的时候，j是要从0开始计算的    for i := 1; i &lt;= n; i++ {        for j := 0; j &lt;= target; j++ {            // 当前物品太大，放不进背包，肯定不放            if j - nums[i-1] &lt; 0 {                dp[i][j] = dp[i-1][j]            } else {                // 可以选择放或者不放，两种选择之和                dp[i][j] = dp[i-1][j] + dp[i-1][j-nums[i-1]]            }        }    }    return dp[n][target]}</code></pre><h1 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h1><h3 id="时间复杂度：O-n-S"><a href="#时间复杂度：O-n-S" class="headerlink" title="时间复杂度：O((n*S))"></a>时间复杂度：O((n*S))</h3><p>n为数组的元素个数</p><h3 id="空间复杂度：O-n-S"><a href="#空间复杂度：O-n-S" class="headerlink" title="空间复杂度：O((n*S))"></a>空间复杂度：O((n*S))</h3><p>需要开辟一个大小为n*S的二维数组</p><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><p>回溯算法和动态规划其实有很多相似之处，对于大多数题目可以相互转化。对于第二种解法，可以考虑状态压缩，也就是将二维数组压缩成一维数组，可以进一步优化空间复杂度。</p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 背包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Go源码解析12】make和new</title>
      <link href="/2021/03/11/go-sourcecode-make-new/"/>
      <url>/2021/03/11/go-sourcecode-make-new/</url>
      
        <content type="html"><![CDATA[<blockquote><p>当我们想要在 Go 语言中初始化一个结构时，可能会用到两个不同的关键字 — make 和 new。因为它们的功能相似，所以初学者可能会对这两个关键字的作用感到困惑1，但是它们两者能够初始化的变量却有较大的不同。</p></blockquote><p><img src="https://vegard-bear.github.io/images/make%E5%92%8Cnew.png" alt></p><blockquote><p>点击图片查看高清大图</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> 源码解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【leetcode-337】打家劫舍III</title>
      <link href="/2021/03/11/leetcode-337/"/>
      <url>/2021/03/11/leetcode-337/</url>
      
        <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/house-robber-iii/" target="_blank" rel="noopener">337. 打家劫舍 III</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。</p><p>计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。</p><p>示例 1:</p><pre><code>输入: [3,2,3,null,3,null,1]     3    / \   2   3    \   \      3   1输出: 7 解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7.</code></pre><p>示例 2:</p><pre><code>输入: [3,4,5,1,3,null,1]     3    / \   4   5  / \   \  1   3   1输出: 9解释: 小偷一晚能够盗取的最高金额 = 4 + 5 = 9.</code></pre><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>这是打家劫舍系列的第三题，但这次不是数组了，是二叉树了。</p><p>对于二叉树来说，相邻的房子的索引不再是i-1或者是i-1了，而是父节点和左右子节点，所以这里我们只需要在<a href="https://leetcode-cn.com/problems/house-robber/" target="_blank" rel="noopener">198. 打家劫舍</a>的基础上改变一下遍历的顺序就行了，按照二叉树的顺序遍历而不是线性表。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code>// 定义备忘录var memo = map[*TreeNode]int{}func rob(root *TreeNode) int {    // 定义base case    if root == nil {        return 0    }    // 利用备忘录消除重叠子问题    if _, ok := memo[root]; ok {        return memo[root]    }    // 做选择    // 选当前节点，那么只能隔一层选下下层    do := root.Val    if root.Left != nil {        do += rob(root.Left.Left) + rob(root.Left.Right)    }    if root.Right != nil {        do += rob(root.Right.Left) + rob(root.Right.Right)    }    // 不选当前节点，可以选下一层    notDo := rob(root.Left) + rob(root.Right)    // 选其中较大者    res := max(do, notDo)    // 记录备忘录    memo[root] = res    return res}</code></pre><h1 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h1><h3 id="时间复杂度：O-n"><a href="#时间复杂度：O-n" class="headerlink" title="时间复杂度：O((n))"></a>时间复杂度：O((n))</h3><p>n为树的节点数</p><h3 id="空间复杂度：O-n"><a href="#空间复杂度：O-n" class="headerlink" title="空间复杂度：O((n))"></a>空间复杂度：O((n))</h3><p>需要开辟一个大小为n的memo数组。</p><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><p>这道题需要注意二叉树的遍历顺序。</p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【leetcode-213】打家劫舍II</title>
      <link href="/2021/03/11/leetcode-213/"/>
      <url>/2021/03/11/leetcode-213/</url>
      
        <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/house-robber-ii/" target="_blank" rel="noopener">213. 打家劫舍 II</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，能够偷窃到的最高金额。</p><p>示例 1：</p><pre><code>输入：nums = [2,3,2]输出：3解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。</code></pre><p>示例 2：</p><pre><code>输入：nums = [1,2,3,1]输出：4解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。     偷窃到的最高金额 = 1 + 3 = 4 。</code></pre><p>示例 3：</p><pre><code>输入：nums = [0]输出：0</code></pre><p>提示：</p><ul><li>1 &lt;= nums.length &lt;= 100</li><li>0 &lt;= nums[i] &lt;= 1000</li></ul><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>这是打家劫舍系列的第二题，和<a href="https://leetcode-cn.com/problems/house-robber/" target="_blank" rel="noopener">198. 打家劫舍</a>唯一的区别就是房子不再是一排，而是一个圈了。</p><p>围成一个圈和一排的唯一区别就在于首尾两个房子也算是相邻的了，不能同时取到。那么很简单，我们要做的就是在之前的基础上单独处理以下首尾的情况就好了。</p><p>首尾不能同时取钱，可以分为三种情况：</p><ol><li>第一间房子和最后一间房子都不取钱。</li><li>取第一间房子，不取最后一间房子。</li><li>取最后一间房子，不取第一间房子。</li></ol><p>那么我们只要穷举这三种情况，进行最优选择就好了。这里需要注意的是，其实第二和第三种情况已经覆盖了第一种情况。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code>func rob(nums []int) int {    n := len(nums)    // 环形数组，对于只有一个元素的特殊情况需要单独考虑    if n == 1 {        return nums[0]    }    // 因为是环形数组，首尾两端不能同时选    return max(dp(nums[1:]), dp(nums[:n-1]))}func dp(nums []int) int {    n := len(nums)    // 定义dp数组，dp[i]表示从第i个房子开始选择所能获得的最大金额    dp := make([]int, n + 2)    // 确定base case    // dp[n+1] = 0, 0    // 推导状态转移方程    for i := n - 1; i &gt;=0; i-- {        // 要么选第i个房子，要么不选第i个房子        dp[i] = max(dp[i+1], nums[i] + dp[i+2])    }    return dp[0]}</code></pre><h1 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h1><h3 id="时间复杂度：O-n"><a href="#时间复杂度：O-n" class="headerlink" title="时间复杂度：O((n))"></a>时间复杂度：O((n))</h3><p>这里就一层循环，遍历了一下所有的房子，所以算法的总时间复杂度是 O((n))</p><h3 id="空间复杂度：O-n"><a href="#空间复杂度：O-n" class="headerlink" title="空间复杂度：O((n))"></a>空间复杂度：O((n))</h3><p>需要开辟一个大小为n的dp数组。</p><blockquote><p>值得注意的是，我们其实可以通过状态压缩进一步将空间复杂度压缩到常数级，也就是O((1))，不过写出来的代码就有点不好理解了。</p></blockquote><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><p>打家劫舍系列很经典，比如这道题就是结合了环形数组。</p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【leetcode-198】打家劫舍</title>
      <link href="/2021/03/11/leetcode-198/"/>
      <url>/2021/03/11/leetcode-198/</url>
      
        <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/house-robber/" target="_blank" rel="noopener">198. 打家劫舍</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p><p>示例 1：</p><pre><code>输入：[1,2,3,1]输出：4解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。     偷窃到的最高金额 = 1 + 3 = 4 。</code></pre><p>示例 2：</p><pre><code>输入：[2,7,9,3,1]输出：12解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。     偷窃到的最高金额 = 2 + 9 + 1 = 12 。</code></pre><p>提示：</p><ul><li>0 &lt;= nums.length &lt;= 100</li><li>0 &lt;= nums[i] &lt;= 400</li></ul><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>这是一道典型的动态规划题型，而动态规划的关键在于【状态】和【选择】。</p><p>现在我们来模拟一下这个场景，假设我们从第一间房子开始，可以选择取出该房子内的钱或者不取。</p><ul><li><p>假设取出该房子内的钱，那么相邻的下一个房子就不能取了，只能到再下一个房子继续做选择。</p></li><li><p>假设不取出该房子内的钱，那么就可以走到相邻的下一个房子，继续做选择。</p></li></ul><p>当我们走过最后一个房子，显然就不能做选择，此时我们所能获得现金就是0（所谓的base case）</p><p>我们这里的状态（在做选择的过程中变化的量）其实就是房子的索引。</p><h3 id="1-定义dp数组"><a href="#1-定义dp数组" class="headerlink" title="1. 定义dp数组"></a>1. 定义dp数组</h3><h5 id="dp-i-表示从第i个房子开始做选择，最多可以获得的金额"><a href="#dp-i-表示从第i个房子开始做选择，最多可以获得的金额" class="headerlink" title="dp[i]表示从第i个房子开始做选择，最多可以获得的金额"></a><center><font color="blue">dp[i]表示从第i个房子开始做选择，最多可以获得的金额</font></center></h5><h3 id="2-确定base-case"><a href="#2-确定base-case" class="headerlink" title="2. 确定base case"></a>2. 确定base case</h3><h5 id="dp-n-1-0"><a href="#dp-n-1-0" class="headerlink" title=" dp[n+1]=0 "></a><center><font color="blue"> dp[n+1]=0 </font></center></h5><p>表示（从i+1个）开始选，但是注意此时已经没有房子可以选了，所以金额只能是0</p><h3 id="3-推导状态转移方程"><a href="#3-推导状态转移方程" class="headerlink" title="3. 推导状态转移方程"></a>3. 推导状态转移方程</h3><p>有两个选择，在第i个房子取钱或者不取钱</p><ul><li>如果取了第i个房子里的钱就不能取第i+1个，只能从i+2个开始取。</li><li>如果没有取第i个房子里的钱，那么就可以从第i+1个开始取。</li></ul><p>然后从这两个选择里面取最优结果就行了。</p><h5 id="dp-i-max-dp-i-1-nums-i-dp-i-2"><a href="#dp-i-max-dp-i-1-nums-i-dp-i-2" class="headerlink" title=" dp [ i ] = max ( dp [ i + 1 ], nums[ i ] + dp [ i + 2 ] ) "></a><center><font color="blue"> dp [ i ] = max ( dp [ i + 1 ], nums[ i ] + dp [ i + 2 ] ) </font></center></h5><p>分析完动态规划的框架后，其实已经可以直接写代码了。但是我们先等等，因为如果我们直接按照这个思路写代码虽然很好理解，但是由于base case是i=n+1，也就是我们最先知道的是dp[n+1]，那么如果从i=1开始遍历，就意味着要进行递归，因为dp[i]的结果是依赖于dp[i+1]和dp[i+2]的，而dp[i+1]的结果是依赖于dp[i+2]和dp[i+3]的……</p><p>所以我们为了避开递归，可以从i=n-1开始((为什么不是i=n，是因为第i个房子里的钱是nums[i-1]))，这里主要是为了防止数组越界），这样写出来的代码就简洁多了。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code>func rob(nums []int) int {    n := len(nums)    // 这里的状态只有选第几个房子，选择就是取钱还是不取钱    // 定义dp数组，dp[i]表示从第i个房子开始做选择，最多可以获得的金额    // 需注意dp数组的大小    dp := make([]int, n + 2)    //     确定base case，这里已经自动初始化好了    //dp[n+1] = 0    // 推导状态转移方程，注意这里为了防止数组越界，i是从n+1开始的    for i := n - 1; i &gt;= 0 ;i--  {        // 有两个选择，在第i个房子取钱或者不取钱        dp[i] = max(dp[i+1], nums[i] + dp[i+2])    }    return dp[0]}</code></pre><h1 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h1><h3 id="时间复杂度：O-n"><a href="#时间复杂度：O-n" class="headerlink" title="时间复杂度：O((n))"></a>时间复杂度：O((n))</h3><p>这里就一层循环，遍历了一下所有的房子，所以算法的总时间复杂度是 O((n))</p><h3 id="空间复杂度：O-n"><a href="#空间复杂度：O-n" class="headerlink" title="空间复杂度：O((n))"></a>空间复杂度：O((n))</h3><p>需要开辟一个大小为n的dp数组。</p><blockquote><p>值得注意的是，我们其实可以通过状态压缩进一步将空间复杂度压缩到常数级，也就是O((1))，不过写出来的代码就有点不好理解了。</p></blockquote><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><p>动态规划中，对dp数组适当的遍历顺序可以简化代码。</p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Go源码解析11】panic和recover</title>
      <link href="/2021/03/10/go-sourcecode-panic-recover/"/>
      <url>/2021/03/10/go-sourcecode-panic-recover/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本节将分析 Go 语言中两个经常成对出现的两个关键字 — panic 和 recover。这两个关键字与上一节提到的 defer 有紧密的联系，它们都是 Go 语言中的内置函数，也提供了互补的功能。</p></blockquote><p><img src="https://vegard-bear.github.io/images/panic%E5%92%8Crecover.png" alt></p><blockquote><p>点击图片查看高清大图</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> 源码解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【leetcode-518】零钱兑换II (完全背包)</title>
      <link href="/2021/03/09/leetcode-518/"/>
      <url>/2021/03/09/leetcode-518/</url>
      
        <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/coin-change-2/" target="_blank" rel="noopener">518. 零钱兑换 II</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。 </p><p>示例 1:</p><pre><code>输入: amount = 5, coins = [1, 2, 5]输出: 4解释: 有四种方式可以凑成总金额:5=55=2+2+15=2+1+1+15=1+1+1+1+1</code></pre><p>示例 2:</p><pre><code>输入: amount = 3, coins = [2]输出: 0解释: 只用面额2的硬币不能凑成总金额3。</code></pre><p>示例 3:</p><pre><code>输入: amount = 10, coins = [10] 输出: 1</code></pre><p>注意:</p><p>你可以假设：</p><ul><li>0 &lt;= amount ((总金额)) &lt;= 5000</li><li>1 &lt;= coin ((硬币面额)) &lt;= 5000</li><li>硬币种类不超过 500 种</li><li>结果符合 32 位符号整数</li></ul><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>这道题和 <a href="https://vegard-bear.github.io/2021/03/07/leetcode-416/">leetcode-512 分割等和子集</a>一样属于01背包问题的变体，关于01背包在<a href="https://vegard-bear.github.io/2021/03/07/01-bei-bao/">01背包</a>中有详细介绍。</p><p>那么我们把这道题可以转化为背包问题：</p><ul><li>有一个容量为amount的背包，然后有一堆物品，每个物品的重量为coins[i], <strong>每个物品的数量无限</strong>。那么把背包装满有多少种方法？</li></ul><p>注意，这里的物品数量是无限的，我们也把这种背包问题称为完全背包问题，这一点也会在后面推导状态转移方程的时候体现。至此，我们就可以按照背包问题来分析了。</p><h3 id="1-定义dp数组"><a href="#1-定义dp数组" class="headerlink" title="1. 定义dp数组"></a>1. 定义dp数组</h3><h5 id="dp-i-j-表示对于前i个物体，当前背包的重量为j，那么有dp-i-j种方法恰好可以将背包装满"><a href="#dp-i-j-表示对于前i个物体，当前背包的重量为j，那么有dp-i-j种方法恰好可以将背包装满" class="headerlink" title=" dp[i][j]表示对于前i个物体，当前背包的重量为j，那么有dp[i][j种方法恰好可以将背包装满"></a><center><font color="blue"> dp[i][j]表示对于前i个物体，当前背包的重量为j，那么有dp[i][j种方法恰好可以将背包装满</font></center></h5><h3 id="2-确定base-case"><a href="#2-确定base-case" class="headerlink" title="2. 确定base case"></a>2. 确定base case</h3><pre><code>dp[0][...]=0</code></pre><p>表示不用硬币就无法凑出任何面值的金额</p><pre><code>dp[...][0]=1</code></pre><p>表示凑出面额为0的金额，组合有且只有一个（什么都不用做）</p><h3 id="3-推导状态转移方程"><a href="#3-推导状态转移方程" class="headerlink" title="3. 推导状态转移方程"></a>3. 推导状态转移方程</h3><p>推导状态转移方程本质就是做选择，也就是把第i个物体放入或者不放入背包，然后做最优选择就行了</p><p>如果背包剩余的容量足够大，有两种选择，选或者不选，总的组合数是这两种选择的组合数之和</p><p><font color="red">特别注意，完全背包问题和之前的01背包和子集背包问题最大的不同在于物品的数量是无限的,所以如果选择了这种面值的硬币，则是dp[i][j-coins[i-1]]而不是之前的dp[i-1][j-coins[i-1]]</font></p><h5 id="dp-i-j-dp-i-1-j-dp-i-j-coins-i-1"><a href="#dp-i-j-dp-i-1-j-dp-i-j-coins-i-1" class="headerlink" title=" dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i ] [ j - coins [ i - 1 ] ] "></a><center><font c olor="blue"> dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i ] [ j - coins [ i - 1 ] ] </font></center></h5><p>这里需要注意的是数组的下标，由于i是从1开始的，所以题目中的给的数组下标为i-1时表示的是第i个物品的重量。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code>func change(amount int, coins []int) int {    n := len(coins)    // 定义二维dp数组，dp[i][j]表示用前i个面值的硬币凑成总金额的组合数    // 注意这里数组的长度是n+1    dp := make([][]int, n + 1)    for i := 0; i &lt;= n; i++ {        dp[i] = make([]int, amount + 1)    }    //定义 base case    // dp[0][...]=0 表示不用硬币就无法凑出任何面值的金额    // dp[...][0]=1 表示凑出面额为0的金额，组合有且只有一个（什么都不用做）    // 注意这两个 base case 定义的先后顺序    for i := 0; i &lt;= n; i++ {        //dp[0][i] = 0        dp[i][0] = 1    }    // 推导状态转移方程，注意下标从1开始，coins[i-1]表示第i种面值    for i := 1; i &lt;= n; i++ {        for j := 1; j &lt;= amount; j++ {            // 如果背包剩余的容量足够大，有两种选择，选或者不选，总的组合数是这两种选择的组合数之和            // 特别注意，完全背包问题和之前的01背包和子集背包问题最大的不同在于物品的数量是无限的            // 所以如果选择了这种面值的硬币，则是dp[i][j-coins[i-1]]而不是之前的dp[i-1][j-coins[i-1]]            if j - coins[i-1] &gt;= 0 {                dp[i][j] = dp[i-1][j] + dp[i][j-coins[i-1]]            } else {            // 如果背包剩余的容量小于当前这个硬币的面值，那么肯定就不选                dp[i][j] = dp[i-1][j]            }        }    }    return dp[n][amount]}</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="时间复杂度：O-N-amount"><a href="#时间复杂度：O-N-amount" class="headerlink" title="时间复杂度：O((N*amount))"></a>时间复杂度：O((N*amount))</h3><p>硬币面值为N，总金额数是amount，两层循环，所以算法的总时间复杂度是 O((N*amount))</p><h3 id="空间复杂度：O-N-amount"><a href="#空间复杂度：O-N-amount" class="headerlink" title="空间复杂度：O((N*amount))"></a>空间复杂度：O((N*amount))</h3><p>需要开辟一个为N*amount大小的dp数组。</p><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><p>完全背包问题和之前的01背包和子集背包问题最大的不同在于物品的数量是无限的，在推导状态转移方程的时候需要特别注意。</p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 背包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fabric如何使用SoftHSM</title>
      <link href="/2021/03/08/fabric-softhsm/"/>
      <url>/2021/03/08/fabric-softhsm/</url>
      
        <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><blockquote><p>官方文档 <a href="https://hyperledger-fabric.readthedocs.io/en/latest/hsm.html" target="_blank" rel="noopener">Using a Hardware Security Module（HSM）</a></p></blockquote><p>在 <a href="https://vegard-bear.github.io/2020/12/26/fabric-bccsp/">Fabric 1.4源码分析:BCCSP模块</a> 的最后部分介绍了fabric的加密模块BCCSP目前主要分为PKCS11和noPKCS11两个大的分支。我们以noPKCS11分支的SW插件实现为例分析了BCCSP模块的源码实现，另外也提到了目前PKCS11实现主要依赖的是github上开源的第三方库 <a href="https://github.com/miekg/pkcs11" target="_blank" rel="noopener">pkcs11</a>，并且这个库已经和SoftHSM测试过了。</p><p>而本节我们就来讲讲如何在fabric中配置SoftHSM。</p><h1 id="什么是SoftHSM"><a href="#什么是SoftHSM" class="headerlink" title="什么是SoftHSM"></a>什么是SoftHSM</h1><p>在搞清楚什么是SoftHSM之前，我们先来了解一下HSM。</p><blockquote><p>硬件安全模块（英语：Hardware security module，缩写HSM）是一种用于保障和管理强认证系统所使用的数字密钥，并同时提供相关密码学操作的计算机硬件设备。硬件安全模块一般通过扩展卡或外部设备的形式直接连接到电脑或网络服务器。</p></blockquote><ul><li>引用自维基百科<a href="https://zh.wikipedia.org/wiki/%E7%A1%AC%E4%BB%B6%E5%AE%89%E5%85%A8%E6%A8%A1%E5%9D%97" target="_blank" rel="noopener">硬件安全模块</a></li></ul><p>简单来说，HSM就是一种用于密钥管理和加解密操作的独立硬件设备。</p><p>实际上，在某些场景下，用户可能需要HSM提供的密码服务，但同时他们又不愿意投入较多的资金购买新的密码硬件设备，这个时候SoftHSM就是一种很好的选择。</p><p><a href="https://www.opendnssec.org/softhsm/" target="_blank" rel="noopener">SoftHSM</a>属于开源项目<a href="https://www.opendnssec.org/" target="_blank" rel="noopener">OpenDNSSEC</a>，它是一种可通过PKCS11接口访问的密码存储实现。代码托管在<a href="https://github.com/opendnssec/SoftHSMv2" target="_blank" rel="noopener">github</a>上。这意味着任何应用都能够通过pkcs11的接口标准访问softHSM提供的密钥管理等密码服务，如图所示，SoftHSM是HSM的一种替代选择。</p><p><img src="https://vegard-bear.github.io/images/softHSM%E7%AE%80%E4%BB%8B.png" alt></p><p>关于SoftHSM的具体使用请参考 <a href="https://vegard-bear.github.io/2021/03/08/softhsm-introduce/">SoftHSM操作手册</a></p><h3 id="主要配置文件"><a href="#主要配置文件" class="headerlink" title="主要配置文件"></a>主要配置文件</h3><ul><li>libsofthsm2.so （ubuntu:  /usr/lib/softhsm/libsofthsm2.so）((centos:/usr/local/lib/softhsm/libsofthsm2.so))</li><li>softhsm2.conf，配置文件，里面配置了softhsm使用时，存储文件的路径和方式（例如：file，/var/lib/softhsm/tokens/）</li><li>/var/lib/softhsm/tokens/ 这里面放了softhsm生成的文件</li></ul><h1 id="Fabric-CA配置SoftHSM"><a href="#Fabric-CA配置SoftHSM" class="headerlink" title="Fabric CA配置SoftHSM"></a>Fabric CA配置SoftHSM</h1><h3 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h3><p>fabric-ca所在的服务器或者容器内安装了softhsm</p><h3 id="编译二进制"><a href="#编译二进制" class="headerlink" title="编译二进制"></a>编译二进制</h3><p>下载好fabric-ca的代码后，添加GO_TAGS=pkcs11 重新编译二进制文件并放入环境变量:</p><pre><code>make fabric-ca-server GO_TAGS=pkcs11make fabric-ca-client GO_TAGS=pkcs11</code></pre><h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><p>配置fabric-ca-server-config.yaml文件和fabric-ca-client.yaml文件中的bccsp部分,这里的具体配置与安装的softhsm一致</p><pre><code>bccsp:default: PKCS11#sw:#    hash: SHA2#    security: 256#    filekeystore:        # The directory used for the software file-based keystore#        keystore: msp/keystorepkcs11:    library: /usr/local/lib/softhsm/libsofthsm2.so    Label: ForFabric    Pin: 98765432    hash: SHA2    security: 256    filekeystore:        # The directory used for the software file-based keystore        #             keystore: msp/keystore</code></pre><h3 id="生成证书套件"><a href="#生成证书套件" class="headerlink" title="生成证书套件"></a>生成证书套件</h3><p>配置完这两个配置文件后就可以利用fabric-ca为组织申请一套证书用于替代byfn的crypto-config（不包含TLS证书），具体步骤可参考</p><ul><li><p><a href="https://yq.aliyun.com/articles/625191" target="_blank" rel="noopener">HyperLedger Fabric ca正式环境部署-阿里云开发者社区</a></p></li><li><p><a href="https://blog.csdn.net/ahilll/article/details/83046667" target="_blank" rel="noopener">HyperLedger Fabric 1.2 生产环境使用ca生成msp和tls（12）_ahilll的博客-CSDN博客_fabric ca 生成证书</a></p></li></ul><p>这里为了方便，我们直接用c脚本一键生成的方式:</p><ol><li>首先进入之前配置好的fabric-ca-server-config.yaml所在目录，启动一个fabric-ca-server</li></ol><pre><code>fabric-ca-server start -b admin:adminpw</code></pre><ol start="2"><li>执行完显示如下：</li></ol><pre><code>2021/03/08 11:19:07 [INFO] Listening on http://0.0.0.0:7054</code></pre><ol start="3"><li>然后执行脚本</li></ol><pre><code>sh fabric-ca-regitser.sh</code></pre><ol start="4"><li>执行完后一切顺利的话会生成crypto-config目录，我们需要将此目录拷贝到byfn下面</li></ol><pre><code>cp -r ./fabric-ca-client/crypto-config $GOPATH/src/github.com/hyperledger/fabric/fabric-samples/first-network</code></pre><h1 id="Fabric配置SoftHSM"><a href="#Fabric配置SoftHSM" class="headerlink" title="Fabric配置SoftHSM"></a>Fabric配置SoftHSM</h1><h3 id="前提条件-1"><a href="#前提条件-1" class="headerlink" title="前提条件"></a>前提条件</h3><p>fabric-ca所在的服务器或者容器内安装了softhsm</p><h3 id="在SoftHSM中创建密钥"><a href="#在SoftHSM中创建密钥" class="headerlink" title="在SoftHSM中创建密钥"></a>在SoftHSM中创建密钥</h3><ul><li>初始化token</li></ul><pre><code>softhsm2-util --init-token --slot 0 --label &quot;ForFabric&quot; --so-pin 1234 --pin 98765432</code></pre><p>注意这里需要指定label和pin，这里的label和pin会在修改fabric的配置文件的时候用到。</p><p>执行完以上命令后可以查看刚刚创建的slot和token信息</p><pre><code>➜ softhsm2-util --show-slotsSlot 1655411567    Slot info:        Description:      SoftHSM slot ID 0x62ab936f        Manufacturer ID:  SoftHSM project        Hardware version: 2.2        Firmware version: 2.2        Token present:    yes    Token info:        Manufacturer ID:  SoftHSM project        Model:            SoftHSM v2        Hardware version: 2.2        Firmware version: 2.2        Serial number:    4f6dddc562ab936f        Initialized:      yes        User PIN init.:   yes        Label:            ForFabric</code></pre><p>至此，说明我们已经成功创建了一个标记为 “ForFabric” 并把 pin 设置为 “98765432” 的秘钥。</p><h3 id="修改配置文件-1"><a href="#修改配置文件-1" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><p>这一步我们需要在节点配置文件（core.yaml和orderer.yaml）中更新 BCCSP 部分。</p><ul><li>core.yaml</li></ul><pre><code>    # BCCSP (Blockchain crypto provider): Select which crypto implementation or    # library to use    BCCSP:        # if setting is GM, chaincode.golang.dynamiclink must be false.        Default: PKCS11        # Settings for the SW crypto provider (i.e. when DEFAULT: SW)        SW:            # TODO: The default Hash and Security level needs refactoring to be            # fully configurable. Changing these defaults requires coordination            # SHA2 is hardcoded in several places, not only BCCSP            Hash: SHA2            Security: 256            Library:             # Location of Key Store            FileKeyStore:                # If &quot;&quot;, defaults to &#39;mspConfigPath&#39;/keystore                KeyStore:        # Settings for the PKCS#11 crypto provider (i.e. when DEFAULT: PKCS11)        PKCS11:            # Location of the PKCS11 module library            Library: /usr/lib/softhsm/libsofthsm2.so             #/etc/hyperledger/fabric/libsofthsm2.so            # Token Label            Label: ForFabric            # User PIN            Pin: &quot;98765432&quot;            Hash: SHA2            Security: 256</code></pre><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><p>这里我们采用的是通过编译docker镜像并使 docker compose文件 部署节点，所以需要修改 docker compose 配置文件的 volumes 部分来挂载softhsm库和配置文件。</p><p>下边的示例演示了如何在docker compose 配置文件中设置环境变量和挂载：</p><pre><code>  environment:     - SOFTHSM2_CONF=/etc/hyperledger/fabric/config.file  volumes:     - /home/softhsm/config.file:/etc/hyperledger/fabric/config.file     - /usr/local/Cellar/softhsm/2.1.0/lib/softhsm/libsofthsm2.so:/etc/hyperledger/fabric/libsofthsm2.so</code></pre><p>注意这里的/home/softhsm/config.file需要在宿主机上存在，这里我们需要将原来默认的/etc/softhsm2.conf文件拷贝一份到/home/softhsm/目录下，然后修改其中的token文件夹路径：</p><pre><code># SoftHSM v2 configuration filedirectories.tokendir = /etc/hyperledger/fabric/tokens/objectstore.backend = file# ERROR, WARNING, INFO, DEBUGlog.level = INFO</code></pre><p>这里的 <strong>/etc/hyperledger/fabric/tokens/</strong> 实际上就对应配置文件中的</p><pre><code>- /var/lib/softhsm/tokens/:/etc/hyperledger/fabric/tokens/</code></pre><p>尤其需要注意的是不能直接配成</p><pre><code>- /etc/softhsm2.conf:/etc/hyperledger/fabric/config.file</code></pre><p>会报错</p><pre><code>2021-03-08 07:27:08.704 UTC [main] InitCmd -&gt; ERRO 01f Cannot run peer because error when setting up MSP of type bccsp from directory /etc/hyperledger/fabric/msp: could not initialize BCCSP Factories: Failed initializing PKCS11.BCCSP %!s(&lt;nil&gt;): Could not initialize BCCSP PKCS11 [Failed initializing PKCS11 library /usr/lib/softhsm/libsofthsm2.so ForFabric: Could not find token with label ForFabric]Could not find default `PKCS11` BCCSP</code></pre><h3 id="重新编译镜像"><a href="#重新编译镜像" class="headerlink" title="重新编译镜像"></a>重新编译镜像</h3><pre><code>make docker GO_TAGS=pkcs11 或 make all GO_TAGS=pkcs11</code></pre><h3 id="运行byfn"><a href="#运行byfn" class="headerlink" title="运行byfn"></a>运行byfn</h3><p>注意目前fabric-samples/first-network下的byfn<br>配置暂不支持tls的，也就是TLS_ENABLED要设置为false</p><ul><li>生成需要的配置文件</li></ul><pre><code>./byfn generate</code></pre><ul><li>执行e2e的测试用例</li></ul><pre><code>./byfn up</code></pre>]]></content>
      
      
      <categories>
          
          <category> 密码学 </category>
          
          <category> fabric </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
            <tag> SoftHSM </tag>
            
            <tag> fabric </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SoftHSM操作手册</title>
      <link href="/2021/03/08/softhsm-introduce/"/>
      <url>/2021/03/08/softhsm-introduce/</url>
      
        <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>OpenDNSSEC通过PKCS＃11接口处理并存储其加密密钥。该接口指定如何与诸如HSM :（硬件安全模块）和智能卡之类的加密设备进行通信。这些设备的目的是在不向外界透露私钥材料的情况下生成密码密钥和签名信息。</p><p>使用PKCS＃11接口的潜在问题是，它可能会限制OpenDNSSEC的广泛使用，因为潜在的用户可能不愿投资于新的硬件设备。为了消除这种影响，OpenDNSSEC正在提供具有PKCS＃11接口的通用加密设备SoftHSM的软件实现。SoftHSM旨在满足OpenDNSSEC的要求，但由于具有PKCS＃11接口，因此还可以与其他加密产品一起使用。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>首先下载源码 <a href="https://github.com/opendnssec/SoftHSMv2" target="_blank" rel="noopener">opendnssec/SoftHSMv2</a></p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>配置安装/编译脚本：</p><pre><code>sh ./autogen.sh./configure</code></pre><p>选项：</p><pre><code>--disable-non-paged-memory            Disable non-paged memory for secure storage            (default enabled)--disable-ecc        Disable support for ECC (default enabled)--disable-gost        Disable support for GOST (default enabled)--disable-visibility    Disable hidden visibilty link mode [enabled]--with-crypto-backend    Select crypto backend (openssl|botan)--with-openssl=PATH    Specify prefix of path of OpenSSL--with-botan=PATH    Specify prefix of path of Botan--with-migrate        Build the migration tool. Used when migrating            a SoftHSM v1 token database. Requires SQLite3--with-objectstore-backend-db            Build with database object store (SQLite3)--with-sqlite3=PATH    Specify prefix of path of SQLite3--disable-p11-kit    Disable p11-kit integration (default enabled)--with-p11-kit=PATH    Specify install path of the p11-kit module, will            override path given by pkg-config</code></pre><p>有关更多选项：</p><pre><code>./configure --help</code></pre><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>使用以下命令编译源代码：</p><pre><code>make 或 sudo make</code></pre><h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><p>使用以下命令安装库：</p><pre><code>sudo make install</code></pre><p>验证是否安装成功</p><pre><code>softhsm2-util --show-slots</code></pre><p>如果所有都安装后，还报错误：<br>checking for OpenSSL GOST support… Cannot GOST engine<br>configure: error: OpenSSL library has no GOST support 【执行 ./configure –disable-gost 再安装 （2.2.0版本会有这个问题）】</p><h2 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h2><p>配置文件的默认位置是/etc/softhsm2.conf。可以通过设置环境变量来更改此位置，比如：</p><pre><code>export SOFTHSM2_CONF=/home/user/config.file</code></pre><p>配置文件中定义了生成的token文件路径以及日志等级等信息：</p><pre><code># SoftHSM v2 configuration filedirectories.tokendir = /var/lib/softhsm/tokens/objectstore.backend = file# ERROR, WARNING, INFO, DEBUGlog.level = INFO</code></pre><p>有关配置的详细信息，可以使用<strong>man softhsm2.conf</strong>。</p><h2 id="初始化token"><a href="#初始化token" class="headerlink" title="初始化token"></a>初始化token</h2><p>创建在配置文件中定义的token目录：</p><pre><code>mkdir /var/lib/softhsm/tokens/</code></pre><p>在初始状态下，最下面的slot0表示目前的slot数量为0，状态为未初始化。</p><pre><code>Slot 0    Slot info:        Description:      SoftHSM slot ID 0x0        Manufacturer ID:  SoftHSM project        Hardware version: 2.2        Firmware version: 2.2        Token present:    yes    Token info:        Manufacturer ID:  SoftHSM project        Model:            SoftHSM v2        Hardware version: 2.2        Firmware version: 2.2        Serial number:        Initialized:      no        User PIN init.:   no        Label:</code></pre><p>然后每次初始化一个token就会增加一个新的slot用于记录刚刚初始化的token信息。</p><p>比如执行</p><pre><code>softhsm2-util --init-token --slot 0 --label &quot;ForFabric&quot; --so-pin 1234 --pin 98765432</code></pre><p>这里，我们需要记下pin和label，用于后续配置在应用程序（比如fabric和fabric ca）中，这样应用程序才可以利用这些信息与去SoftHSM找到对应的token信息。</p><blockquote><p>注意，这里指定的slot0 必须是已经存在的slot，否则会报错。</p></blockquote><p>执行完以上命令后再次查看slot</p><pre><code>➜  ~ softhsm2-util --show-slotsAvailable slots:Slot 1655411567    Slot info:        Description:      SoftHSM slot ID 0x62ab936f        Manufacturer ID:  SoftHSM project        Hardware version: 2.2        Firmware version: 2.2        Token present:    yes    Token info:        Manufacturer ID:  SoftHSM project        Model:            SoftHSM v2        Hardware version: 2.2        Firmware version: 2.2        Serial number:    4f6dddc562ab936f        Initialized:      yes        User PIN init.:   yes        Label:            ForFabricSlot 1    Slot info:        Description:      SoftHSM slot ID 0x1        Manufacturer ID:  SoftHSM project        Hardware version: 2.2        Firmware version: 2.2        Token present:    yes    Token info:        Manufacturer ID:  SoftHSM project        Model:            SoftHSM v2        Hardware version: 2.2        Firmware version: 2.2        Serial number:        Initialized:      no        User PIN init.:   no        Label:</code></pre><p>可以看到从上倒下新增了一个token，就是我们刚刚初始化的token。</p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>链接到该库并使用PKCS11接口。</p><h2 id="后备"><a href="#后备" class="headerlink" title="后备"></a>后备</h2><p>所有令牌及其对象都存储在softhsm2.conf给定的位置。因此可以将备份作为常规文件副本进行。</p><h1 id="从存储库构建"><a href="#从存储库构建" class="headerlink" title="从存储库构建"></a>从存储库构建</h1><p>如果直接从代码存储库下载代码，则必须准备配置脚本，然后才能继续使用真实的README。</p><p>您需要安装automake，autoconf，libtool等。<br>运行命令“ sh autogen.sh”<br>继续阅读此自述文件。</p><h1 id="操作接口"><a href="#操作接口" class="headerlink" title="操作接口"></a>操作接口</h1><p>SoftHSM的常用操作接口主要由三部分组成：</p><ul><li>softhsm2-util</li><li>softhsm2-keyconv </li><li>softhsm2-dump-file  </li></ul><h2 id="softhsm2-util"><a href="#softhsm2-util" class="headerlink" title="softhsm2-util"></a>softhsm2-util</h2><p>softhsm2-util 是 libsofthsm2的支持工具</p><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><ul><li><p>softhsm2-util –show-slots</p></li><li><p>softhsm2-util –init-token –free –label text [–so-pin PIN —-pin PIN]</p></li><li><p>softhsm2-util –import path [–file-pin PIN] –token label [–pin PIN –no-public-key] –label text –id hex</p></li><li><p>softhsm2-util –delete-token –token text</p></li></ul><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>softhsm2-util是一个主要用于libsofthsm2的支持工具。它还可以通过使用选项–module与其他PKCS#11库一起使用</p><p>大多数应用程序都假定它们想要使用的token已经初始化。然后由用户初始化PKCS#11的token。这是通过调用PKCS#11接口完成的，但是您可以使用softhsm2-util工具，而不是编写自己的工具。</p><p>密钥通常是直接在token中创建的，但用户可能希望使用现有的密钥对。密钥可以通过使用PKCS#11接口导入到令牌中，但是如果用户在PKCS#8文件中有密钥对，也可以使用这个工具。如果您需要将密钥从 BIND.private-key 格式转换成 PKCS#8, 可以使用 softhsm2-keyconv。</p><p>libsofthsm2库，也称为SoftHSM，通过使用PKCS#11 API提供加密功能。作为<br>OpenDNSSEC的项目，因此需要满足OpenDNSSEC的要求，而且还可以与其他软件一起使用。</p><p>SoftHSM是一个带有pkcs#11接口的通用密码设备的软件实现。这些设备通常被称为token。</p><p>请参阅手册 <a href="https://linux.die.net/man/5/softhsm.conf" target="_blank" rel="noopener">softhsm2.conf(5)</a>，了解如何创建这些token，以及如何将它们添加到SoftHSM中的一个slot。</p><p>PKCS#11 API可用于处理和存储加密密钥。该接口指定如何与加密设备通信，例如hsm(硬件安全模块)和智能卡。</p><p>这些设备的目的是在产生加密密钥和签名信息的同时而不向外界透露私钥材料信息。与普通计算机中的普通进程相比，它们通常被设计为在这些特定的情况下表现良好的任务。</p><h3 id="ACTIONS"><a href="#ACTIONS" class="headerlink" title="ACTIONS"></a>ACTIONS</h3><ul><li>–delete-token</li></ul><p>删除给定slot上的token。与–token或–serial一起使用。token中的任何内容都将被删除。</p><ul><li>–help, -h</li></ul><p>显示帮助信息。</p><ul><li>–import path</li></ul><p>从给定路径导入密钥对。文件必须是pkcs# 8格式。<br>与–slot或–token或–serial、–file-pin、–pin、–no-public-key、–label和–id一起使用。</p><ul><li>–init-token</li></ul><p>在给定的slot、token标签或token串行上初始化token。如果token已经初始化，那么这个命令将会重新初始化, 并删除标记中的所有对象。同时，进行重新初始化的时候必须提供配对的Security Officer ((SO)) PIN密码</p><p>此命令与 –slot or –token or –serial or –free, –label, –so-pin, and –pin 一起使用。</p><ul><li>–show-slots</li></ul><p>显示所有可用slot及其他们当前的状态。</p><p>–version，-v</p><p>显示版本信息。</p><h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><ul><li>–file-pin PIN</li></ul><p>PIN将被用于解密PKCS#8文件。如果没有给出，那么PKCS#8文件就被认为是未加密的。</p><ul><li>–force</li></ul><p>使用此选项可覆盖警告并强制执行给定操作。</p><ul><li>–free</li></ul><p>使用第一个 free/uninitialized 的令牌。</p><ul><li>–id [hex]</li></ul><p>选择密钥对的ID。该ID为可变长度的十六进制形式。在导入密钥对时使用 –force，如果ID已经存在。</p><ul><li>–label [text]</li></ul><p>定义要设置的对象或token的标签。</p><ul><li>–module [path]</li></ul><p>使用另一个PKCS#11库而不是SoftHSM。</p><ul><li>–no-public-key</li></ul><p>不要导入公钥</p><ul><li>–pin [PIN]</li></ul><p>普通用户的PIN码。</p><p> –serial [number]</p><p>将使用具有匹配序列号的令牌</p><ul><li>–solt [number]</li></ul><p>token所在的slot</p><ul><li>–so-pin PIN</li></ul><p>Security Officer ((SO))的PIN</p><p> –token label</p><p>将使用带有匹配token标签的token。</p><h3 id="example"><a href="#example" class="headerlink" title="example"></a>example</h3><p>可以使用以下命令初始化token:</p><pre><code>softhsm2-util——init-token——slot 1——label“mytoken”</code></pre><p>可以使用softhsm工具导入密钥对，其中指定密钥文件的路径、slot号、新对象的label和ID，和用户PIN。文件必须是pkcs# 8格式。</p><pre><code>softhsm2-util --import key1.pem --token &quot;mytoken&quot; --label &quot;My key&quot; --id A1B2 --pin 123456</code></pre><p>((Add，——file-pin [PIN]，如果密钥文件是加密的))</p><h2 id="softhsm2-keyconv"><a href="#softhsm2-keyconv" class="headerlink" title="softhsm2-keyconv"></a>softhsm2-keyconv</h2><p>softhsm2-keyconv </p><p>-从BIND转化成PKCS#8密钥文件格式</p><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>softhsm2-keyconv –in path –out path [–pin PIN]</p><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p>softhsm2-keyconv可以将BIND.private-key文件转换为PKCS#8文件格式。这样就可以使用softhsm2-util命令将PKCS#8文件导入libsofthsm。如果您有另一种文件格式，那么openssl可能可以帮助您将其转换为PKCS#8文件格式。</p><h3 id="选项-1"><a href="#选项-1" class="headerlink" title="选项"></a>选项</h3><ul><li>–help， -h</li></ul><p>显示帮助界面</p><ul><li>–in [path]</li></ul><p>输入文件的路径</p><ul><li>–out [path]</li></ul><p>输出文件的路径</p><ul><li>–pin [PIN]</li></ul><p>PIN将被用于加密PKCS#8文件。如果没有给出，那么PKCS#8文件将是未加密的。</p><ul><li>–version, -v</li></ul><p>显示版本信息</p><h3 id="examples"><a href="#examples" class="headerlink" title="examples"></a>examples</h3><p>以下命令可以用来将BIND .private-key文件转换为PKCS#8文件:</p><pre><code> softhsm2-keyconv --in Kexample.com.+007+05474.private --out rsa.pem</code></pre><h2 id="softhsm2-dump-file"><a href="#softhsm2-dump-file" class="headerlink" title="softhsm2-dump-file"></a>softhsm2-dump-file</h2><h4 id="name"><a href="#name" class="headerlink" title="name"></a>name</h4><p>softhsm2-dump-file - SoftHSM对象文件存储</p><h4 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h4><p>softhsm2-dump-file [path]</p><h4 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h4><p>softhsm2-dump-file是一个可以转储SoftHSM v2对象文件的工具，用于调试。</p><h4 id="选项-2"><a href="#选项-2" class="headerlink" title="选项"></a>选项</h4><p>[path] 存放待转储的SoftHSM v2对象文件。</p><p>–help -h</p><p>显示帮助信息</p>]]></content>
      
      
      <categories>
          
          <category> 密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
            <tag> SoftHSM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Go源码解析10】defer</title>
      <link href="/2021/03/07/go-sourcecode-defer/"/>
      <url>/2021/03/07/go-sourcecode-defer/</url>
      
        <content type="html"><![CDATA[<p>很多现代的编程语言中都有 defer 关键字，Go 语言的 defer 会在当前函数返回前执行传入的函数，它会经常被用于关闭文件描述符、关闭数据库连接以及解锁资源。</p><p><img src="https://vegard-bear.github.io/images/defer.png" alt></p><blockquote><p>点击图片查看高清大图</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> 源码解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Go源码解析9】select</title>
      <link href="/2021/03/07/go-sourcecode-select/"/>
      <url>/2021/03/07/go-sourcecode-select/</url>
      
        <content type="html"><![CDATA[<p>Go 语言的 select 与操作系统中的 select 比较相似，本节会介绍 Go 语言 select 关键字常见的现象、数据结构以及实现原理。</p><p><img src="https://vegard-bear.github.io/images/select.png" alt></p><blockquote><p>点击图片查看高清大图</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> 源码解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【leetcode-416】分割等和子集（子集背包）</title>
      <link href="/2021/03/07/leetcode-416/"/>
      <url>/2021/03/07/leetcode-416/</url>
      
        <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/" target="_blank" rel="noopener">分割等和子集</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><p>注意:</p><ul><li>每个数组中的元素不会超过 100</li><li>数组的大小不会超过 200<br>示例 1:</li></ul><pre><code>输入: [1, 5, 11, 5]输出: true解释: 数组可以分割成 [1, 5, 5] 和 [11].</code></pre><p>示例 2:</p><pre><code>输入: [1, 2, 3, 5]输出: false解释: 数组不能分割成两个元素和相等的子集.</code></pre><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>这道题可以转化为经典的子集背包问题，其实就是01背包问题的变体，关于01背包在<a href="https://vegard-bear.github.io/2021/03/07/01-bei-bao/">01背包</a>中有详细介绍。那么这道题为什么可以转化为01背包呢，我们可以这么考虑：</p><p>将n个数的集合（和为sum）分成两个和相等的子集不就是在这个集合中选若干个数，使他们的和为sum/2吗，因为这样剩下的数的和就自动为sum/2了。</p><p>好了，现在问题就转变成：</p><p><strong>给一个可装载sum/2的背包和N个物品，每个物品的重量为nums[i]，是否存在一种装法，能够恰好将背包装满？</strong></p><p>这不就是01背包问题的模型吗，甚至比01背包更简单，因为最后求的不是最大值而只是一个bool值。这一点也会在我们定义dp数组的时候有所体现。</p><h3 id="1-定义dp数组"><a href="#1-定义dp数组" class="headerlink" title="1. 定义dp数组"></a>1. 定义dp数组</h3><h5 id="dp-i-j-表示对于前i个物体，当前背包的重量为j，这种情况下如果存在一种装法，可以恰好装满背包，则dp-i-j-true，否则dp-i-j-false则"><a href="#dp-i-j-表示对于前i个物体，当前背包的重量为j，这种情况下如果存在一种装法，可以恰好装满背包，则dp-i-j-true，否则dp-i-j-false则" class="headerlink" title=" dp[i][j]表示对于前i个物体，当前背包的重量为j，这种情况下如果存在一种装法，可以恰好装满背包，则dp[i][j]=true，否则dp[i][j]=false则"></a><center><font color="blue"> dp[i][j]表示对于前i个物体，当前背包的重量为j，这种情况下如果存在一种装法，可以恰好装满背包，则dp[i][j]=true，否则dp[i][j]=false则</font></center></h5><h3 id="2-确定base-case"><a href="#2-确定base-case" class="headerlink" title="2. 确定base case"></a>2. 确定base case</h3><pre><code>dp[0][...]=false </code></pre><p>表示没有物品可选了，此时肯定无法装满背包了</p><pre><code>dp[...][0]=true</code></pre><p>表示背包容量为0，此时什么也不需要做，相当于装满了</p><h3 id="3-推导状态转移方程"><a href="#3-推导状态转移方程" class="headerlink" title="3. 推导状态转移方程"></a>3. 推导状态转移方程</h3><p>推导状态转移方程本质就是做选择，也就是把第i个物体放入或者不放入背包，然后做最优选择就行了</p><h5 id="dp-i-j-dp-i-1-j-dp-i-1-j-nums-i-1"><a href="#dp-i-j-dp-i-1-j-dp-i-1-j-nums-i-1" class="headerlink" title=" dp [ i ] [ j ] = dp [ i - 1 ] [ j ] || dp [ i - 1 ] [ j - nums [ i - 1 ] ] "></a><center><font color="blue"> dp [ i ] [ j ] = dp [ i - 1 ] [ j ] || dp [ i - 1 ] [ j - nums [ i - 1 ] ] </font></center></h5><p>这里需要注意的是数组的下标，由于i是从1开始的，所以题目中的给的数组下标为i-1时表示的是第i个物品的重量。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code>func canPartition(nums []int) bool {    // 先求数组元素和    n, sum := len(nums), 0    for i := range nums {        sum += nums[i]    }    // 如果和不是偶数直接返回    if sum%2 != 0 {        return false    }    // 注意转化成背包问题，背包的重量只有和的一半    sum = sum/2    // 定义dp数组，dp[i][j]表示前否从i个物品中选出恰好装满重量为j背包的物品    // 这里之所以长度是n+1和sum+1是因为dp[0][..]和dp[...][0]是有额外用处的(定义base case)    dp := make([][]bool, n+1)    for i := 0; i &lt;= n; i++ {        dp[i] = make([]bool, sum+1)    }    // 确定base case    // dp[0][...]=false 表示没有物品可选了，此时肯定无法装满背包了    // dp[...][0]=true 表示背包容量为0，此时什么也不需要做，相当于装满了    for i := 0; i &lt; n; i++ {        dp[i][0] = true    }    // 推导状态转移方程，注意这里下标都是从1开始的    for i := 1; i &lt;= n; i++ {        for j := 1; j &lt;= sum; j++ {            // 如果背包容量不够放入第i个物品，肯定不能放            // 注意第i个物品的在nums数组中的下标是1-1            if j - nums[i-1] &lt; 0 {                dp[i][j] = dp[i-1][j]            } else {                // 装入或者不装入背包，看看是否存在刚好装满的情况                dp[i][j] = dp[i-1][j] || dp[i-1][j - nums[i-1]]            }        }    }    return dp[n][sum]}</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="时间复杂度：O-N-S"><a href="#时间复杂度：O-N-S" class="headerlink" title="时间复杂度：O((N*S))"></a>时间复杂度：O((N*S))</h3><p>假设元素的个数为N, 和为S，两层循环，所以算法的总时间复杂度是 O((N*S))</p><h3 id="空间复杂度：O-N-S"><a href="#空间复杂度：O-N-S" class="headerlink" title="空间复杂度：O((N*S))"></a>空间复杂度：O((N*S))</h3><p>需要开辟一个为N*S大小的dp数组。</p><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><p>子集背包属于01背包的变体，可以稍微转化一下在套用01背包的模版。</p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 背包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>01背包问题</title>
      <link href="/2021/03/07/01-bei-bao/"/>
      <url>/2021/03/07/01-bei-bao/</url>
      
        <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://www.nowcoder.com/questionTerminal/2820ea076d144b30806e72de5e5d4bbf" target="_blank" rel="noopener">01背包</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>已知一个背包最多能容纳物体的体积为V<br>现有n个物品第i个物品的体积为v_iv<br>i<br>​<br>  第i个物品的重量为w_iw<br>i<br>​    </p><p>求当前背包最多能装多大重量的物品</p><p>示例1</p><p>输入</p><pre><code>10,2,[[1,3],[10,4]]</code></pre><p>输出</p><pre><code>4</code></pre><p>说明</p><pre><code>第一个物品的体积为1，重量为3，第二个物品的体积为10，重量为4。只取第二个物品可以达到最优方案，取物重量为4 </code></pre><p>备注:</p><pre><code>1≤V≤2001≤n≤2001≤v≤2001≤w≤200</code></pre><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>对于动态规划问题，我们首先需要搞清楚【状态】和【选择】是什么？</p><p>这道题涉及到的变化的状态量有两个，就是背包的体积和当前可选的物品，选择就是把物体装进背包或者不装进背包。</p><p>这样就可以定义我们的dp数组了.</p><h3 id="1-定义dp数组"><a href="#1-定义dp数组" class="headerlink" title="1. 定义dp数组"></a>1. 定义dp数组</h3><p>首先两个状态量就是二维dp数组的两个维度。</p><h5 id="dp-i-j-x表示对于前i个物体，当前背包的体积为j，这种情况下可以装的最大重量是dp-i-j"><a href="#dp-i-j-x表示对于前i个物体，当前背包的体积为j，这种情况下可以装的最大重量是dp-i-j" class="headerlink" title=" dp[i][j]=x表示对于前i个物体，当前背包的体积为j，这种情况下可以装的最大重量是dp[i][j] "></a><center><font color="blue"> dp[i][j]=x表示对于前i个物体，当前背包的体积为j，这种情况下可以装的最大重量是dp[i][j] </font></center></h5><blockquote><p>这里的定义可能并不直观，但是这是背包问题的典型套路，记住就行了</p></blockquote><h3 id="2-确定base-case"><a href="#2-确定base-case" class="headerlink" title="2. 确定base case"></a>2. 确定base case</h3><p>物体个数为0或者背包体积为0时可以装的物体重量都为0，即 </p><pre><code>dp[0][...]=0，dp[...][0]=0</code></pre><h3 id="3-推导状态转移方程"><a href="#3-推导状态转移方程" class="headerlink" title="3. 推导状态转移方程"></a>3. 推导状态转移方程</h3><p>推导状态转移方程本质就是做选择，也就是把第i个物体放入或者不放入背包，然后做最优选择就行了</p><h5 id="dp-i-j-max-dp-i-1-j-dp-i-1-j-vw-i-1-0-vw-i-1-1"><a href="#dp-i-j-max-dp-i-1-j-dp-i-1-j-vw-i-1-0-vw-i-1-1" class="headerlink" title=" dp[i][j] = max((dp[i-1][j], dp[i-1][j-vw[i-1][0]] + vw[i-1][1]))"></a><center><font color="blue"> dp[i][j] = max((dp[i-1][j], dp[i-1][j-vw[i-1][0]] + vw[i-1][1]))</font></center></h5><p>这里需要注意的是数组的下标，由于i是从1开始的，所以题目中的给的数组下标为i-1时表示的是第i个物品的重量。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code>/** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * 计算01背包问题的结果 * @param V int整型 背包的体积 * @param n int整型 物品的个数 * @param vw int整型二维数组 第一维度为n,第二维度为2的二维数组,vw[i][0],vw[i][1]分别描述i+1个物品的vi,wi * @return int整型*/func knapsack(V int ,n int ,vw [][]int ) int {    // 定义dp数组，dp[i][j]表示对于前i个物体，当前背包体积为j，最多可以装多大重量的物体    dp := make([][]int, n+1)    for i := 0; i &lt;= n ; i++ {        // 定义base case        // 物体个数为0或者背包体积为0时可以装的物体重量都为0，即        // dp[0][...]=0，dp[...][0]=0这个已经自动初始化好了        dp[i] = make([]int, V+1)    }    // 推导状态转移方程    // 按照物体数量进行遍历    for i := 1; i &lt;= n; i++ {        // 按照背包可用体积进行遍历        for j := 1; j &lt;= V; j++ {            // 背包体积已经不够装第i个物体了,只能不装入背包            if j - vw[i-1][0] &lt; 0 {                dp[i][j] = dp[i-1][j]            } else {                // 可以选择装入或不装入，取较大值                dp[i][j] = max(dp[i-1][j], dp[i-1][j-vw[i-1][0]] + vw[i-1][1])            }        }    }    return dp[n][V]}</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="时间复杂度：O-C-N"><a href="#时间复杂度：O-C-N" class="headerlink" title="时间复杂度：O((C*N))"></a>时间复杂度：O((C*N))</h3><p>假设物品的个数为N, 背包的容量是C，两层循环，所以算法的总时间复杂度是 O((C*N))</p><h3 id="空间复杂度：O-C-N"><a href="#空间复杂度：O-C-N" class="headerlink" title="空间复杂度：O((C*N))"></a>空间复杂度：O((C*N))</h3><p>需要开辟一个为C*N大小的dp数组。</p><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><p>背包问题是非常经典的动态规划问题，本题01背包是其中最基本的问题，先熟悉一下套路。</p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 背包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【leetcode-312】戳气球</title>
      <link href="/2021/03/07/leetcode-312/"/>
      <url>/2021/03/07/leetcode-312/</url>
      
        <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/burst-balloons/" target="_blank" rel="noopener">312. 戳气球</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>有 n 个气球，编号为0 到 n - 1，每个气球上都标有一个数字，这些数字存在数组 nums 中。</p><p>现在要求你戳破所有的气球。戳破第 i 个气球，你可以获得 nums[i - 1] <em> nums[i] </em> nums[i + 1] 枚硬币。 这里的 i - 1 和 i + 1 代表和 i 相邻的两个气球的序号。如果 i - 1或 i + 1 超出了数组的边界，那么就当它是一个数字为 1 的气球。</p><p>求所能获得硬币的最大数量。</p><p>示例 1：</p><pre><code>输入：nums = [3,1,5,8]输出：167解释：nums = [3,1,5,8] --&gt; [3,5,8] --&gt; [3,8] --&gt; [8] --&gt; []coins =  3*1*5    +   3*5*8   +  1*3*8  + 1*8*1 = 167</code></pre><p>示例 2：</p><pre><code>输入：nums = [1,5]输出：10</code></pre><p>提示：</p><ul><li>n == nums.length</li><li>1 &lt;= n &lt;= 500</li><li>0 &lt;= nums[i] &lt;= 100</li></ul><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>对于这道题依旧是采用动态规划算法，但是这道题的独特之处在于每戳破一个气球，得到的分数和该气球相邻的气球nums[left]和nums[right]是有相关性的。</p><p>我们之前提到动态规划算法需要满足的一个条件是子问题之间必须是相互独立的。因此，为了解决这个问题，我们需要想办法通过定义dp数组来避免这个相关性。</p><p>实际上最关键的就两点</p><h3 id="1-定义dp数组"><a href="#1-定义dp数组" class="headerlink" title="1. 定义dp数组"></a>1. 定义dp数组</h3><h5 id="dp-i-j-x表示戳破气球i和j之间的所有气球可以获得的最高分数为x"><a href="#dp-i-j-x表示戳破气球i和j之间的所有气球可以获得的最高分数为x" class="headerlink" title=" dp[i][j]=x表示戳破气球i和j之间的所有气球可以获得的最高分数为x "></a><center><font color="blue"> dp[i][j]=x表示戳破气球i和j之间的所有气球可以获得的最高分数为x </font></center></h5><h3 id="2-推导状态转移方程"><a href="#2-推导状态转移方程" class="headerlink" title="2. 推导状态转移方程"></a>2. 推导状态转移方程</h3><p>这里需要逆向思考，气球i和气球j之间最后一个被戳破的气球是哪个？</p><p>这里可以假设为第k个, 那么</p><h5 id="dp-i-j-dp-i-k-dp-k-i-nums-i-nums-k-nums-j"><a href="#dp-i-j-dp-i-k-dp-k-i-nums-i-nums-k-nums-j" class="headerlink" title=" dp[i][j]=dp[i][k]+dp[k][i]+nums[i]nums[k]nums[j]"></a><center><font color="blue"> dp[i][j]=dp[i][k]+dp[k][i]+nums[i]<em>nums[k]</em>nums[j]</font></center></h5><p>这里是个难点，可以画图思考一下为什么。</p><p>解决了以上两个问题，最后需要注意一下 i, j, k 的遍历顺序就行了。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code>func maxCoins(nums []int) int {    // 在两侧添加虚拟气球    nums = append(append([]int{1}, nums...), 1)    // 定义dp数组，dp[i][j]表示戳破气球i和气球j之间的所有气球所能获得的最高分数    // dp数组的长度为气球的个数（包括新加的虚拟气球）    n := len(nums)    dp := make([][]int, n)    for i := range dp {        dp[i] = make([]int, n)    }    // 确定base case，这里base case已经都被初始化为0，不需要重新赋值    // 推导状态转移方程    // i自下而上    for i := n - 1; i &gt;= 0 ; i-- {        // j自左向右        for j := i; j &lt;= n-1 ; j++ {            // 在i和j之间枚举k, 假设最后戳破气球k（注意i和j取不到）            for k := i + 1; k &lt; j; k++ {                dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + nums[i] * nums[j] * nums[k])            }        }    }    return dp[0][n-1]}</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="时间复杂度：O-N-3"><a href="#时间复杂度：O-N-3" class="headerlink" title="时间复杂度：O((N^3))"></a>时间复杂度：O((N^3))</h3><p>i，j，k三层循环，每层循环的复杂度是N</p><p>所以算法的总时间复杂度是 O((K<em>N</em>logN))</p><h3 id="空间复杂度：O-N-2"><a href="#空间复杂度：O-N-2" class="headerlink" title="空间复杂度：O((N^2))"></a>空间复杂度：O((N^2))</h3><p>需要开辟一个为N*N的dp数组。</p><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><p>我们之前提到动态规划算法需要满足的一个条件是子问题之间必须是相互独立的。因此，为了解决这个问题，我们需要想办法通过定义dp数组来避免这个相关性。</p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Go源码解析8】for和range循环</title>
      <link href="/2021/03/02/go-sourcecode-for/"/>
      <url>/2021/03/02/go-sourcecode-for/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本节将深入分析 Go 语言的两种循环，也就是 for 循环和 for-range 循环，我们会分析这两种循环的运行时结构以及它们的实现原理。</p></blockquote><p><img src="https://vegard-bear.github.io/images/for%E5%BE%AA%E7%8E%AF.png" alt></p><blockquote><p>点击图片查看高清大图</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> 源码解析 </tag>
            
            <tag> 循环 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【leetcode-887】鸡蛋掉落</title>
      <link href="/2021/02/28/leetcode-887/"/>
      <url>/2021/02/28/leetcode-887/</url>
      
        <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/super-egg-drop/" target="_blank" rel="noopener">887. 鸡蛋掉落</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>你将获得 K 个鸡蛋，并可以使用一栋从 1 到 N  共有 N 层楼的建筑。</p><p>每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它掉下去。</p><p>你知道存在楼层 F ，满足 0 &lt;= F &lt;= N 任何从高于 F 的楼层落下的鸡蛋都会碎，从 F 楼层或比它低的楼层落下的鸡蛋都不会破。</p><p>每次移动，你可以取一个鸡蛋（如果你有完整的鸡蛋）并把它从任一楼层 X 扔下（满足 1 &lt;= X &lt;= N）。</p><p>你的目标是确切地知道 F 的值是多少。</p><p>无论 F 的初始值如何，你确定 F 的值的最小移动次数是多少？</p><p>样例 1:</p><pre><code>输入：K = 1, N = 2输出：2解释：鸡蛋从 1 楼掉落。如果它碎了，我们肯定知道 F = 0 。否则，鸡蛋从 2 楼掉落。如果它碎了，我们肯定知道 F = 1 。如果它没碎，那么我们肯定知道 F = 2 。因此，在最坏的情况下我们需要移动 2 次以确定 F 是多少。</code></pre><p>样例 2:</p><pre><code>输入：K = 2, N = 6输出：3</code></pre><p>示例 3：</p><pre><code>输入：K = 3, N = 14输出：4</code></pre><p>注释:</p><ul><li>1 &lt;= K &lt;= 100</li><li>1 &lt;= N &lt;= 10000</li></ul><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>参考 <a href="https://leetcode-cn.com/problems/super-egg-drop/solution/ji-ben-dong-tai-gui-hua-jie-fa-by-labuladong/" target="_blank" rel="noopener">题目理解 + 基本解法 + 进阶解法</a></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code>// 使用备忘录消解重叠子问题var memo map[string]intfunc superEggDrop(K int, N int) int {    memo = make(map[string]int, 0)    // dp(i,j)表示当前还剩i个鸡蛋，面对j层楼时的最小移动次数    return dp(K, N)}func dp(K, N int) int {    // 确定 base case    // 当只剩一个鸡蛋时，只能线性扫描所有楼层，所以直接返回楼层数    if K == 1 {        return N    }    // 当楼层数为0时，说明不用接着扔鸡蛋了    if N == 0 {        return 0    }    if _, ok := memo[string(K) + string(N)]; ok  {        return memo[string(K) + string(N)]    }    // 先初始化结果为无限大    res := math.MaxInt32    // 穷举所有可能，在所有楼层中选第i层扔鸡蛋，最后要其中最小的结果    //for i := 1; i &lt;= N ; i++  {    //    res = min(res, max(    //        dp(K, N-i),     // 没碎，鸡蛋数不变，然后往上找    //        dp(K-1, i-1)) + 1 )  // 碎了，鸡蛋数-1，然后往下找    //}    // 使用二分搜索代替线性搜索    low, high := 1, N    for low &lt;= high  {        mid := (low + high)/2        broken := dp(K-1, mid-1) // 碎了，鸡蛋数-1，然后往下一层找        notBroken := dp(K, N-mid) // 碎了，鸡蛋数-1，然后往上找        if notBroken &gt;= broken {            // 说明在交点的左侧，需要向右半部分搜索，左边界右移动            low = mid + 1            // 此时两条曲线的较大值属于notBroken这条曲线            res = min(res, notBroken + 1)        } else {            // 说明在交点的右侧，需要向左半部分搜索，右边界左移            high = mid - 1            // 此时两条曲线的较大值属于broken这条曲线            res = min(res, broken + 1)        }    }    // 将结果记录备忘录    memo[string(K)+string(N)] = res    return res}</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="时间复杂度：O-KNlogN"><a href="#时间复杂度：O-KNlogN" class="headerlink" title="时间复杂度：O((KNlogN))"></a>时间复杂度：O((K<em>N</em>logN))</h3><p>动态规划算法的时间复杂度就是子问题个数 × 函数本身的复杂度。</p><p>函数本身的复杂度就是忽略递归部分的复杂度，这里 dp 函数中用了一个二分搜索，所以函数本身的复杂度是 O((logN))。</p><p>子问题个数也就是不同状态组合的总数，显然是两个状态的乘积，也就是 O((KN))。</p><p>所以算法的总时间复杂度是 O((K<em>N</em>logN))</p><h3 id="空间复杂度：O-KN"><a href="#空间复杂度：O-KN" class="headerlink" title="空间复杂度：O((KN))"></a>空间复杂度：O((KN))</h3><p>需要开辟一个长度为K*N的memo数组。</p><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><p>对动态规划问题，最重要的是想清楚这个问题有什么「状态」，有什么「选择」，然后套用算法框架即可。</p><ul><li><p>「状态」很明显，就是当前拥有的鸡蛋数 K 和需要测试的楼层数 N。随着测试的进行，鸡蛋个数可能减少，楼层的搜索范围会减小，这就是状态的变化。</p></li><li><p>「选择」其实就是去选择哪层楼扔鸡蛋。不同的选择会造成不同的状态转移。</p></li></ul><p>当然，这道题为了降低时间复杂度，对于穷举选择的过程采用了二分搜索进行优化，所以难度会更大一些。</p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【基金02】基金入门</title>
      <link href="/2021/02/08/fund-02/"/>
      <url>/2021/02/08/fund-02/</url>
      
        <content type="html"><![CDATA[<h1 id="基金入门"><a href="#基金入门" class="headerlink" title="基金入门"></a>基金入门</h1><p><img src="https://vegard-bear.github.io/images/%E5%9F%BA%E9%87%91%E5%85%A5%E9%97%A8.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 投资 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基金 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【基金01】投资的基石</title>
      <link href="/2021/02/06/fund-01/"/>
      <url>/2021/02/06/fund-01/</url>
      
        <content type="html"><![CDATA[<h1 id="投资的基石"><a href="#投资的基石" class="headerlink" title="投资的基石"></a>投资的基石</h1><p><img src="https://vegard-bear.github.io/images/%E6%8A%95%E8%B5%84%E7%9A%84%E5%9F%BA%E7%9F%B3.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 投资 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基金 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Go源码解析7】反射</title>
      <link href="/2021/01/26/go-sourcecode-reflect/"/>
      <url>/2021/01/26/go-sourcecode-reflect/</url>
      
        <content type="html"><![CDATA[<blockquote><p>虽然在大多数的应用和服务中并不常见，但是很多框架都依赖 Go 语言的反射机制简化代码。因为 Go 语言的语法元素很少、设计简单，所以它没有特别强的表达能力，但是 Go 语言的 reflect 包能够弥补它在语法上reflect.Type的一些劣势。</p></blockquote><p><img src="https://vegard-bear.github.io/images/%E5%8F%8D%E5%B0%84.png" alt></p><blockquote><p>点击图片查看高清大图</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> 源码解析 </tag>
            
            <tag> 反射 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【leetcode-651】4键键盘</title>
      <link href="/2021/01/24/leetcode-651/"/>
      <url>/2021/01/24/leetcode-651/</url>
      
        <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/4-keys-keyboard/" target="_blank" rel="noopener">651. 4键键盘</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>假设你有一个特殊的键盘包含下面的按键：</p><p>Key 1: ((A))：在屏幕上打印一个 ‘A’。</p><p>Key 2: ((Ctrl-A))：选中整个屏幕。</p><p>Key 3: ((Ctrl-C))：复制选中区域到缓冲区。</p><p>Key 4: ((Ctrl-V))：将缓冲区内容输出到上次输入的结束位置，并显示在屏幕上。</p><p>现在，你只可以按键 N 次（使用上述四种按键），请问屏幕上最多可以显示几个 ‘A’呢？</p><p>样例 1:</p><pre><code>输入: N = 3输出: 3解释: 我们最多可以在屏幕上显示三个&#39;A&#39;通过如下顺序按键：A, A, A</code></pre><p>样例 2:</p><pre><code>输入: N = 7输出: 9解释: 我们最多可以在屏幕上显示九个&#39;A&#39;通过如下顺序按键：A, A, A, Ctrl A, Ctrl C, Ctrl V, Ctrl V</code></pre><p>注释:</p><ul><li>1 &lt;= N &lt;= 50</li><li>结果不会超过 32 位有符号整数范围。</li></ul><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>这题依旧是用动态规划解决，而动态规划就是要定义dp数组，base case以及推导状态转移方程。</p><h2 id="动态规划三步走"><a href="#动态规划三步走" class="headerlink" title="动态规划三步走"></a>动态规划三步走</h2><h4 id="定义dp数组"><a href="#定义dp数组" class="headerlink" title="定义dp数组"></a>定义dp数组</h4><p>这里的dp数组定义并不难，直接按照题意定义即可：</p><h5 id="dp-i-表示进行i次操作后最多能显示多少个A"><a href="#dp-i-表示进行i次操作后最多能显示多少个A" class="headerlink" title="dp[i] 表示进行i次操作后最多能显示多少个A"></a><center><font color="red">dp[i] 表示进行i次操作后最多能显示多少个A</font></center></h5><h4 id="确定-base-case"><a href="#确定-base-case" class="headerlink" title="确定 base case"></a>确定 base case</h4><p>根据dp数组的定义。我们就可以确定 base case，即</p><h5 id="dp-0-0"><a href="#dp-0-0" class="headerlink" title="dp[0] = 0 "></a><center><font color="red">dp[0] = 0 </font></center></h5><p>表示进行0次操作能得到0个A</p><h4 id="推导状态转移方程"><a href="#推导状态转移方程" class="headerlink" title="推导状态转移方程"></a>推导状态转移方程</h4><p>依旧是采用数学归纳法来寻找状态转移关系：假设我们已经计算出了dp[i-1],如何推导出dp[i]呢？</p><p>我们首先需要看由dp[i-1]得到dp[i]需要经过哪些状态，也就是会有哪几种选择。由于可以进行四种操作，所以看起来是有4个选择，实际上不然。我们仔细思考后会发现<font color="red">按键序列只有两种：</font></p><ol><li>要么一直按A：A,A,A,A…,A（当N比较小时）</li><li>要么先按几个A，再一直按C-A,C-C,C-v（当N比较大时）</li></ol><p>因为</p><ul><li>字符数量少（N 比较小）时，C-A C-C C-V 这一套操作的代价相对比较高，可能不如一个个按 A。</li><li>而当 N 比较大时，后期 C-V 的收获肯定很大。这种情况下整个操作序列大致是：开头连按几个 A，然后 C-A C-C 组合再接若干 C-V，然后再 C-A C-C 接着若干 C-V，循环下去。</li></ul><p>换句话说，最后一次按键要么是 A 要么是 C-V。明确了这一点，可以通过这两种情况来设计算法：</p><pre><code>int[] dp = new int[N + 1];// 定义：dp[i] 表示 i 次操作后最多能显示多少个 Afor (int i = 0; i &lt;= N; i++)     dp[i] = max(            这次按 A 键，            这次按 C-V        )</code></pre><p>对于「按 A 键」这种情况，就是状态 i - 1 的屏幕上新增了一个 A 而已，很容易得到结果：</p><pre><code>// 按 A 键，就比上次多一个 A 而已dp[i] = dp[i - 1] + 1;但是，如果要按 C-V，还要考虑之前是在哪里 C-A C-C 的。刚才说了，最优的操作序列一定是 C-A C-C 接着若干 C-V，所以我们用一个变量 j 作为若干 C-V 的起点。那么 j 之前的 2 个操作就应该是 C-A C-C 了：public int maxA(int N) {    int[] dp = new int[N + 1];    dp[0] = 0;    for (int i = 1; i &lt;= N; i++) {        // 按 A 键        dp[i] = dp[i - 1] + 1;        for (int j = 2; j &lt; i; j++) {            // 全选 &amp; 复制 dp[j-2]，连续粘贴 i - j 次            // 屏幕上共 dp[j - 2] * (i - j + 1) 个 A            dp[i] = Math.max(dp[i], dp[j - 2] * (i - j + 1));        }    }    // N 次按键之后最多有几个 A？    return dp[N];}</code></pre><p>其中 j 变量减 2 是给 C-A C-C 留下操作数，看个图就明白了：</p><p><img src="https://gblobscdn.gitbook.com/assets%2F-MREMDZyyb0x7r5aTgIC%2Fsync%2F43c7985b4e7201e0ffc8ff5c580883e60e98ed3b.jpg?alt=media" alt></p><p>至此，我们就可以直接写代码了。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code>func maxA(N int) int {    // 定义 dp 数组, dp[i]表述按下i次键最多可以得到的&#39;A&#39;的个数    dp := make([]int, N + 1)    // 确定 base case    dp[0] = 0    // 开始遍历 dp 数组    for i := 1; i &lt;= N ; i++ {        // 如果这次按&#39;A&#39;键, 消耗一次操作数，多一个&#39;A&#39;        dp[i] = dp[i-1] + 1        // 如果这次按的是&#39;C-V&#39;键，那么就需要知道当前剪切板中有多少个&#39;A&#39;        // 当前剪切板中有多少个&#39;A&#39;取决于上次进行&#39;C-A，C-V&#39;的操作时有多少个&#39;A&#39;        // 假设上次进行完&#39;C-A，C-V&#39;的操作时已经按下j个键，那么进行&#39;C-A，C-V&#39;的操作前则按下了j-2个键        // 那么我们就可以进行穷举，依次计算在第i次操作前某一时刻进行&#39;C-A，C-V&#39;操作时能产生的&#39;A&#39;的个数，并取其中最大值        for j := 2 ; j &lt; i ; j++ {     // 注意，为了避免数组越界，这里j需要从2开始枚举            dp[i] = max(dp[i], dp[j-2] * (i - j +1))        }    }    // 最后返回N次操作最多可以得到的&#39;A&#39;的个数    return dp[N]}func max(a, b int) int {    if a &gt; b {        return a    }    return b}</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="时间复杂度：O-n-2"><a href="#时间复杂度：O-n-2" class="headerlink" title="时间复杂度：O((n^2))"></a>时间复杂度：O((n^2))</h3><p>两层循环，每一层是操作数N。</p><h3 id="空间复杂度：O-mn"><a href="#空间复杂度：O-mn" class="headerlink" title="空间复杂度：O((mn))"></a>空间复杂度：O((mn))</h3><p>需要开辟一个长度为N的dp数组。</p><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><p>动态规划难就难在寻找状态转移，不同的定义可以产生不同的状态转移逻辑，虽然最后都能得到正确的结果，但是效率可能有巨大的差异。</p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【leetcode-10】正则表达式匹配</title>
      <link href="/2021/01/23/leetcode-10/"/>
      <url>/2021/01/23/leetcode-10/</url>
      
        <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/regular-expression-matching/" target="_blank" rel="noopener">10. 正则表达式匹配</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘*’ 的正则表达式匹配。</p><p>‘.’ 匹配任意单个字符<br>‘*’ 匹配零个或多个前面的那一个元素<br>所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。</p><p>示例 1：</p><pre><code>输入：s = &quot;aa&quot; p = &quot;a&quot;输出：false解释：&quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。</code></pre><p>示例 2:</p><pre><code>输入：s = &quot;aa&quot; p = &quot;a*&quot;输出：true解释：因为 &#39;*&#39; 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 &#39;a&#39;。因此，字符串 &quot;aa&quot; 可被视为 &#39;a&#39; 重复了一次。</code></pre><p>示例 3：</p><pre><code>输入：s = &quot;ab&quot; p = &quot;.*&quot;输出：true解释：&quot;.*&quot; 表示可匹配零个或多个（&#39;*&#39;）任意字符（&#39;.&#39;）。</code></pre><p>示例 4：</p><pre><code>输入：s = &quot;aab&quot; p = &quot;c*a*b&quot;输出：true解释：因为 &#39;*&#39; 表示零个或多个，这里 &#39;c&#39; 为 0 个, &#39;a&#39; 被重复一次。因此可以匹配字符串 &quot;aab&quot;。</code></pre><p>示例 5：</p><pre><code>输入：s = &quot;mississippi&quot; p = &quot;mis*is*p*.&quot;输出：false</code></pre><p>提示：</p><ul><li>0 &lt;= s.length &lt;= 20</li><li>0 &lt;= p.length &lt;= 30</li><li>s 可能为空，且只包含从 a-z 的小写字母。</li><li>p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。</li><li>保证每次出现字符 * 时，前面都匹配到有效的字符</li></ul><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>这题的解体思路有点复杂，具体见书 P155</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code>func isMatch(s string, p string) bool {    return dp(s, 0, p, 0)}func dp(s string, i int, p string, j int) bool {    // 定义 base case    m, n := len(s), len(p)    // 模式p已经匹配完了，检查文本串s匹配是否也匹配完    if j == n {        return i == m    }    // 文本串已经匹配完了，检查模式串能否匹配空串    if i == m {        // 如果能匹配空串，一定是字符和 * 成对出现，所以长度一定是偶数        if (n-j) % 2 == 1 {            return false        }        // 检查模式串是否为 x*y*z* 这种形式        for ; j + 1 &lt; len(p) ; j += 2 {            if p[j+1] != &#39;*&#39; {                return false            }        }        return true    }    // 初始化结果为false    res := false    // 如果两个字符匹配，那么看模式串    // 如果模式串为&#39;.&#39;，意味着模式串当前字符可以匹配任意文本串字符    if s[i] == p[j] || p[j] == &#39;.&#39; {        // 看模式串下一个字符，如果下一个字符为&#39;*&#39;，意味着可以匹配任意个数量的字符，那么要么匹配0次，要么匹配多次        if j &lt; len(p) - 1 &amp;&amp; p[j+1] == &#39;*&#39;{            res = dp(s, i, p, j + 2) || dp(s, i + 1, p, j)        } else {            // 如果下一个字符不是&#39;*&#39;，那么就只能正常匹配一次, i 和 j 依次各移动一位            res = dp(s, i + 1, p, j+1)        }    } else {        // 两个字符不匹配        // 那么就看模式串下一个字符，如果模式串下一个字符为&#39;*&#39;        if j &lt; len(p) - 1 &amp;&amp; p[j+1] == &#39;*&#39; {            // 通配符匹配0次            res = dp(s, i, p, j + 2)        } else {            // 下一个字符也不是&#39;*&#39;            res = false        }    }    return res}</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="时间复杂度：O-mn"><a href="#时间复杂度：O-mn" class="headerlink" title="时间复杂度：O((mn))"></a>时间复杂度：O((mn))</h3><p>动态规划的时间复杂度为 “状态的总数” <em> “每次递归花费的时间”，本题中状态的总数当然是 i 和 j 的组合，也就是 m </em> n ( m 为字符串 s 的长度，n 为模式串串 p 的长度)</p><h3 id="空间复杂度：O-mn"><a href="#空间复杂度：O-mn" class="headerlink" title="空间复杂度：O((mn))"></a>空间复杂度：O((mn))</h3><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【leetcode-1312】让字符串成为回文串的最少插入次数</title>
      <link href="/2021/01/21/leetcode-1312/"/>
      <url>/2021/01/21/leetcode-1312/</url>
      
        <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/minimum-insertion-steps-to-make-a-string-palindrome/" target="_blank" rel="noopener">1312. 让字符串成为回文串的最少插入次数</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一个字符串 s ，每一次操作你都可以在字符串的任意位置插入任意字符。</p><p>请你返回让 s 成为回文串的 最少操作次数 。</p><p>「回文串」是正读和反读都相同的字符串。</p><p>示例 1：</p><pre><code>输入：s = &quot;zzazz&quot;输出：0解释：字符串 &quot;zzazz&quot; 已经是回文串了，所以不需要做任何插入操作。</code></pre><p>示例 2：</p><pre><code>输入：s = &quot;mbadm&quot;输出：2解释：字符串可变为 &quot;mbdadbm&quot; 或者 &quot;mdbabdm&quot; 。</code></pre><p>示例 3：</p><pre><code>输入：s = &quot;leetcode&quot;输出：5解释：插入 5 个字符后字符串变为 &quot;leetcodocteel&quot; 。</code></pre><p>示例 4：</p><pre><code>输入：s = &quot;g&quot;输出：0</code></pre><p>示例 5：</p><pre><code>输入：s = &quot;no&quot;输出：1</code></pre><p>提示：</p><ul><li>1 &lt;= s.length &lt;= 500</li><li>s 中所有字符都是小写字母。</li></ul><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>这道题和 <font color="blue">最长回文子序列</font> 一样套用的都是单个字符串的二维dp数组模版。</p><h2 id="动态规划三步走"><a href="#动态规划三步走" class="headerlink" title="动态规划三步走"></a>动态规划三步走</h2><h4 id="定义dp数组"><a href="#定义dp数组" class="headerlink" title="定义dp数组"></a>定义dp数组</h4><p>注意这里由于有两个字符串，所以我们需要定义一个二维的dp数组。</p><h5 id="dp-i-j-表示让子串s-i…j-成为回文子序列的最少插入次数"><a href="#dp-i-j-表示让子串s-i…j-成为回文子序列的最少插入次数" class="headerlink" title="dp[i][j] 表示让子串s[i…j]成为回文子序列的最少插入次数"></a><center><font color="red">dp[i][j] 表示让子串s[i…j]成为回文子序列的最少插入次数</font></center></h5><h4 id="确定-base-case"><a href="#确定-base-case" class="headerlink" title="确定 base case"></a>确定 base case</h4><p>根据dp数组的定义。我们就可以确定 base case，即</p><h5 id="当-i-等于-j-时-dp-i-j-1"><a href="#当-i-等于-j-时-dp-i-j-1" class="headerlink" title="当 i 等于 j 时, dp[i][j] = 1 "></a><center><font color="red">当 i 等于 j 时, dp[i][j] = 1 </font></center></h5><p>这是因为i等于j时，dp[i][j]表示单个字符，而单个字符一定是回文序列，此时不需要插入字符，也就是说插入次数为0，也就是说二维dp数组的对角线上都是0</p><h4 id="推导状态转移方程"><a href="#推导状态转移方程" class="headerlink" title="推导状态转移方程"></a>推导状态转移方程</h4><p>依旧是采用数学归纳法来寻找状态转移关系：假设我们已经计算出了dp[i+1][j-1]，dp[i+1][j]以及dp[i][j-1],如何推导出dp[i][j]呢？</p><p>对于dp[i][j]有两种选择：</p><ol><li>如果s[i]等于s[j]，也就是首尾两个字符相等，那么直接拼上中间的最长回文序列，形成一个更长的回文子序列，此时不需要插入字符。</li><li>如果 s[i] 等于 s[j]，那么此时只有三个选择，要么在右边插一个字符，要么在左边插一个字符，要么都插<big></big></li></ol><pre><code>             dp[i+1][j-1]                                                       当s[i]==s[j]时dp[i][j] =              dp[i][j] = min(min(dp[i+1][j], dp[i][j-1]) + 1, dp[i+1][j-1] + 2)  当s[i]!=s[j]时</code></pre><h4 id="dp数组遍历方式"><a href="#dp数组遍历方式" class="headerlink" title="dp数组遍历方式"></a>dp数组遍历方式</h4><p>最后还剩下一个问题，就是dp数组的遍历方式，注意这里其实是有两种遍历方式的，我们取其中一种即可，至于具体怎么选择，可参考 <a href="https://leetcode-cn.com/problems/longest-palindromic-subsequence/solution/zi-xu-lie-wen-ti-tong-yong-si-lu-zui-chang-hui-wen/" target="_blank" rel="noopener">子序列问题通用思路|最长回文子序列</a></p><p>至此，我们就可以直接写代码了。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code>func minInsertions(s string) int {    // 按照字符串长度定义一个 n*n 的 dp 二维数组    // dp[i][j] 表示 s[i..j] 的最少插入次数    n := len(s)    dp := make([][]int, n)    for i := range dp {        dp[i] = make([]int, n)    }    // 定义 base case, 当 i 等于 j 时，说明是单个字符，必定回文，所以插入次数为 0，由于默认是0，所以不用赋值    // for i := 0; i &lt; n ; i++ {    //     dp[i][i] = 0    // }    // 开始遍历 dp 数组，注意遍历顺序    for i := n - 2; i &gt;= 0 ; i-- {        for j := i + 1; j &lt; n ; j++ {            // 如果 s[i] 等于 s[j]，说明首尾字符串相等，已经是回文了，不需要再插入字符            if s[i] == s[j] {                dp[i][j] = dp[i+1][j-1]            } else {                // 如果 s[i] 等于 s[j]，那么此时只有三个选择，要么在右边插一个字符，要么在左边插一个字符，要么都插                dp[i][j] = min(min(dp[i+1][j], dp[i][j-1]) + 1, dp[i+1][j-1] + 2)            }        }    }    return dp[0][n-1]}func min(a, b int) int  {    if a &lt; b {        return a    }    return b}</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="时间复杂度：O-n-2"><a href="#时间复杂度：O-n-2" class="headerlink" title="时间复杂度：O((n^2))"></a>时间复杂度：O((n^2))</h3><p>n 为字符串 s 的长度</p><h3 id="空间复杂度：O-n-2"><a href="#空间复杂度：O-n-2" class="headerlink" title="空间复杂度：O((n^2))"></a>空间复杂度：O((n^2))</h3><p>我们需要大小为 O((n^2)) 的 dp 数组来记录状态值。</p><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><p>这道题和 <font color="blue">最长回文子序列</font> 一样套用的都是单个字符串的二维dp数组模版。</p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Go源码解析6】接口</title>
      <link href="/2021/01/20/go-sourcecode-interface/"/>
      <url>/2021/01/20/go-sourcecode-interface/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Go 语言中的接口是一组方法的签名，它是 Go 语言的重要组成部分。使用接口能够让我们写出易于测试的代码，然而很多工程师对 Go 的接口了解都非常有限，也不清楚其底层的实现原理，这成为了开发高性能服务的阻碍。</p></blockquote><p><img src="https://vegard-bear.github.io/images/%E6%8E%A5%E5%8F%A3.png" alt></p><blockquote><p>点击图片查看高清大图</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> 源码解析 </tag>
            
            <tag> 接口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【leetcode-516】最长回文子序列</title>
      <link href="/2021/01/19/leetcode-516/"/>
      <url>/2021/01/19/leetcode-516/</url>
      
        <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/longest-palindromic-subsequence/" target="_blank" rel="noopener">516. 最长回文子序列</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个字符串 s ，找到其中最长的回文子序列，并返回该序列的长度。可以假设 s 的最大长度为 1000 。</p><p>示例 1:</p><p>输入:</p><pre><code>&quot;bbbab&quot;</code></pre><p>输出:</p><pre><code>4</code></pre><p>一个可能的最长回文子序列为 “bbbb”。</p><p>示例 2:</p><p>输入:</p><pre><code>&quot;cbbd&quot;</code></pre><p>输出:</p><pre><code>2</code></pre><p>一个可能的最长回文子序列为 “bb”。</p><p>提示：</p><ul><li>1 &lt;= s.length &lt;= 1000</li><li>s 只包含小写英文字母</li></ul><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>这道题和<font color="blue">最长公共子序列</font>以及<font color="blue">编辑距离</font>套用的都是二维的dp数组模版</p><h2 id="动态规划三步走"><a href="#动态规划三步走" class="headerlink" title="动态规划三步走"></a>动态规划三步走</h2><h4 id="定义dp数组"><a href="#定义dp数组" class="headerlink" title="定义dp数组"></a>定义dp数组</h4><p>注意这里由于有两个字符串，所以我们需要定义一个二维的dp数组。</p><h5 id="dp-i-j-表示子串s-i…j-的最长回文子序列长度"><a href="#dp-i-j-表示子串s-i…j-的最长回文子序列长度" class="headerlink" title="dp[i][j] 表示子串s[i…j]的最长回文子序列长度"></a><center><font color="red">dp[i][j] 表示子串s[i…j]的最长回文子序列长度</font></center></h5><h4 id="确定-base-case"><a href="#确定-base-case" class="headerlink" title="确定 base case"></a>确定 base case</h4><p>根据dp数组的定义。我们就可以确定 base case，即</p><h5 id="当-i-等于-j-时-dp-i-j-1"><a href="#当-i-等于-j-时-dp-i-j-1" class="headerlink" title="当 i 等于 j 时, dp[i][j] = 1 "></a><center><font color="red">当 i 等于 j 时, dp[i][j] = 1 </font></center></h5><p>这是因为i等于j时，dp[i][j]表示单个字符，而单个字符一定是回文序列，且长度为1，也就是说二维dp数组的对角线上都是1</p><h4 id="推导状态转移方程"><a href="#推导状态转移方程" class="headerlink" title="推导状态转移方程"></a>推导状态转移方程</h4><p>依旧是采用数学归纳法来寻找状态转移关系：假设我们已经计算出了dp[i-1][j-1]，dp[i-1][j]以及dp[i][j-1],如何推导出dp[i][j]呢？</p><p>对于dp[i][j]有两种选择：</p><ol><li>如果s[i]等于s[j]，也就是首尾两个字符相等，那么直接拼上中间的最长回文序列，形成一个更长的回文子序列，此时子序列的长度+2。</li><li>如果s[i]不等于s[j]，也就是首尾两个字符不相等，那么就将这两个字符分别加入中间的最长回文子序列，取其中更长的那个即可。<big>```                   dp[i+1][j-1]+2                   当s[i]==s[j]时dp[i][j] =           max(dp[i+1][j], dp[i][j-1])      当s[i]!=s[j]时```</big></li></ol><h4 id="dp数组遍历方式"><a href="#dp数组遍历方式" class="headerlink" title="dp数组遍历方式"></a>dp数组遍历方式</h4><p>最后还剩下一个问题，就是dp数组的遍历方式，注意这里其实是有两种遍历方式的，我们取其中一种即可，至于具体怎么选择，可参考 <a href="https://leetcode-cn.com/problems/longest-palindromic-subsequence/solution/zi-xu-lie-wen-ti-tong-yong-si-lu-zui-chang-hui-wen/" target="_blank" rel="noopener">子序列问题通用思路|最长回文子序列</a></p><p>至此，我们就可以直接写代码了。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code>func longestPalindromeSubseq(s string) int {    // 初始化二维dp数组    // dp[i][j]表示子串s[i...j]的最长回文子序列长度    n := len(s)    dp := make([][]int, n)    for i := range dp {        dp[i] = make([]int, n)    }    // 确定base case    // 注意对角线上是1，这是因为dp[i][i]表示单个字符，而单个字符一定是回文序列，且长度为1    for i := 0; i &lt; n ; i++ {        dp[i][i] = 1    }    // 推导状态转移方程，注意这里dp数组的遍历方式    for i := n - 2 ; i &gt;= 0 ; i-- {        for j := i + 1 ; j &lt; n ; j++ {            // 如果首尾两个字符相等，那么直接拼上中间的最长回文序列            if s[i] == s[j] {                dp[i][j] = dp[i+1][j-1] +2            } else {                // 如果首尾两个字符不相等，那么就将这两个字符分别加入中间的最长回文子序列，取其中更长的那个即可                dp[i][j] = max(dp[i+1][j], dp[i][j-1])            }        }    }    // 最后返回整个字符串s的最长回文子序列    return dp[0][n-1]}func max(a, b int) int {    if a &gt; b {        return a    }    return b}</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="时间复杂度：O-n-2"><a href="#时间复杂度：O-n-2" class="headerlink" title="时间复杂度：O((n^2))"></a>时间复杂度：O((n^2))</h3><p>n 为字符串 s 的长度</p><h3 id="空间复杂度：O-n-2"><a href="#空间复杂度：O-n-2" class="headerlink" title="空间复杂度：O((n^2))"></a>空间复杂度：O((n^2))</h3><p>我们需要大小为 O((n^2)) 的 dp 数组来记录状态值。</p><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><p>这道题和<font color="blue">最长公共子序列</font>以及<font color="blue">编辑距离</font>套用的都是二维的dp数组模版，但是不同之处在于这里只涉及一个字符串/子序列，所以属于二维dp数组的另一种小类。</p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Go 源码解析5】函数调用</title>
      <link href="/2021/01/18/go-sourcecode-functioncall/"/>
      <url>/2021/01/18/go-sourcecode-functioncall/</url>
      
        <content type="html"><![CDATA[<blockquote><p>函数是 Go 语言的一等公民，掌握和理解函数的调用过程是我们深入学习 Go 无法跳过的，本节将从函数的调用惯例和参数传递方法两个方面分别介绍函数的执行过程。</p></blockquote><p><img src="http://vegard-bear.github.io/images/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8.png" alt></p><blockquote><p>点击图片查看高清大图</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> 源码解析 </tag>
            
            <tag> 函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【leetcode-72】编辑距离</title>
      <link href="/2021/01/17/leetcode-72/"/>
      <url>/2021/01/17/leetcode-72/</url>
      
        <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/edit-distance/" target="_blank" rel="noopener">72. 编辑距离</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。</p><p>你可以对一个单词进行如下三种操作：</p><ul><li>插入一个字符</li><li>删除一个字符</li><li>替换一个字符</li></ul><p>示例 1：</p><pre><code>输入：word1 = &quot;horse&quot;, word2 = &quot;ros&quot;输出：3解释：horse -&gt; rorse (将 &#39;h&#39; 替换为 &#39;r&#39;)rorse -&gt; rose (删除 &#39;r&#39;)rose -&gt; ros (删除 &#39;e&#39;)</code></pre><p>示例 2：</p><pre><code>输入：word1 = &quot;intention&quot;, word2 = &quot;execution&quot;输出：5解释：intention -&gt; inention (删除 &#39;t&#39;)inention -&gt; enention (将 &#39;i&#39; 替换为 &#39;e&#39;)enention -&gt; exention (将 &#39;n&#39; 替换为 &#39;x&#39;)exention -&gt; exection (将 &#39;n&#39; 替换为 &#39;c&#39;)exection -&gt; execution (插入 &#39;u&#39;)</code></pre><p>提示：</p><ul><li>0 &lt;= word1.length, word2.length &lt;= 500</li><li>word1 和 word2 由小写英文字母组成</li></ul><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>这道题和【leetcode 1143动态规划子序列】一样也是一道二维的动态规划算法题。解体套路也是非常的相似。</p><h2 id="动态规划三步走"><a href="#动态规划三步走" class="headerlink" title="动态规划三步走"></a>动态规划三步走</h2><h4 id="定义dp数组"><a href="#定义dp数组" class="headerlink" title="定义dp数组"></a>定义dp数组</h4><p>注意这里由于有两个字符串，所以我们需要定义一个二维的dp数组。</p><h5 id="dp-i-j-表示对于-world1-1-i-和-world2-1-j-，它们的编辑距离度是-dp-i-j"><a href="#dp-i-j-表示对于-world1-1-i-和-world2-1-j-，它们的编辑距离度是-dp-i-j" class="headerlink" title="dp[i][j] 表示对于 world1[1..i] 和 world2[1..j]，它们的编辑距离度是 dp[i][j]"></a><center><font color="red">dp[i][j] 表示对于 world1[1..i] 和 world2[1..j]，它们的编辑距离度是 dp[i][j]</font></center></h5><h4 id="确定-base-case"><a href="#确定-base-case" class="headerlink" title="确定 base case"></a>确定 base case</h4><p>根据dp数组的定义。我们就可以确定 base case，即</p><h5 id="dp-i-0-i-dp-0-j-j"><a href="#dp-i-0-i-dp-0-j-j" class="headerlink" title="dp[i][0] = i, dp[0][j] = j"></a><center><font color="red">dp[i][0] = i, dp[0][j] = j</font></center></h5><p>因为只要有一个字符串是空串，此时编辑距离就是另一个字符串的长度。</p><h4 id="推导状态转移方程"><a href="#推导状态转移方程" class="headerlink" title="推导状态转移方程"></a>推导状态转移方程</h4><p>依旧是采用数学归纳法来寻找状态转移关系：假设我们已经计算出了dp[i-1][j-1]，dp[i-1][j]以及dp[i][j-1],如何推导出dp[i][j]呢？</p><p><font color="blue">如题意，我们很快可以知道dp[i][j]有三种选择，分别是插入、删除和替换一个字符，而实际上这里还隐含了一种选择，就是什么也不做，也就是dp[i]==dp[j]的时候。</font>。<br><big></big></p><pre><code>             dp[i-1][j-1],            当s[i]==s[j]时dp[i][j] =              min(dp[i][j-1]+1, dp[i-1][j]+1, dp[i-1][j-1])+1) 当s[i]!=s[j]时</code></pre>至此，我们列出状态转移方程，就可以直接写代码了。<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code>func minDistance(word1 string, word2 string) int {    // 定义 dp 数组, dp[i][j] 表示world1[i]和word2[j]的编辑距离    l1, l2 := len(word1), len(word2)    // 注意这里dp数组的二维长度都需要+1，    // 因为要把第一列空出来用来表示其中一个字符串为空的这种情况    dp := make([][]int, l1 + 1)    for k := range dp {        dp[k] = make([]int, l2 + 1)    }    // 定义 base case, dp[i][0]表示当word2为空字符串，此时编辑距离就是word1的长度    for i := 0; i &lt;= l1 ; i++ {        dp[i][0] = i    }    for j := 0 ; j &lt;= l2 ; j++ {        dp[0][j] = j    }    // 列出状态转移方程    for i := 1; i &lt;= l1 ; i ++ {        for j := 1 ; j &lt;= l2 ; j++ {            // 当两个字符串的字符相等时，直接跳过这个字符，相当于什么都不做            if word1[i-1] == word2[j-1] {                dp[i][j] = dp[i-1][j-1]            } else {                // 当两个字符不相等时，那么就对s[i]执行插入、删除或替换的操作，取其中代价最小的操作                dp[i][j] = min(dp[i][j-1] + 1, min(dp[i-1][j] + 1, dp[i-1][j-1] + 1))            }        }    }    return dp[l1][l2]}func min(a, b int) int  {    if a &lt; b {        return a    }    return b}</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="时间复杂度：O-mn"><a href="#时间复杂度：O-mn" class="headerlink" title="时间复杂度：O((mn))"></a>时间复杂度：O((mn))</h3><p>其中 m 为 word1 的长度，n 为 word2 的长度</p><h3 id="空间复杂度：O-mn"><a href="#空间复杂度：O-mn" class="headerlink" title="空间复杂度：O((mn))"></a>空间复杂度：O((mn))</h3><p>我们需要大小为 O((mn)) 的 dp 数组来记录状态值。</p><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><p>此题和【1143. 最长公共子序列】解法非常相似，都是属于二维的动态规划算法题，套用的是同一个模版。</p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【leetcode-1143】最长公共子序列</title>
      <link href="/2021/01/16/leetcode-1143/"/>
      <url>/2021/01/16/leetcode-1143/</url>
      
        <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/longest-common-subsequence/" target="_blank" rel="noopener">1143. 最长公共子序列</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。</p><p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p><p>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。</p><p>若这两个字符串没有公共子序列，则返回 0。</p><p>示例 1:</p><pre><code>输入：text1 = &quot;abcde&quot;, text2 = &quot;ace&quot; 输出：3  解释：最长公共子序列是 &quot;ace&quot;，它的长度为 3。</code></pre><p>示例 2:</p><pre><code>输入：text1 = &quot;abc&quot;, text2 = &quot;abc&quot;输出：3解释：最长公共子序列是 &quot;abc&quot;，它的长度为 3。</code></pre><p>示例 3:</p><pre><code>输入：text1 = &quot;abc&quot;, text2 = &quot;def&quot;输出：0解释：两个字符串没有公共子序列，返回 0。</code></pre><p>提示:</p><ul><li>1 &lt;= text1.length &lt;= 1000</li><li>1 &lt;= text2.length &lt;= 1000</li><li>输入的字符串只含有小写英文字符。</li></ul><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><blockquote><p>详细题解参考 <a href="https://leetcode-cn.com/problems/longest-common-subsequence/solution/dong-tai-gui-hua-zhi-zui-chang-gong-gong-zi-xu-lie/" target="_blank" rel="noopener">动态规划之最长公共子序列（LCS）</a></p></blockquote><p>这是一道非常经典的面试题，因为它采用的解法是典型的二维动态规划。</p><p>对于子序列问题，穷举出所有可能的结果都不容易，而动态规划算法要做的就是穷举+剪枝，所以说只要涉及子序列的问题，十有八九都是用动态规划来解决。</p><p>而对于两个字符串的动态规划问题，套路是通用的，就是需要一个二维数组。</p><h2 id="动态规划三步走"><a href="#动态规划三步走" class="headerlink" title="动态规划三步走"></a>动态规划三步走</h2><h4 id="定义dp数组"><a href="#定义dp数组" class="headerlink" title="定义dp数组"></a>定义dp数组</h4><p>注意这里由于有两个字符串，所以我们需要定义一个二维的dp数组。</p><h5 id="dp-i-j-表示对于-s1-1-i-和-s2-1-j-，它们的最长公共子序列-LCS-长度是-dp-i-j"><a href="#dp-i-j-表示对于-s1-1-i-和-s2-1-j-，它们的最长公共子序列-LCS-长度是-dp-i-j" class="headerlink" title="dp[i][j] 表示对于 s1[1..i] 和 s2[1..j]，它们的最长公共子序列((LCS))长度是 dp[i][j]"></a><center><font color="red">dp[i][j] 表示对于 s1[1..i] 和 s2[1..j]，它们的最长公共子序列((LCS))长度是 dp[i][j]</font></center></h5><h4 id="确定-base-case"><a href="#确定-base-case" class="headerlink" title="确定 base case"></a>确定 base case</h4><p>根据dp数组的定义。我们就可以确定 base case，即</p><h5 id="dp-i-0-dp-0-j-0"><a href="#dp-i-0-dp-0-j-0" class="headerlink" title="dp[i][0], dp[0][j] = 0"></a><center><font color="red">dp[i][0], dp[0][j] = 0</font></center></h5><p>因为只要有一个字符串是空串，它们的最长公共子序列的长度显然应该是 0。</p><h4 id="推导状态转移方程"><a href="#推导状态转移方程" class="headerlink" title="推导状态转移方程"></a>推导状态转移方程</h4><p>依旧是采用数学归纳法来寻找状态转移关系：假设我们已经计算出了dp[i-1][j-1]，dp[i-1][j]以及dp[i][j-1],如何推导出dp[i][j]呢？</p><p><font color="blue">dp[i][j]其实只有两种选择，要么就是与前面的子序列连接，形成一个更长的公共子序列，要么不与前面的子序列连接，原来的最长子序列保持不变。而做出这个选择的关键就在于s[i]是否等于s[j]</font>。<br><big></big></p><pre><code>             dp[i-1][j-1] + 1,            当s[i]==s[j]时dp[i][j] =              max(dp[i][j-1], dp[i-1][j]), 当s[i]!=s[j]时</code></pre>至此，我们列出状态转移方程，就可以直接写代码了。<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code>func longestCommonSubsequence(text1 string, text2 string) int {    // 定义 dp 数组    l1, l2 := len(text1), len(text2)    // 这里是一个二维数组, 注意二维数组的长度是字符串长度+1    dp := make([][]int, l1+1)    for k := range dp {        dp[k] = make([]int, l2+1)    }    // 开始遍历，注意下标从1开始    for i := 1; i &lt;= l1 ; i++ {        for j := 1; j &lt;= l2 ; j++ {            // 如果s[i]等于s[j]，说明此时s[i]和s[j]属于公共子序列，公共子序列+1            if text1[i-1] == text2[j-1] {                dp[i][j] = dp[i-1][j-1] +1            } else {                // 如果s[i]不等于s[j]，说明s[i]和s[j]至少有一个不属于公共子序列，子序列长度不变                dp[i][j] = max(dp[i-1][j], dp[i][j-1])            }        }    }    return dp[l1][l2]}func max(a, b int) int {    if a &gt; b {        return a    }    return b}</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="时间复杂度：O-n-2"><a href="#时间复杂度：O-n-2" class="headerlink" title="时间复杂度：O((n^2))"></a>时间复杂度：O((n^2))</h3><p>需要两层循环遍历两个字符串。</p><h3 id="空间复杂度：O-n-2"><a href="#空间复杂度：O-n-2" class="headerlink" title="空间复杂度：O((n^2))"></a>空间复杂度：O((n^2))</h3><p>需要定义一个二维的dp数组。</p><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><p>最长公共子序列是一道非常经典的面试题目，因为它的解法是典型的二维动态规划，大部分比较困难的字符串问题都和这个问题一个套路，比如说编辑距离。而且，这个算法稍加改造就可以用于解决其他问题，所以说 LCS 算法是值得掌握的。</p><blockquote><p>所谓二维无非就是比一维多了一维，我们只需要在定义dp数组，base case以及推导状态转移方程上多一个维度的思考就行了</p></blockquote><h3 id="需要尤其注意的是二维数组开辟的大小比两个字符串的大小要-1。这是因为需要专门让索引为-0-的行和列表示空串，dp-0-和-dp-0-都应该初始化为-0，相当于-base-case。"><a href="#需要尤其注意的是二维数组开辟的大小比两个字符串的大小要-1。这是因为需要专门让索引为-0-的行和列表示空串，dp-0-和-dp-0-都应该初始化为-0，相当于-base-case。" class="headerlink" title="需要尤其注意的是二维数组开辟的大小比两个字符串的大小要+1。这是因为需要专门让索引为 0 的行和列表示空串，dp[0][..] 和 dp[..][0] 都应该初始化为 0，相当于 base case。"></a>需要尤其注意的是二维数组开辟的大小比两个字符串的大小要+1。这是因为需要专门让索引为 0 的行和列表示空串，dp[0][..] 和 dp[..][0] 都应该初始化为 0，相当于 base case。</h3>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【leetcode-53】最大子序和</title>
      <link href="/2021/01/11/leetcode-53/"/>
      <url>/2021/01/11/leetcode-53/</url>
      
        <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">53. 最大子序和</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>示例:</p><pre><code>输入: [-2,1,-3,4,-1,2,1,-5,4]输出: 6解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</code></pre><ul><li>进阶:</li></ul><p>如果你已经实现复杂度为 O((n)) 的解法，尝试使用更为精妙的分治法求解。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>这道题与 <a href="https://vegard-bear.github.io/2021/01/08/leetcode-300/">最长递增子序列</a> 非常相似，这里我们依旧是采用动态规划算法解决。</p><h4 id="定义dp数组"><a href="#定义dp数组" class="headerlink" title="定义dp数组"></a>定义dp数组</h4><h5 id="dp-i-表示以-nums-i-结尾的最大子数组和"><a href="#dp-i-表示以-nums-i-结尾的最大子数组和" class="headerlink" title="dp[i] 表示以 nums[i] 结尾的最大子数组和"></a><center><font color="blue">dp[i] 表示以 nums[i] 结尾的最大子数组和</font></center></h5><h4 id="确定-base-case"><a href="#确定-base-case" class="headerlink" title="确定 base case"></a>确定 base case</h4><p>那么根据这个定义。我们就可以确定 base case，就是</p><h5 id="dp-i-0"><a href="#dp-i-0" class="headerlink" title="dp[i] = 0"></a><center><font color="blue">dp[i] = 0</font></center></h5><p>因为在初始状态下，以nums[i]结尾的最大子数组和就是其自身。<br>然后就可以列我们的状态转移方程了。</p><h4 id="推导状态转移方程"><a href="#推导状态转移方程" class="headerlink" title="推导状态转移方程"></a>推导状态转移方程</h4><p>依旧是采用数学归纳法来寻找状态转移关系：假设我们已经计算出了dp[i-1]，如何推导出dp[i]呢？</p><p>dp[i]其实只有两种选择，要么就是与前面的相邻子数组连接，形成一个更大的子数组，要么不与前面的子数组比较，自成一派，自己作为一个子数组。</p><p>而对于这两种情况，我们只需要其中和最大的那一个，也就是：</p><h4 id="dp-i-max-dp-i-dp-i-1-nums-i"><a href="#dp-i-max-dp-i-dp-i-1-nums-i" class="headerlink" title=" dp[i] = max (( dp[i] , dp[i-1] + nums[i] ))  "></a><center><font color="blue"> dp[i] = max (( dp[i] , dp[i-1] + nums[i] ))  </font></center></h4><p>至此，我们列出状态转移方程，就可以直接写代码了。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code>func maxSubArray(nums []int) int {    // 定义dp动态数组, dp表示以nums[i]结尾的最大子数组和    dp := make([]int, len(nums))    // 定义base case, 第一个数前面没有数，所以    // 以第一个数结尾的最大子数组和就是其本身    dp[0] = nums[0]    // 开始计算dp数组    for i := 1; i &lt; len(nums); i++{        // 列出状态转移方程        // 以nums[i]结尾的最大数组和 要么是其自身nums[i]，        // 要么是自身nums[i]加上以前一个数nums[i-1]结尾的最大子数组拼上当前数而成的数组和        dp[i] = max(nums[i], dp[i-1] + nums[i])    }     // res用于返回最后结果    res := math.MinInt32    // 遍历dp数组，找到最大的那一个就是答案    for i := 0; i &lt; len(dp); i++ {        res = max(res, dp[i])    }    return res}func max(a, b int) int {    if a &gt; b {        return a    }    return b}</code></pre><p>不难发现，以上解法的时间复杂度和空间复杂度都是O((n)), 考虑到 <font color="red">dp[i]仅仅和dp[i-1]有关，那么就可以进行状态压缩，进一步降低空间复杂度</font></p><pre><code>func maxSubArray(nums []int) int {    // 定义base case，注意这里只定义了dp_0，而不是整个dp数组    dp_0 := nums[0]    res := dp_0    // 开始计算dp数组    for i := 1; i &lt; len(nums); i++ {        // 列出状态转移方程        dp_1 := max(nums[i], dp_0 + nums[i])        // 注意这里需要更新前一个状态        dp_0 = dp_1        // 直接计算当前最大和        res = max(res, dp_1)    }    return res}func max(a, b int) int {    if a &gt; b {        return a    }    return b}</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="时间复杂度：O-n"><a href="#时间复杂度：O-n" class="headerlink" title="时间复杂度：O((n))"></a>时间复杂度：O((n))</h3><p>其中 n 为数组 nums 的长度。</p><h3 id="空间复杂度：O-C"><a href="#空间复杂度：O-C" class="headerlink" title="空间复杂度：O((C))"></a>空间复杂度：O((C))</h3><p>不再需要额外定义一个dp数组了，只需要dp_0和dp_1两个变量，所以此算法的空间复杂度为常数。</p><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><p>动态规划算法可通过状态压缩进一步降低空间复杂度。</p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【leetcode-354】俄罗斯套娃信封问题</title>
      <link href="/2021/01/10/leetcode-354/"/>
      <url>/2021/01/10/leetcode-354/</url>
      
        <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/russian-doll-envelopes/" target="_blank" rel="noopener">354. 俄罗斯套娃信封问题</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一些标记了宽度和高度的信封，宽度和高度以整数对形式 ((w, h)) 出现。当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。</p><p>请计算最多能有多少个信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。</p><p>说明:<br>不允许旋转信封。</p><p>示例:</p><pre><code>输入: envelopes = [[5,4],[6,4],[6,7],[2,3]]输出: 3 解释: 最多信封的个数为 3, 组合为: [2,3] =&gt; [5,4] =&gt; [6,7]。</code></pre><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>这道题与最长递增子序列非常相似，只不过从一维变成了二维，也是采用动态规划的思路，废话不多说，直接上题解。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h3 id="题解一"><a href="#题解一" class="headerlink" title="题解一"></a>题解一</h3><pre><code>func maxEnvelopes(envelopes [][]int) int {    // 先对所有信封按照宽度从小到大进行排序    sort.Slice(envelopes, func(i, j int) bool {        return envelopes[i][0] &lt; envelopes[j][0]    })    // 定义dp数组，dp[i]表示前i+1个信封中能组成的俄罗斯套娃最大个数    dp := make([]int, len(envelopes))    // 定义base case，初始状态为1    for i := 0; i &lt; len(dp); i++ {        dp[i] = 1    }    // 推导状态转移方程    for i := 0; i &lt; len(envelopes); i++ {        // 遍历高度        for j := 0; j &lt; i; j++ {            // 因为宽度已经是递增的，那么只要保证高度也是递增的就可以            // 注意需要把宽度相等的剔除掉            if envelopes[j][1] &lt; envelopes[i][1] &amp;&amp; envelopes[j][0] &lt; envelopes[i][0] {                // 选择或者不选，留下最大值                dp[i] = max(dp[j] + 1, dp[i])            }        }    }    max := 0    for i := 0; i &lt; len(dp); i++ {        if max &lt; dp[i] {            max = dp[i]        }    }    // 最后返回结果    return max}</code></pre><h3 id="题解二"><a href="#题解二" class="headerlink" title="题解二"></a>题解二</h3><pre><code>func maxEnvelopes(envelopes [][]int) int {    n := len(envelopes)    sort.Slice(envelopes, func(i, j int) bool {        // 按宽短升序排列，如果宽度一样，则按高度降序排列        if envelopes[i][0] == envelopes[j][0] {            return envelopes[i][1] &gt; envelopes[j][1]        } else {            return envelopes[i][0] &lt; envelopes[j][0]        }    })    // 对排好序的数组取其中高度组成的数组调用最长递增子序列    height := make([]int, n)    for i := 0 ; i &lt; n ; i++ {        height[i] = envelopes[i][1]    }    return lengthOfLIS(height)}func lengthOfLIS(nums []int) int {    // 定义一个dp数组    // dp[i]表示以第i+1个元素结尾的字符串最长子递增子序列    dp := make([]int, len(nums))    // 初始化数组，初始最长递增子序列为1    for k := range dp {        dp[k] = 1    }    // 遍历数组，依次计算以每个数为结尾的最长子序列    for i := 0; i &lt; len(nums) ; i++ {        // 遍历之前已经计算完成的子序列        for j := 0; j &lt; i ; j++ {            // 核心代码，状态转移方程            // 以当前数字结尾的最长子序列长度等于【之前比他小的数字的结尾的最长子序列长度+1】            if nums[j] &lt; nums[i] {                dp[i] = max(dp[i], dp[j] + 1)            }        }    }    // 最后遍历一遍dp数组，留下最大值    maxLen := 0    for k := range dp {        if maxLen &lt; dp[k] {            maxLen = dp[k]        }    }    return maxLen}func max(a, b int) int {    if a &gt; b {        return a    }    return b}</code></pre><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><h3 id="时间复杂度：O-n-2"><a href="#时间复杂度：O-n-2" class="headerlink" title="时间复杂度：O((n^2))"></a>时间复杂度：O((n^2))</h3><p>其中 n 为数组 nums 的长度。排序和 LIS 算法都是 O((NlogN))</p><h3 id="空间复杂度：O-n"><a href="#空间复杂度：O-n" class="headerlink" title="空间复杂度：O((n))"></a>空间复杂度：O((n))</h3><p>需要额外使用长度为 n 的 dp 数组。另外，我们使用的排序算法也可能需要额外的空间。</p><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><ul><li><p>动态规划的题最重要的是如何定义dp数组，确定base case以及状态转移方程。</p></li><li><p>特别注意最后需要遍历一遍dp数组，其中的最大值才是我们想要的，而不是直接返回dp[end]</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【leetcode-300】最长递增子序列</title>
      <link href="/2021/01/08/leetcode-300/"/>
      <url>/2021/01/08/leetcode-300/</url>
      
        <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">300. 最长递增子序列</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p><p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p><p>示例 1：</p><pre><code>输入：nums = [10,9,2,5,3,7,101,18]输出：4解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</code></pre><p>示例 2：</p><pre><code>输入：nums = [0,1,0,3,2,3]输出：4</code></pre><p>示例 3：</p><pre><code>输入：nums = [7,7,7,7,7,7,7]输出：1</code></pre><p>提示：</p><ul><li>1 &lt;= nums.length &lt;= 2500</li><li>-104 &lt;= nums[i] &lt;= 104</li></ul><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>这道题是一道非常经典的动态规划算法题，而对于动态规划算法，最重要的就是列出状态转移方程。这里我们先要定义一个dp数组，这个dp数组的含义非常重要。</p><h5 id="dp-i-表示以-nums-i-结尾的最长递增子序列的长度"><a href="#dp-i-表示以-nums-i-结尾的最长递增子序列的长度" class="headerlink" title="dp[i] 表示以 nums[i] 结尾的最长递增子序列的长度"></a><center><font color="blue">dp[i] 表示以 nums[i] 结尾的最长递增子序列的长度</font></center></h5><p>那么根据这个定义。我们可以先确定 base case，就是</p><h5 id="dp-i-1"><a href="#dp-i-1" class="headerlink" title="dp[i] = 1"></a><center><font color="blue">dp[i] = 1</font></center></h5><p>因为在初始状态下，以nums[i]结尾的最长递增子序列至少存在一个包含自身的子序列。<br>然后就可以列我们的状态转移方程了。</p><blockquote><p>注意：“子序列”和“子串”这两个名词的区别，子串一定是连续的，而子序列不一定是连续的。</p></blockquote><p>现在假设我们要求dp[5]，也就是以第6个数字结尾的字符串的最长递增子序列。那么我们只需要遍历以它前面数字结尾的所有最长子序列，找到那个结尾数字小于当前数字的子序列，然后长度+1即可。即遍历 dp[0] 到 dp[4]，如果nums[j] &lt; nums[5]，那么就可以更新 dp[5] = dp[j] + 1，当然，最后需要保留大的那个数字作为dp[5]的最终值。</p><h4 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h4><h4 id="dp-i-max-dp-i-dp-j-1-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-当-j-lt-i-时"><a href="#dp-i-max-dp-i-dp-j-1-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-nbsp-当-j-lt-i-时" class="headerlink" title=" dp[i] = max ( dp[i] , dp[j] + 1 )  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  当 j &lt; i 时 "></a><center><font color="blue"> dp[i] = max ( dp[i] , dp[j] + 1 )  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  当 j &lt; i 时 </font></center></h4><p>代码如下：</p><pre><code>for j := 0; j &lt; i ; j++ {    // 核心代码，状态转移方程    // 以当前数字结尾的最长子序列长度等于【之前比他小的数字的结尾的最长子序列长度+1】    if nums[j] &lt; nums[i] {        dp[i] = max(dp[i], dp[j] + 1)    }}</code></pre><p>既然得到了dp[5]，那么dp[i]都能求出来，只需要依次遍历一遍即可，最终代码如下。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code>func lengthOfLIS(nums []int) int {    // 定义一个dp数组    // dp[i]表示以第i+1个元素结尾的字符串最长子递增子序列    dp := make([]int, len(nums))    // 初始化数组，初始最长递增子序列为1    for k := range dp {        dp[k] = 1    }    // 遍历数组，依次计算以每个数为结尾的最长子序列    for i := 0; i &lt; len(nums) ; i++ {        // 遍历之前已经计算完成的子序列        for j := 0; j &lt; i ; j++ {            // 核心代码，状态转移方程            // 以当前数字结尾的最长子序列长度等于【之前比他小的数字的结尾的最长子序列长度+1】            if nums[j] &lt; nums[i] {                dp[i] = max(dp[i], dp[j] + 1)            }        }    }    // 最后遍历一遍dp数组，留下最大值    maxLen := 0    for k := range dp {        if maxLen &lt; dp[k] {            maxLen = dp[k]        }    }    return maxLen}func max(a, b int) int {    if a &gt; b {        return a    }    return b}</code></pre><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><h3 id="时间复杂度：O-n-2"><a href="#时间复杂度：O-n-2" class="headerlink" title="时间复杂度：O((n^2))"></a>时间复杂度：O((n^2))</h3><p>其中 n 为数组 nums 的长度。动态规划的状态数为 n，计算状态 dp[i] 时，需要 O(n) 的时间遍历 dp[0…i−1] 的所有状态，所以总时间复杂度为 O(n^2)</p><h3 id="空间复杂度：O-n"><a href="#空间复杂度：O-n" class="headerlink" title="空间复杂度：O((n))"></a>空间复杂度：O((n))</h3><p>需要额外使用长度为 n 的 dp 数组。</p><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><p>动态规划的题最重要的是如何定义dp数组，确定base case以及状态转移方程。</p><h3 id="注意，以nums最后一个数字结尾的子序列并不一定是最大的，这是一个坑，需要重新遍历一遍dp数组，找到最大的那个值"><a href="#注意，以nums最后一个数字结尾的子序列并不一定是最大的，这是一个坑，需要重新遍历一遍dp数组，找到最大的那个值" class="headerlink" title="注意，以nums最后一个数字结尾的子序列并不一定是最大的，这是一个坑，需要重新遍历一遍dp数组，找到最大的那个值"></a>注意，以nums最后一个数字结尾的子序列并不一定是最大的，这是一个坑，需要重新遍历一遍dp数组，找到最大的那个值</h3>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Go源码解析4】字符串</title>
      <link href="/2021/01/07/go-sourcecode-string/"/>
      <url>/2021/01/07/go-sourcecode-string/</url>
      
        <content type="html"><![CDATA[<blockquote><p>字符串是 Go 语言中的基础数据类型，虽然字符串往往被看做一个整体，但是它实际上是一片连续的内存空间，我们也可以将它理解成一个由字符组成的数组，本节会详细介绍字符串的实现原理、转换过程以及常见操作的实现。</p></blockquote><p><img src="https://vegard-bear.github.io/images/%E5%AD%97%E7%AC%A6%E4%B8%B2.png" alt></p><blockquote><p>点击图片查看高清大图</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> 源码解析 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Go源码解析3】哈希表</title>
      <link href="/2021/01/07/go-sourcecode-map/"/>
      <url>/2021/01/07/go-sourcecode-map/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本节会介绍 Go 语言的哈希的实现原理，哈希是除了数组之外，最常见的数据结构。几乎所有的语言都会有数组和哈希表两种集合元素，有的语言将数组实现成列表，而有的语言将哈希称作字典或者映射。无论如何命名或者如何实现，数组和哈希是两种设计集合元素的思路，数组用于表示元素的序列，而哈希表示的是键值对之间映射关系。</p></blockquote><p><img src="https://vegard-bear.github.io/images/%E5%93%88%E5%B8%8C%E8%A1%A8.png" alt></p><blockquote><p>点击图片查看高清大图</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> 源码解析 </tag>
            
            <tag> map </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Go源码解析2】切片</title>
      <link href="/2021/01/06/go-sourcecode-slice/"/>
      <url>/2021/01/06/go-sourcecode-slice/</url>
      
        <content type="html"><![CDATA[<p>上一节介绍的数组在 Go 语言中没那么常用，更常用的数据结构是切片，即动态数组，其长度并不固定，我们可以向切片中追加元素，它会在容量不足时自动扩容。</p><p>这一节我们就来看看Go语言中切片的底层实现逻辑。</p><p><img src="https://vegard-bear.github.io/images/%E5%88%87%E7%89%87%E5%AE%9E%E7%8E%B0.png" alt></p><blockquote><p>点击图片查看高清大图</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> 源码解析 </tag>
            
            <tag> 切片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Go源码解析1】数组</title>
      <link href="/2021/01/04/go-sourcecode-array/"/>
      <url>/2021/01/04/go-sourcecode-array/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>数组是由相同类型元素的集合组成的数据结构，<font color="blue">计算机会为数组分配一块连续的内存来保存其中的元素</font>，我们可以利用数组中元素的索引快速访问特定元素。</p><p>在Go语言中我们常常采用如下的方式定义数组：</p><pre><code>[10]int[200]interface{}</code></pre><p>Go 语言数组在初始化之后大小就无法改变，<font color="red">存储元素类型相同、但是大小不同的数组类型在 Go 语言看来也是完全不同的，只有两个条件都相同才是同一类型</font>。</p><pre><code>func NewArray(elem *Type, bound int64) *Type {    if bound &lt; 0 {        Fatalf(&quot;NewArray: invalid bound %v&quot;, bound)    }    t := New(TARRAY)    t.Extra = &amp;Array{Elem: elem, Bound: bound}    t.SetNotInHeap(elem.NotInHeap())    return t}</code></pre><p>编译期间的数组类型是由上述的 cmd/compile/internal/types.NewArray 函数生成的，该类型包含两个字段，分别是<font color="red">元素类型 Elem 和数组的大小 Bound，这两个字段共同构成了数组类型</font>，而当前数组是否应该在堆栈中初始化也在编译期就确定了。</p><h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><p>Go 语言的数组有两种不同的创建方式</p><ul><li>显式的指定数组大小</li><li>使用 […]T 声明数组，Go 语言会在编译期间通过源代码推导数组的大小</li></ul><pre><code>arr1 := [3]int{1, 2, 3}arr2 := [...]int{1, 2, 3}</code></pre><p>上述两种声明方式在运行期间得到的结果是完全相同的，后一种声明方式在编译期间就会被转换成前一种，这也就是编译器对数组大小的推导</p><h2 id="上限推导"><a href="#上限推导" class="headerlink" title="上限推导"></a>上限推导</h2><p>两种不同的声明方式会导致编译器做出完全不同的处理，如果我们使用第一种方式 [10]T，那么<font color="red">变量的类型在编译进行到类型检查阶段就会被提取出来</font>，随后使用 cmd/compile/internal/types.NewArray创建包含数组大小的 cmd/compile/internal/types.Array 结构体。</p><p>当我们使用 […]T 的方式声明数组时，编译器会在 cmd/compile/internal/gc.typecheckcomplit 函数中<font color="red">对该数组的大小进行推导</font>：</p><pre><code>func typecheckcomplit(n *Node) (res *Node) {    ...    if n.Right.Op == OTARRAY &amp;&amp; n.Right.Left != nil &amp;&amp; n.Right.Left.Op == ODDD {        n.Right.Right = typecheck(n.Right.Right, ctxType)        if n.Right.Right.Type == nil {            n.Type = nil            return n        }        elemType := n.Right.Right.Type        // 通过遍历元素的方式来计算数组中元素的数量        length := typecheckarraylit(elemType, -1, n.List.Slice(), &quot;array literal&quot;)        n.Op = OARRAYLIT        n.Type = types.NewArray(elemType, length)        n.Right = nil        return n    }    ...    switch t.Etype {    case TARRAY:        typecheckarraylit(t.Elem(), t.NumElem(), n.List.Slice(), &quot;array literal&quot;)        n.Op = OARRAYLIT        n.Right = nil    }}</code></pre><p>所以我们可以看出 […]T{1, 2, 3} 和 [3]T{1, 2, 3} 在运行时是完全等价的，[…]T 这种初始化方式也只是 Go 语言为我们提供的一种语法糖，当我们不想计算数组中的元素个数时可以通过这种方法减少一些工作量。</p><h2 id="语句转换"><a href="#语句转换" class="headerlink" title="语句转换"></a>语句转换</h2><p>对于一个由字面量组成的数组，根据数组元素数量的不同，编译器会在负责初始化字面量的 cmd/compile/internal/gc.anylit 函数中做两种不同的优化：</p><ul><li><font color="red">当元素数量小于或者等于 4 个时，会直接将数组中的元素放置在栈上；</font></li><li>当元素数量大于 4 个时，会将数组中的元素放置到静态区并在运行时取出；</li></ul><pre><code>func anylit(n *Node, var_ *Node, init *Nodes) {    t := n.Type    switch n.Op {    case OSTRUCTLIT, OARRAYLIT:        if n.List.Len() &gt; 4 {            ...        }        // 注意这里传入的是 initKindLocalCode        fixedlit(inInitFunction, initKindLocalCode, n, var_, init)    ...    }}</code></pre><p>当数组的元素小于或者等于四个时，cmd/compile/internal/gc.fixedlit 会负责在函数编译之前将 [3]{1, 2, 3} 转换成更加原始的语句：</p><pre><code>func fixedlit(ctxt initContext, kind initKind, n *Node, var_ *Node, init *Nodes) {    var splitnode func(*Node) (a *Node, value *Node)    ...    for _, r := range n.List.Slice() {        a, value := splitnode(r)        a = nod(OAS, a, value)        a = typecheck(a, ctxStmt)        switch kind {        case initKindStatic:            genAsStatic(a)            // 元素个数小于等于4时走的是这个分支        case initKindLocalCode:            a = orderStmtInPlace(a, map[string][]*Node{})            a = walkstmt(a)            init.Append(a)        }    }}</code></pre><p>当数组中元素的个数小于或者等于四个并且 cmd/compile/internal/gc.fixedlit 函数接收的 kind 是 initKindLocalCode 时，上述代码会将原有的初始化语句 [3]int{1, 2, 3} 拆分成一个声明变量的表达式和几个赋值表达式，这些表达式会完成对数组的初始化：</p><pre><code>var arr [3]intarr[0] = 1arr[1] = 2arr[2] = 3</code></pre><p>但是如果当前数组的元素大于四个，cmd/compile/internal/gc.anylit 会先获取一个唯一的 staticname，然后调用 cmd/compile/internal/gc.fixedlit 函数在静态存储区初始化数组中的元素并将临时变量赋值给数组：</p><pre><code>func anylit(n *Node, var_ *Node, init *Nodes) {    t := n.Type    switch n.Op {    case OSTRUCTLIT, OARRAYLIT:        if n.List.Len() &gt; 4 {            // 这里先获取一个staticname            vstat := staticname(t)            vstat.Name.SetReadonly(true)            // 然后再调用fixedlit完成语句转化，注意这里传入的是initKindStatic            fixedlit(inNonInitFunction, initKindStatic, n, vstat, init)            a := nod(OAS, var_, vstat)            a = typecheck(a, ctxStmt)            a = walkexpr(a, init)            init.Append(a)            break        }        ...    }}</code></pre><p>假设代码需要初始化 [5]int{1, 2, 3, 4, 5}，那么我们可以将上述过程理解成以下的伪代码：</p><pre><code>var arr [5]intstatictmp_0[0] = 1statictmp_0[1] = 2statictmp_0[2] = 3statictmp_0[3] = 4statictmp_0[4] = 5arr = statictmp_0</code></pre><p>总结起来，在不考虑逃逸分析的情况下，<font color="red">如果数组中元素的个数小于或者等于 4 个，那么所有的变量会直接在栈上初始化，如果数组元素大于 4 个，变量就会在静态存储区初始化然后拷贝到栈上</font>，这些转换后的代码才会继续进入中间代码生成和机器码生成两个阶段，最后生成可以执行的二进制文件。</p><h1 id="访问和赋值"><a href="#访问和赋值" class="headerlink" title="访问和赋值"></a>访问和赋值</h1><p>无论是在栈上还是静态存储区，数组在内存中都是一连串的内存空间，我们<font color="blue">通过指向数组开头的指针、元素的数量以及元素类型占的空间大小表示数组。如果我们不知道数组中元素的数量，访问时可能发生越界；而如果不知道数组中元素类型的大小，就没有办法知道应该一次取出多少字节的数据</font>，无论丢失了那个信息，我们都无法知道这片连续的内存空间到底存储了什么数据：</p><p>数组访问越界是非常严重的错误，Go 语言中可以<font color="blue">在编译期间的静态类型检查判断数组越界</font>，cmd/compile/internal/gc.typecheck1 会验证访问数组的索引：</p><pre><code>func typecheck1(n *Node, top int) (res *Node) {    switch n.Op {    case OINDEX:        ok |= ctxExpr        l := n.Left  // array        r := n.Right // index        switch n.Left.Type.Etype {        case TSTRING, TARRAY, TSLICE:            ...            // 访问数组的索引是非整数时，报错            if n.Right.Type != nil &amp;&amp; !n.Right.Type.IsInteger() {                yyerror(&quot;non-integer array index %v&quot;, n.Right)                break            }            if !n.Bounded() &amp;&amp; Isconst(n.Right, CTINT) {                x := n.Right.Int64()                // 访问数组的索引是负数时，报错                if x &lt; 0 {                    yyerror(&quot;invalid array index %v (index must be non-negative)&quot;, n.Right)                  // 访问数组的索引越界时，报错                } else if n.Left.Type.IsArray() &amp;&amp; x &gt;= n.Left.Type.NumElem() {                    yyerror(&quot;invalid array index %v (out of bounds for %d-element array)&quot;, n.Right, n.Left.Type.NumElem())                }            }        }    ...    }}</code></pre><p>数组和字符串的一些简单越界错误都会在编译期间发现，例如：直接使用整数或者常量访问数组；但是<font color="blue">如果使用变量去访问数组或者字符串时，编译器就无法提前发现错误，我们需要 Go 语言运行时阻止不合法的访问</font>：</p><pre><code>arr[4]: invalid array index 4 (out of bounds for 3-element array)arr[i]: panic: runtime error: index out of range [4] with length 3</code></pre><p>Go 语言运行时在发现数组、切片和字符串的越界操作会由运行时的 <strong>runtime.panicIndex</strong> 和 <strong>runtime.goPanicIndex</strong> 触发程序的运行时错误并导致崩溃退出：</p><pre><code>TEXT runtime·panicIndex(SB),NOSPLIT,$0-8    MOVL    AX, x+0(FP)    MOVL    CX, y+4(FP)    JMP    runtime·goPanicIndex(SB)func goPanicIndex(x int, y int) {    panicCheck1(getcallerpc(), &quot;index out of range&quot;)    panic(boundsError{x: int64(x), signed: true, y: y, code: boundsIndex})}</code></pre><p>当数组的访问操作 OINDEX 成功通过编译器的检查后，会被转换成几个 SSA 指令，假设我们有如下所示的 Go 语言代码，通过如下的方式进行编译会得到 ssa.html 文件：</p><pre><code>package checkfunc outOfRange() int {    arr := [3]int{1, 2, 3}    i := 4    elem := arr[i]    return elem}$ GOSSAFUNC=outOfRange go build array.godumped SSA to ./ssa.html</code></pre><p>start 阶段生成的 SSA 代码就是优化之前的第一版中间代码，下面展示的部分是 elem := arr[i] 对应的中间代码，在这段中间代码中我们发现 Go 语言为数组的访问操作生成了判断数组上限的指令 IsInBounds 以及当条件不满足时触发程序崩溃的 PanicBounds 指令：</p><pre><code>b1:    ...    v22 (6) = LocalAddr &lt;*[3]int&gt; {arr} v2 v20    v23 (6) = IsInBounds &lt;bool&gt; v21 v11If v23 → b2 b3 (likely) (6)b2: ← b1-    v26 (6) = PtrIndex &lt;*int&gt; v22 v21    v27 (6) = Copy &lt;mem&gt; v20    v28 (6) = Load &lt;int&gt; v26 v27 (elem[int])    ...Ret v30 (+7)b3: ← b1-    v24 (6) = Copy &lt;mem&gt; v20    v25 (6) = PanicBounds &lt;mem&gt; [0] v21 v11 v24Exit v25 (6)</code></pre><p><font color="red">编译器会将 PanicBounds 指令转换成上面提到的 runtime.panicIndex 函数，当数组下标没有越界时，编译器会先获取数组的内存地址和访问的下标、利用 PtrIndex 计算出目标元素的地址，最后使用 Load 操作将指针中的元素加载到内存中</font>。</p><p>当然只有当编译器无法对数组下标是否越界无法做出判断时才会加入 PanicBounds 指令交给运行时进行判断，在使用字面量整数访问数组下标时会生成非常简单的中间代码，当我们将上述代码中的 arr[i] 改成 arr[2] 时，就会得到如下所示的代码：</p><pre><code>b1:    ...    v21 (5) = LocalAddr &lt;*[3]int&gt; {arr} v2 v20    v22 (5) = PtrIndex &lt;*int&gt; v21 v14    v23 (5) = Load &lt;int&gt; v22 v20 (elem[int])    ...</code></pre><p>Go 语言对于数组的访问还是有着比较多的检查的，<font color="blue">它不仅会在编译期间提前发现一些简单的越界错误并插入用于检测数组上限的函数调用，还会在运行期间通过插入的函数保证不会发生越界</font>。</p><p>数组的赋值和更新操作 a[i] = 2 也会生成 SSA 生成期间计算出数组当前元素的内存地址，然后修改当前内存地址的内容，这些赋值语句会被转换成如下所示的 SSA 代码：</p><pre><code>b1:    ...    v21 (5) = LocalAddr &lt;*[3]int&gt; {arr} v2 v19    v22 (5) = PtrIndex &lt;*int&gt; v21 v13    v23 (5) = Store &lt;mem&gt; {int} v22 v20 v19    ...</code></pre><p>赋值的过程中会先确定目标数组的地址，再通过 PtrIndex 获取目标元素的地址，最后使用 Store 指令将数据存入地址中，从上面的这些 SSA 代码中我们可以看出<font color="blue">无论是数组的寻址还是赋值都是在编译阶段完成的，没有运行时的参与</font>。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>数组是 Go 语言中重要的数据结构，了解它的实现能够帮助我们更好地理解这门语言，通过对其实现的分析，我们知道了<font color="red">对数组的访问和赋值需要同时依赖编译器和运行时，它的大多数操作在编译期间都会转换成直接读写内存，在中间代码生成期间，编译器还会插入运行时方法 runtime.panicIndex 调用防止发生越界错误</font>。</p><p><img src="http://qlkvpxmsx.hd-bkt.clouddn.com/%E6%95%B0%E7%BB%84%E5%B0%8F%E7%BB%93.png" alt></p><h4 id="遗留问题："><a href="#遗留问题：" class="headerlink" title="遗留问题："></a>遗留问题：</h4><p>如果数组元素大于 4 个，变量就会在静态存储区初始化然后拷贝到栈上”， 请问go为什么要这样实现，既然最终都要到栈上，即使400个元素，直接在栈上初始化，会如何呢？</p>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> 源码解析 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Go源码解析0】预备知识</title>
      <link href="/2021/01/03/go-sourcecode-prepare/"/>
      <url>/2021/01/03/go-sourcecode-prepare/</url>
      
        <content type="html"><![CDATA[<blockquote><p>学习Go语言的内部实现，主要依靠对源代码的分析，所以阅读源代码是很好的方式。大名鼎鼎的Linux之父linus谈到如何学习Linux内核时也说过”Read the F**ing Source code”。所以现在就开启我们的Go语言源码阅读之旅行吧～</p></blockquote><p>本节主要介绍Go源码解析的预备知识。</p><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h3 id="抽象语法树"><a href="#抽象语法树" class="headerlink" title="抽象语法树"></a>抽象语法树</h3><p>抽象语法树（Abstract Syntax Tree、AST），是源代码语法的结构的一种抽象表示，它用树状的方式表示编程语言的语法结构1。抽象语法树中的每一个节点都表示源代码中的一个元素，每一棵子树都表示一个语法元素，以表达式 2 * 3 + 7 为例，编译器的语法分析阶段会生成如下图所示的抽象语法树。</p><p><img src="http://qlkvpxmsx.hd-bkt.clouddn.com/%E6%8A%BD%E8%B1%A1%E8%AF%AD%E6%B3%95%E6%A0%91.png" alt></p><blockquote><p>图片来源于<a href="https://draveness.me/golang/docs/part1-prerequisite/ch02-compile/golang-compile-intro/" target="_blank" rel="noopener">draveness</a></p></blockquote><p>作为编译器常用的数据结构，抽象语法树抹去了源代码中不重要的一些字符 - 空格、分号或者括号等等。编译器在执行完语法分析之后会输出一个抽象语法树，这个抽象语法树会辅助编译器进行语义分析，我们可以用它来确定语法正确的程序是否存在一些类型不匹配的问题。</p><h3 id="静态单赋值"><a href="#静态单赋值" class="headerlink" title="静态单赋值"></a>静态单赋值</h3><p>静态单赋值（Static Single Assignment、SSA）是中间代码的特性，如果中间代码具有静态单赋值的特性，那么每个变量就只会被赋值一次。在实践中，我们通常会用下标实现静态单赋值，这里以下面的代码举个例子：</p><pre><code>x := 1x := 2y := x</code></pre><p>经过简单的分析，我们就能够发现上述的代码第一行的赋值语句 x := 1 不会起到任何作用。下面是具有 SSA 特性的中间代码，我们可以清晰地发现变量 y_1 和 x_1 是没有任何关系的，所以在机器码生成时就可以省去 x := 1 的复制，通过减少需要执行的指令优化这段代码。</p><pre><code>x_1 := 1x_2 := 2y_1 := x_2</code></pre><p>因为 SSA 的主要作用是对代码进行优化，所以它是编译器后端3的一部分；当然代码编译领域除了 SSA 还有很多中间代码的优化方法，编译器生成代码的优化也是一个古老并且复杂的领域，这里就不会展开介绍了。</p><h3 id="指令集"><a href="#指令集" class="headerlink" title="指令集"></a>指令集</h3><p>最后要介绍的一个预备知识就是指令集4了，很多开发者在都会遇到在本地开发环境编译和运行正常的代码，在生产环境却无法正常工作，这种问题背后会有多种原因，而不同机器使用的不同指令集可能是原因之一。</p><p>我们大多数开发者都会使用 x86_64 的 Macbook 作为工作上主要使用的设备，在命令行中输入 uname -m 就能获得当前机器的硬件信息：</p><pre><code>$ uname -mx86_64</code></pre><p>x86 是目前比较常见的指令集，除了 x86 之外，还有 arm 等指令集，苹果最新 Macbook 的自研芯片就使用了 arm 指令集，不同的处理器使用了不同的架构和机器语言，所以很多编程语言为了在不同的机器上运行需要将源代码根据架构翻译成不同的机器代码。</p><p>复杂指令集计算机（CISC）和精简指令集计算机（RISC）是两种遵循不同设计理念的指令集，从名字我们就可以推测出这两种指令集的区别：</p><ul><li>复杂指令集：通过增加指令的类型减少需要执行的指令数；</li><li>精简指令集：使用更少的指令类型完成目标的计算任务；</li></ul><p>早期的 CPU 为了减少机器语言指令的数量一般使用复杂指令集完成计算任务，这两者并没有绝对的优劣，它们只是在一些设计上的选择不同以达到不同的目的，我们会在后面的机器码生成一节中详细介绍指令集架构，不过各位读者也可以主动了解相关的内容。</p><h1 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a>编译原理</h1><p>Go 语言编译器的源代码在 src/cmd/compile 目录中，目录下的文件共同组成了 Go 语言的编译器</p><p>Go语言的具体编译过程如下：</p><p><img src="http://qlkvpxmsx.hd-bkt.clouddn.com/Go%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.png" alt></p><p>至此，我们就简单了解了Go源码编译的过程。</p>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> 源码解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Go特性8】Socket编程之UDP</title>
      <link href="/2021/01/02/go-feature-socket-udp/"/>
      <url>/2021/01/02/go-feature-socket-udp/</url>
      
        <content type="html"><![CDATA[<h1 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h1><p>在之前的案例中，我们一直使用的是TCP协议来编写Socket的客户端与服务端。其实也可以使用UDP协议来编写Socket的客户端与服务端。</p><h3 id="UDP服务器"><a href="#UDP服务器" class="headerlink" title="UDP服务器"></a>UDP服务器</h3><p><font color="red">由于UDP是“无连接”的，所以，服务器端不需要额外创建监听套接字</font>，只需要指定好IP和port，然后监听该地址，等待客户端与之建立连接，即可通信。</p><p>创建监听地址：</p><pre><code>func ResolveUDPAddr(network, address string) (*UDPAddr, error) </code></pre><p>创建监听连接：</p><pre><code>func ListenUDP(network string, laddr *UDPAddr) (*UDPConn, error) </code></pre><p>接收udp数据：</p><pre><code>func (c *UDPConn) ReadFromUDP(b []byte) (int, *UDPAddr, error)</code></pre><p>写出数据到udp：</p><pre><code>func (c *UDPConn) WriteToUDP(b []byte, addr *UDPAddr) (int, error)</code></pre><p>服务端完整代码实现如下：</p><pre><code>package main  import (    &quot;fmt&quot;    &quot;net&quot; )  func main() {    //创建监听的地址，并且指定udp协议    udp_addr, err := net.ResolveUDPAddr(&quot;udp&quot;, &quot;127.0.0.1:8002&quot;)    if err != nil {       fmt.Println(&quot;ResolveUDPAddr err:&quot;, err)       return    }    conn, err := net.ListenUDP(&quot;udp&quot;, udp_addr)    //创建监听链接    if err != nil {       fmt.Println(&quot;ListenUDP err:&quot;, err)       return    }    defer conn.Close()     buf := make([]byte, 1024)    n, raddr, err := conn.ReadFromUDP(buf)        //接收客户端发送过来的数据，填充到切片buf中。    if err != nil {       return    }    fmt.Println(&quot;客户端发送：&quot;, string(buf[:n]))     _, err = conn.WriteToUDP([]byte(&quot;nice to see u in udp&quot;), raddr) //向客户端发送数据    if err != nil {       fmt.Println(&quot;WriteToUDP err:&quot;, err)       return    } }</code></pre><h3 id="UDP客户端"><a href="#UDP客户端" class="headerlink" title="UDP客户端"></a>UDP客户端</h3><p>udp客户端的编写与TCP客户端的编写，基本上是一样的，只是将协议换成udp.代码如下：</p><pre><code>package main  import (    &quot;net&quot;    &quot;fmt&quot; )  func main() {    conn, err := net.Dial(&quot;udp&quot;, &quot;127.0.0.1:8002&quot;)     if err != nil {       fmt.Println(&quot;net.Dial err:&quot;, err)       return    }    defer conn.Close()     conn.Write([]byte(&quot;Hello! I&#39;m client in UDP!&quot;))     buf := make([]byte, 1024)    n, err1 := conn.Read(buf)    if err1 != nil {       return    }    fmt.Println(&quot;服务器发来：&quot;, string(buf[:n])) }</code></pre><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p>其实对于UDP而言，服务器不需要并发，只要循环处理客户端数据即可。客户端也等同于TCP通信并发的客户端。</p><h3 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h3><pre><code>package main  import (    &quot;net&quot;    &quot;fmt&quot; )  func main() {    // 创建 服务器 UDP 地址结构。指定 IP + port    laddr, err := net.ResolveUDPAddr(&quot;udp&quot;, &quot;127.0.0.1:8003&quot;)    if err != nil {       fmt.Println(&quot;ResolveUDPAddr err:&quot;, err)       return    }    // 监听 客户端连接    conn, err := net.ListenUDP(&quot;udp&quot;, laddr)    if err != nil {       fmt.Println(&quot;net.ListenUDP err:&quot;, err)       return    }    defer conn.Close()     for {       buf := make([]byte, 1024)       n, raddr, err := conn.ReadFromUDP(buf)       if err != nil {          fmt.Println(&quot;conn.ReadFromUDP err:&quot;, err)          return       }       fmt.Printf(&quot;接收到客户端[%s]：%s&quot;, raddr, string(buf[:n]))        conn.WriteToUDP([]byte(&quot;I-AM-SERVER&quot;), raddr) // 简单回写数据给客户端    } }</code></pre><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><pre><code>package main  import (    &quot;net&quot;    &quot;os&quot;    &quot;fmt&quot; )  func main() {    conn, err := net.Dial(&quot;udp&quot;, &quot;127.0.0.1:8003&quot;)    if err != nil {       fmt.Println(&quot;net.Dial err:&quot;, err)       return    }    defer conn.Close()    go func() {       str := make([]byte, 1024)       for {          n, err := os.Stdin.Read(str) //从键盘读取内容， 放在str          if err != nil {             fmt.Println(&quot;os.Stdin. err1 = &quot;, err)             return          }          conn.Write(str[:n])       // 给服务器发送       }    }()    buf := make([]byte, 1024)    for {       n, err := conn.Read(buf)       if err != nil {          fmt.Println(&quot;conn.Read err:&quot;, err)          return       }       fmt.Println(&quot;服务器写来：&quot;, string(buf[:n]))    } }</code></pre><h2 id="UDP与TCP的差异"><a href="#UDP与TCP的差异" class="headerlink" title="UDP与TCP的差异"></a>UDP与TCP的差异</h2><table><thead><tr><th>TCP</th><th>UDP</th></tr></thead><tbody><tr><td>面向连接</td><td>面向无连接</td></tr><tr><td>要求系统资源较多</td><td>要求系统资源较少</td></tr><tr><td>TCP程序结构较复杂</td><td>UDP程序结构较简单</td></tr><tr><td>使用流式</td><td>使用数据包式</td></tr><tr><td>保证数据准确性</td><td>不保证数据准确性</td></tr><tr><td>保证数据顺序</td><td>不保证数据顺序</td></tr><tr><td>通讯速度较慢</td><td>通讯速度较快</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> udp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Go特性7】Socket编程之TCP</title>
      <link href="/2020/12/31/go-feature-socket-tcp/"/>
      <url>/2020/12/31/go-feature-socket-tcp/</url>
      
        <content type="html"><![CDATA[<h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><p><img src="http://qlkvpxmsx.hd-bkt.clouddn.com/TCP%E7%9A%84C%3AS%E6%9E%B6%E6%9E%84.png" alt></p><h2 id="简单C-S模型通信"><a href="#简单C-S模型通信" class="headerlink" title="简单C/S模型通信"></a>简单C/S模型通信</h2><h3 id="Server端"><a href="#Server端" class="headerlink" title="Server端"></a>Server端</h3><p>Listen函数：</p><pre><code>func Listen(network, address string) (Listener, error)    network：选用的协议：TCP、UDP，     如：“tcp”或 “udp”    address：IP地址+端口号,             如：“127.0.0.1:8000”或 “:8000”</code></pre><p>Listener 接口：</p><pre><code>type Listener interface {        Accept() (Conn, error)        Close() error        Addr() Addr}</code></pre><p>Conn 接口：</p><pre><code>type Conn interface {    Read(b []byte) (n int, err error)    Write(b []byte) (n int, err error)    Close() error    LocalAddr() Addr    RemoteAddr() Addr    SetDeadline(t time.Time) error    SetReadDeadline(t time.Time) error    SetWriteDeadline(t time.Time) error}</code></pre><p>示例代码：</p><pre><code>//TCP服务器.gopackage main  import (    &quot;net&quot;    &quot;fmt&quot; )  func main()  {    // 创建一个用于监听的socket套接字    listener, err:= net.Listen(&quot;tcp&quot;, &quot;:8000&quot;)    if err != nil {       fmt.Println(&quot;listen err:&quot;, err)       return    }    defer listener.Close()          // 主协程结束时，关闭listener     fmt.Println(&quot;服务器等待客户端建立连接...&quot;)    // 等待客户端连接请求    conn, err := listener.Accept()    if err != nil {       fmt.Println(&quot;accept err:&quot;, err)       return    }   defer conn.Close()             // 使用结束，断开与客户端链接    fmt.Println(&quot;客户端与服务器连接建立成功...&quot;)     // 接收客户端数据    buf := make([]byte, 1024)        // 创建1024大小的缓冲区，用于read    n, err := conn.Read(buf)    if err != nil {       fmt.Println(&quot;read err:&quot;, err)       return    }    fmt.Println(&quot;服务器读到:&quot;, string(buf[:n])) // 读多少，打印多少。 }</code></pre><p>如图，在整个通信过程中，<font color="red">服务器端有两个socket参与进来，但用于通信的只有 conn 这个socket</font>。它是由 listener创建的。隶属于服务器端。</p><p><img src="http://qlkvpxmsx.hd-bkt.clouddn.com/%E5%9B%BE%E7%89%87%201.png" alt></p><h3 id="Client端"><a href="#Client端" class="headerlink" title="Client端"></a>Client端</h3><p>Dial函数：</p><pre><code>func Dial(network, address string) (Conn, error)    network：选用的协议：TCP、UD`P，如：“tcp”或 “udp”    address：服务器IP地址+端口号, 如：“121.36.108.11:8000”或 “www.itcast.cn:8000”</code></pre><p>Conn 接口：</p><pre><code>type Conn interface {    Read(b []byte) (n int, err error)    Write(b []byte) (n int, err error)    Close() error    LocalAddr() Addr    RemoteAddr() Addr    SetDeadline(t time.Time) error    SetReadDeadline(t time.Time) error    SetWriteDeadline(t time.Time) error}</code></pre><p>示例代码：</p><pre><code>package main  import (    &quot;net&quot;    &quot;fmt&quot; )  func main() {    // 主动发起连接请求    conn, err := net.Dial(&quot;tcp&quot;, &quot;127.0.0.1:8000&quot;)    if err != nil {       fmt.Println(&quot;Dial err:&quot;, err)       return    }    defer conn.Close()         // 结束时，关闭连接     // 发送数据    _, err = conn.Write([]byte(&quot;Are u ready?&quot;))    if err != nil {       fmt.Println(&quot;Write err:&quot;, err)       return    } }</code></pre><h2 id="并发的C-S模型通信"><a href="#并发的C-S模型通信" class="headerlink" title="并发的C/S模型通信"></a>并发的C/S模型通信</h2><h3 id="并发Server"><a href="#并发Server" class="headerlink" title="并发Server"></a>并发Server</h3><p>现在已经完成了客户端与服务端的通信，但是服务端只能接收一个用户发送过来的数据，怎样接收多个客户端发送过来的数据，实现一个高效的并发服务器呢？</p><p><img src="http://qlkvpxmsx.hd-bkt.clouddn.com/%E5%B9%B6%E5%8F%91%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1.png" alt></p><p>Accept(())函数的作用是等待客户端的链接，如果客户端没有链接，该方法会阻塞。如果有客户端链接，那么该方法返回一个Socket负责与客户端进行通信。所以，每来一个客户端，该方法就应该返回一个Socket与其通信，因此，可以使用一个死循环，将Accept(())调用过程包裹起来。</p><p><font color="red">需要注意的是，实现并发处理多个客户端数据的服务器，就需要针对每一个客户端连接，单独产生一个Socket，并创建一个单独的goroutine与之完成通信。</font></p><pre><code>//监听    listener, err := net.Listen(&quot;tcp&quot;, &quot;127.0.0.1:8001&quot;)    if err != nil {            fmt.Println(&quot;err = &quot;, err)            return    }    defer listener.Close()    //接收多个用户    for {            conn, err := listener.Accept()            if err != nil {                  fmt.Println(&quot;err = &quot;, err)                    return            }            //处理用户请求, 新建一个协程            go HandleConn(conn)}</code></pre><p>将客户端的数据处理工作封装到HandleConn方法中，需将Accept()返回的Socket传递给该方法，变量conn的类型为：net.Conn。可以使用conn.RemoteAddr()来获取成功与服务器建立连接的客户端IP地址和端口号：</p><p>Conn 接口：</p><pre><code>type Conn interface {    Read(b []byte) (n int, err error)    Write(b []byte) (n int, err error)    Close() error    LocalAddr() Addr    RemoteAddr() Addr    SetDeadline(t time.Time) error    SetReadDeadline(t time.Time) error    SetWriteDeadline(t time.Time) error}</code></pre><pre><code>//获取客户端的网络地址信息addr := conn.RemoteAddr().String()fmt.Println(addr, &quot; conncet sucessful&quot;)</code></pre><p><font color="red">客户端可能持续不断的发送数据，因此接收数据的过程可以放在for循环中</font>，服务端也持续不断的向客户端返回处理后的数据。</p><p>添加一个限定，如果客户端发送一个“exit”字符串，表示客户端通知服务器不再向服务端发送数据，此时应该结束HandleConn方法，同时关闭与该客户端关联的Socket。</p><pre><code>buf := make([]byte, 2048)    //创建一个切片，存储客户端发送的数据for {        //读取用户数据         n, err := conn.Read(buf)        if err != nil {            fmt.Println(&quot;err = &quot;, err)            return        }        fmt.Printf(&quot;[%s]: %s\n&quot;, addr, string(buf[:n]))        if  &quot;exit&quot; == string(buf[:n-2]) {         //自己写的客户端测试, 发送时，多了2个字符, &quot;\r\n&quot;            fmt.Println(addr, &quot; exit&quot;)            return        }        //服务器处理数据：把客户端数据转大写，再写回给client        conn.Write([]byte(strings.ToUpper(string(buf[:n])))) }</code></pre><p>在上面的代码中，Read(())方法获取客户端发送过来的数据，填充到切片buf中，返回的是实际填充的数据的长度，所以将客户端发送过来的数据进行打印，打印的是实际接收到的数据。</p><pre><code>fmt.Printf(&quot;[%s]: %s\n&quot;, addr, string(buf[:n])).</code></pre><p>同时也可以将客户端的网络地址信息打印出来。<br>在判断客户端数据是否为“exit”字符串时，要注意，客户端会自动的多发送2个字符：“\r\n”（这在windows系统下代表回车、换行）</p><p>Server使用Write方法将数据写回给客户端，参数类型是 []byte，需使用strings包下的ToUpper函数来完成大小写转换。转换的对象即为string((buf[:n]))</p><p>综上，HandleConn方法完整定义如下：</p><pre><code>//处理用户请求func HandleConn(conn net.Conn) {//函数调用完毕，自动关闭conndefer conn.Close()          //获取客户端的网络地址信息          addr := conn.RemoteAddr().String()          fmt.Println(addr, &quot; conncet sucessful&quot;)          buf := make([]byte, 2048)          for {                  //读取用户数据                 n, err := conn.Read(buf)                 if err != nil {                         fmt.Println(&quot;err = &quot;, err)                         return                    }                    fmt.Printf(&quot;[%s]: %s\n&quot;,  addr,  string(buf[:n]))                fmt.Println(&quot;len = &quot;, len(string(buf[:n])))                        //if &quot;exit&quot; == string(buf[:n-1]) {     // nc测试，发送时，只有 \n                 if  &quot;exit&quot; == string(buf[:n-2]) {    // 自己写的客户端测试, 发送时，多了2个字符, &quot;\r\n&quot;                        fmt.Println(addr, &quot; exit&quot;)                        return                 }                 //把数据转换为大写，再给用户发送                 conn.Write([]byte(strings.ToUpper(string(buf[:n]))))          }}</code></pre><h3 id="并发Client"><a href="#并发Client" class="headerlink" title="并发Client"></a>并发Client</h3><p>客户端不仅需要持续的向服务端发送数据，同时也要接收从服务端返回的数据。因此可将发送和接收放到不同的协程中。</p><p>主协程循环接收服务器回发的数据（该数据应已转换为大写），并打印至屏幕；子协程循环从键盘读取用户输入数据，写给服务器。读取键盘输入可使用 os.Stdin.Read((str))。定义切片str，将读到的数据保存至str中。</p><p>这样，客户端也实现了多任务。</p><p>客户端代码实现：</p><pre><code>package main  import (    &quot;net&quot;    &quot;fmt&quot;    &quot;os&quot; )  func main() {    // 主动发起连接请求    conn, err := net.Dial(&quot;tcp&quot;, &quot;127.0.0.1:8001&quot;)    if err != nil {       fmt.Println(&quot;Dial err:&quot;, err)       return    }    defer conn.Close()                       // 客户端终止时，关闭与服务器通信的 socket      // 启动子协程，接收用户键盘输入    go func() {        str := make([]byte, 1024)           // 创建用于存储用户键盘输入数据的切片缓冲区。       for {                                // 反复读取          n, err :=os.Stdin.Read(str)        // 获取用户键盘输入          if err != nil {             fmt.Println(&quot;os.Stdin.Read err:&quot;, err)             return          }          // 将从键盘读到的数据，发送给服务器          _, err = conn.Write(str[:n])       // 读多少，写多少          if err != nil {             fmt.Println(&quot;conn.Write err:&quot;, err)             return          }       }    }()     // 主协程，接收服务器回发数据，打印至屏幕    buf := make([]byte, 1024)                // 定义用于存储服务器回发数据的切片缓冲区    for {       n, err := conn.Read(buf)              // 从通信 socket 中读数据，存入切片缓冲区       if err != nil {          fmt.Println(&quot;conn.Read err:&quot;, err)          return       }       fmt.Printf(&quot;服务器回发：%s\n&quot;, string(buf[:n]))    } }</code></pre><h2 id="TCP通信"><a href="#TCP通信" class="headerlink" title="TCP通信"></a>TCP通信</h2><p>下图是一次TCP通讯的时序图。TCP连接建立断开。包含大家熟知的三次握手和四次握手。</p><p><img src="http://qlkvpxmsx.hd-bkt.clouddn.com/TCP%E9%80%9A%E4%BF%A1.png" alt></p><p>在这个例子中，首先客户端主动发起连接、发送请求，然后服务器端响应请求，然后客户端主动关闭连接。两条竖线表示通讯的两端，从上到下表示时间的先后顺序。注意，数据从一端传到网络的另一端也需要时间，所以图中的箭头都是斜的。</p><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>所谓三次握手（Three-Way Handshake）即建立TCP连接，就是指建立一个TCP连接时，需要客户端和服务端总共发送3个包以确认连接的建立。好比两个人在打电话：<br>Client:“喂，你听得到吗？”<br>Server:“我听得到，你听得到我吗？”<br>Client:“我能听到你，今天balabala…”</p><p>建立连接（三次握手）的过程：</p><ol><li>客户端发送一个带SYN标志的TCP报文到服务器。这是上图中三次握手过程中的段1。客户端发出SYN位表示连接请求。序号是1000，这个序号在网络通讯中用作临时的地址，每发一个数据字节，这个序号要加1，这样在接收端可以根据序号排出数据包的正确顺序，也可以发现丢包的情况。<br>另外，规定SYN位和FIN位也要占一个序号，这次虽然没发数据，但是由于发了SYN位，因此下次再发送应该用序号1001。<br>mss表示最大段尺寸，如果一个段太大，封装成帧后超过了链路层的最大长度，就必须在IP层分片，为了避免这种情况，客户端声明自己的最大段尺寸，建议服务器端发来的段不要超过这个长度。</li><li>服务器端回应客户端，是三次握手中的第2个报文段，同时带ACK标志和SYN标志。表示对刚才客户端SYN的回应；同时又发送SYN给客户端，询问客户端是否准备好进行数据通讯。<br>服务器发出段2，也带有SYN位，同时置ACK位表示确认，确认序号是1001，表示“我接收到序号1000及其以前所有的段，请你下次发送序号为1001的段”，也就是应答了客户端的连接请求，同时也给客户端发出一个连接请求，同时声明最大尺寸为1024。</li><li>客户必须再次回应服务器端一个ACK报文，这是报文段3。<br>客户端发出段3，对服务器的连接请求进行应答，确认序号是8001。</li></ol><p>在这个过程中，客户端和服务器分别给对方发了连接请求，也应答了对方的连接请求，其中服务器的请求和应答在一个段中发出。<br>因此一共有三个段用于建立连接，称为“三方握手”。在建立连接的同时，双方协商了一些信息，例如，双方发送序号的初始值、最大段尺寸等。</p><h3 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h3><ol><li>客户端发出段4，包含从序号1001开始的20个字节数据。</li><li>服务器发出段5，确认序号为1021，对序号为1001-1020的数据表示确认收到，同时请求发送序号1021开始的数据，服务器在应答的同时也向客户端发送从序号8001开始的10个字节数据。</li><li>客户端发出段6，对服务器发来的序号为8001-8010的数据表示确认收到，请求发送序号8011开始的数据。</li></ol><p>在数据传输过程中，ACK和确认序号是非常重要的，应用程序交给TCP协议发送的数据会暂存在TCP层的发送缓冲区中，发出数据包给对方之后，只有收到对方应答的ACK段才知道该数据包确实发到了对方，可以从发送缓冲区中释放掉了，如果因为网络故障丢失了数据包或者丢失了对方发回的ACK段，经过等待超时后TCP协议自动将发送缓冲区中的数据包重发。</p><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p>所谓四次挥手（Four-Way-Wavehand）即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。在socket编程中，这一过程由客户端或服务器任一方执行close来触发。好比两个人打完电话要挂断：<br>Client:“我要说的事情都说完了，我没事了。挂啦？”<br>Server:“等下，我还有一个事儿。Balabala…”<br>Server:“好了，我没事儿了。挂了啊。”<br>Client:“ok！拜拜”</p><p>关闭连接（四次握手）的过程：</p><p>由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。</p><ol><li>客户端发出段7，FIN位表示关闭连接的请求。</li><li>服务器发出段8，应答客户端的关闭连接请求。</li><li>服务器发出段9，其中也包含FIN位，向客户端发送关闭连接请求。</li><li>客户端发出段10，应答服务器的关闭连接请求。</li></ol><p>建立连接的过程是三次握手，而关闭连接通常需要4个段，服务器的应答和关闭连接请求通常不合并在一个段中，因为有连接半关闭的情况，这种情况下客户端关闭连接之后就不能再发送数据给服务器了，但是服务器还可以发送数据给客户端，直到服务器也关闭连接为止。</p><p><img src="http://qlkvpxmsx.hd-bkt.clouddn.com/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E3%80%814%E6%AC%A1%E6%8C%A5%E6%89%8B.png" alt></p><h3 id="TCP状态转换图"><a href="#TCP状态转换图" class="headerlink" title="TCP状态转换图"></a>TCP状态转换图</h3><p><img src="http://qlkvpxmsx.hd-bkt.clouddn.com/TCP%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%9B%BE.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> tcp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【leetcode-567】字符串的排列</title>
      <link href="/2020/12/30/leetcode-567/"/>
      <url>/2020/12/30/leetcode-567/</url>
      
        <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/permutation-in-string/" target="_blank" rel="noopener">567. 字符串的排列</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定两个字符串 s1 和 s2，写一个函数来判断 s2 是否包含 s1 的排列。</p><p>换句话说，第一个字符串的排列之一是第二个字符串的子串。</p><p>示例1:</p><pre><code>输入: s1 = &quot;ab&quot; s2 = &quot;eidbaooo&quot;输出: True解释: s2 包含 s1 的排列之一 (&quot;ba&quot;).</code></pre><p>示例2:</p><pre><code>输入: s1= &quot;ab&quot; s2 = &quot;eidboaoo&quot;输出: False</code></pre><p>注意：</p><ol><li>输入的字符串只包含小写字母</li><li>两个字符串的长度都在 [1, 10,000] 之间</li></ol><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>这道题的直接思路是先对子串s1进行全排列，然后将每种排列去s2中找，但是由于全排列的时间复杂度为O((n!))，所以不可能这么做，也就是说我们需要换一种思路。</p><p>现在我们换一种问法，能否s2中找到一个子串，使得这个子串包含s1中的所有字符但是不包含其他字符？</p><p>作为字符串匹配问题，我们很容易就想到滑动窗口算法。既然采用滑动窗口算法，就需要套算法框架：</p><pre><code>/* 滑动窗口算法框架 */void slidingWindow(string s, string t) {    unordered_map&lt;char, int&gt; need, window;    for (char c : t) need[c]++;    int left = 0, right = 0;    int valid = 0;     while (right &lt; s.size()) {        // c 是将移入窗口的字符        char c = s[right];        // 右移窗口        right++;        // 进行窗口内数据的一系列更新        ...        /*** debug 输出的位置 ***/        printf(&quot;window: [%d, %d)\n&quot;, left, right);        /********************/        // 判断左侧窗口是否要收缩        while (window needs shrink) {            // d 是将移出窗口的字符            char d = s[left];            // 左移窗口            left++;            // 进行窗口内数据的一系列更新            ...        }    }}</code></pre><p>对于这个问题，我们主要需要注意的点在于：</p><ol><li>判断窗口收缩的条件是什么？</li><li>何时返回true？</li></ol><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code>func checkInclusion(s1 string, s2 string) bool {    // 用map定义滑动窗口和目标子串    window, need := make(map[byte]int), make(map[byte]int)    // 初始化目标子串    for _, v := range s1 {        need[byte(v)]++    }    // 定义窗口左右边界    left, right := 0,0    // 记录已经凑足的有效字符种类数    valid := 0    // 右边界没到底    for right != len(s2)  {        // 记录当前字符        c := s2[right]        // 右边界右移        right++        // 将此字符加入窗口        window[c]++        // 如果这个字符所需个数已经满足要求，valid++        if window[c] == need[c] {            valid++        }        // 如果字符总个数已经达到了要求字符数，可能是一种全排列，准备缩小窗口        for right - left == len(s1)  {            // 字符总个数和对应字符数均符合，说明刚好是一种全排列，直接返回true            if valid == len(need) {                return true            }            // 走到这里说明不是一种全排列，缩小窗口            c := s2[left]            // 如果减去这个字符之后会导致这个字符的个数不足，那么valid--            if window[c] == need[c] {                valid--            }            // 缩小窗口            window[c]--            left++            }    }    // 已经走到底了还是没有符合要求的字符串    return false}</code></pre><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><h3 id="时间复杂度：O-n"><a href="#时间复杂度：O-n" class="headerlink" title="时间复杂度：O((n))"></a>时间复杂度：O((n))</h3><p>在最坏的情况下，两个指针都要扫描整个字符串S一遍，如果字符串的长度为n，则时间复杂度是O((2n))=O((n))</p><h3 id="空间复杂度：O-C"><a href="#空间复杂度：O-C" class="headerlink" title="空间复杂度：O((C))"></a>空间复杂度：O((C))</h3><p>采用了两个辅助的map，用于记录当前窗口的字符串和子串，如果子串字符种类数为C，则空间复杂度为O((C))</p><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><p>写出滑动窗口算法的框架不难，难的是处理好细节问题，而这个细节问题则需要具体问题具体分析，比如对于这道题，需要注意的就是：</p><ol><li><p>何时不再扩张窗口（右边界不移动）？</p><p> 由于各种全排列的字符数量是固定的，所以一旦窗口扩张到字符数量到了目标子串的数量，那么就需要查看是否已经得到了满足要求的子串，如果没有，则需要移动左边界，缩小窗口，然后右边界继续右移。</p></li><li><p>何时返回 true ？</p><p> 当进入缩小窗口循环的时候，说明字符总数已经匹配了，那么只要再满足一个条件，就是对应字符的数量匹配就说明是一个合法的排列了，可以直接返回true。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Go特性6】Socket编程初探</title>
      <link href="/2020/12/29/go-feature-socket/"/>
      <url>/2020/12/29/go-feature-socket/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是Socket"><a href="#什么是Socket" class="headerlink" title="什么是Socket?"></a>什么是Socket?</h1><p>Socket，英文含义是【插座、插孔】，一般称之为套接字，用于描述IP地址和端口。可以实现不同程序间的数据通信。</p><p>Socket起源于Unix，而Unix基本哲学之一就是“一切皆文件”，都可以用“打开open –&gt; 读写write/read –&gt; 关闭close”模式来操作。Socket就是该模式的一个实现，网络的Socket数据传输是一种特殊的I/O，Socket也是一种文件描述符。Socket也具有一个类似于打开文件的函数调用：Socket()，该函数返回一个整型的Socket描述符，随后的连接建立、数据传输等操作都是通过该Socket实现的。</p><p>套接字的内核实现较为复杂，不宜在学习初期深入学习，了解到如下结构足矣。</p><p><img src="http://qlkvpxmsx.hd-bkt.clouddn.com/%E5%A5%97%E6%8E%A5%E5%AD%97.png" alt></p><p>在TCP/IP协议中，“IP地址+TCP或UDP端口号”唯一标识网络通讯中的一个进程。“IP地址+端口号”就对应一个socket。欲建立连接的两个进程各自有一个socket来标识，那么这两个socket组成的socket pair就唯一标识一个连接。因此可以用Socket来描述网络连接的一对一关系。</p><p>常用的Socket类型有两种：流式Socket（SOCK_STREAM）和数据报式Socket（SOCK_DGRAM）。流式是一种面向连接的Socket，针对于面向连接的TCP服务应用；数据报式Socket是一种无连接的Socket，对应于无连接的UDP服务应用。</p><h1 id="网络应用程序设计模式"><a href="#网络应用程序设计模式" class="headerlink" title="网络应用程序设计模式"></a>网络应用程序设计模式</h1><h3 id="C-S模式"><a href="#C-S模式" class="headerlink" title="C/S模式"></a>C/S模式</h3><p>传统的网络应用设计模式，客户机(client)/服务器(server)模式。需要在通讯两端各自部署客户机和服务器来完成数据通信。</p><ul><li>优点</li></ul><p>客户端位于目标主机上可以<font color="blue">保证性能，将数据缓存至客户端本地，从而提高数据传输效率</font>。且，一般来说客户端和服务器程序由一个开发团队创作，所以他们之间所采用的协议相对灵活。可以在标准协议的基础上根据需求裁剪及定制。例如，腾讯所采用的通信协议，即为ftp协议的修改剪裁版。</p><p>因此，<font color="blue">传统的网络应用程序及较大型的网络应用程序都首选C/S模式进行开发。</font>如，知名的网络游戏魔兽世界。3D画面，数据量庞大，<font color="blue">使用C/S模式可以提前在本地进行大量数据的缓存处理，从而提高观感。</font></p><ul><li>缺点</li></ul><p>由于客户端和服务器都需要有一个开发团队来完成开发。<font color="blue">工作量将成倍提升，开发周期较长</font>。另外，从用户角度出发，<font color="blue">需要将客户端安插至用户主机上，对用户主机的安全性构成威胁</font>。这也是很多用户不愿使用C/S模式应用程序的重要原因。</p><h3 id="B-S模式"><a href="#B-S模式" class="headerlink" title="B/S模式"></a>B/S模式</h3><p>浏览器(Browser)/服务器(Server)模式。只需在一端部署服务器，而另外一端使用每台PC都默认配置的浏览器即可完成数据的传输。</p><ul><li>优点</li></ul><p>B/S模式相比C/S模式而言，由于它没有独立的客户端，使用标准浏览器作为客户端，其工作开发量较小。只需开发服务器端即可。另外由于其采用浏览器显示数据，因此<font color="blue">移植性非常好，不受平台限制</font>。如早期的偷菜游戏，在各个平台上都可以完美运行。</p><ul><li>缺点</li></ul><p>由于使用第三方浏览器，因此网络应用支持受限。另外，没有客户端放到对方主机上，<font color="blue">缓存数据不尽如人意，从而传输数据量受到限制。应用的观感大打折扣。第三，必须与浏览器一样，采用标准http协议进行通信，协议选择不灵活</font>。</p><p>因此在开发过程中，模式的选择由上述各自的特点决定。根据实际需求选择应用程序设计模式。</p>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【leetcode-76】最小覆盖子串</title>
      <link href="/2020/12/27/leetcode-76/"/>
      <url>/2020/12/27/leetcode-76/</url>
      
        <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/minimum-window-substring/" target="_blank" rel="noopener">76. 最小覆盖子串</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “” 。</p><p>注意：如果 s 中存在这样的子串，我们保证它是唯一的答案。</p><p>示例 1：</p><pre><code>输入：s = &quot;ADOBECODEBANC&quot;, t = &quot;ABC&quot;输出：&quot;BANC&quot;</code></pre><p>示例 2：</p><pre><code>输入：s = &quot;a&quot;, t = &quot;a&quot;输出：&quot;a&quot;</code></pre><p>提示：</p><ul><li>1 &lt;= s.length, t.length &lt;= 105</li><li>s 和 t 由英文字母组成</li></ul><p>进阶：你能设计一个在 o((n) 时间内解决此问题的算法吗？</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>这题我们当然可以用暴力解法，即以字符串s的每一个字符为起点进行枚举，从中筛选出符合题且长度最小的子串，但是这个算法的时间复杂度将大于O((n))，所以肯定不是最优解。</p><p>实际上子串的问题都可以考虑通过双指针技巧减少时间复杂度，链表一般用快慢指针、数组一般用左右指针，而左右指针又常用于二分搜索，而这道题则是属于左右指针中最难的一类，滑动窗口算法。</p><p>直接上滑动窗口算法框架：</p><pre><code>/* 滑动窗口算法框架 */void slidingWindow(string s, string t) {    unordered_map&lt;char, int&gt; need, window;    for (char c : t) need[c]++;    int left = 0, right = 0;    int valid = 0;     while (right &lt; s.size()) {        // c 是将移入窗口的字符        char c = s[right];        // 右移窗口        right++;        // 进行窗口内数据的一系列更新        ...        /*** debug 输出的位置 ***/        printf(&quot;window: [%d, %d)\n&quot;, left, right);        /********************/        // 判断左侧窗口是否要收缩        while (window needs shrink) {            // d 是将移出窗口的字符            char d = s[left];            // 左移窗口            left++;            // 进行窗口内数据的一系列更新            ...        }    }}</code></pre><p>对于这道题，滑动窗口算法的思路是这样：</p><ol><li><p>我们在字符串 S 中使用双指针中的左右指针技巧，初始化 left = right = 0，把索引左闭右开区间 [left, right) 称为一个「窗口」。</p></li><li><p>我们先不断地增加 right 指针扩大窗口 [left, right)，直到窗口中的字符串符合要求（包含了 T 中的所有字符）。</p></li><li><p>此时，我们停止增加 right，转而不断增加 left 指针缩小窗口 [left, right)，直到窗口中的字符串不再符合要求（不包含 T 中的所有字符了）。同时，每次增加 left，我们都要更新一轮结果。</p></li><li><p>重复第 2 和第 3 步，直到 right 到达字符串 S 的尽头。</p></li></ol><p>实际上这道题的思路已经很清晰了，接下来就是一些细节问题，需要边写代码边处理。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code>func minWindow(s string, t string) string {    // 定义滑动窗口以及目标子串    window, need := make(map[byte]int, 0), make(map[byte]int, 0)    // 初始化目标子串    for _, c := range t {        need[byte(c)]++    }    // 定义窗口左右边界    left, right := 0, 0    // 定义当前窗口已经包含的有效字符种类数    valid := 0    // 记录最小覆盖子串的起始索引及长度（只可能小于等于s）    start, minLength := 0, len(s) + 1    //滑动终止条件（窗口右边界小于母串长度）    for right &lt; len(s) {        // c是即将移入窗口的字符        c := s[right]        // 右边界右移        right++        // 如果c是有效字符,更新当前窗口c的个数        if need[c] != 0 {            window[c]++            // 当前窗口内的该类字符已经凑足了，更新valid            if window[c] == need[c]{                valid++            }        }        // 判断左侧窗口是否要收缩(所有所需字符已经凑足)        // 注意这里是for而不是if，因为只要满足条件，就要不断缩小窗口        for valid == len(need) {            // 先获得一个结果，再试图缩小窗口            // 先更新最小覆盖串            if right - left &lt; minLength {                // start记录了当前子串的起点，跟minLength一起确定一个字符串                start = left                minLength = right - left            }            // 继续缩小窗口            // c是即将移出窗口的字符            c := s[left]            // 左边界右移            left++            // 如果c是有效字符,更新当前窗口c的个数            if need[c] != 0 {                window[c]--                // 更新完后，检查是c的个数仍然满足所需个数，不满足，则更新valid                if window[c] &lt; need[c] {                    valid--                }            }        }    }    // 如果最小长度有变化，则说明找到了    if minLength != len(s) + 1 {        return s[start:start+minLength]    }    return &quot;&quot;}</code></pre><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><h3 id="时间复杂度：O-n"><a href="#时间复杂度：O-n" class="headerlink" title="时间复杂度：O((n))"></a>时间复杂度：O((n))</h3><p>在最坏的情况下，两个指针都要扫描整个字符串S一遍，如果字符串的长度为n，则时间复杂度是O((2n))=O((n))</p><h3 id="空间复杂度：O-C"><a href="#空间复杂度：O-C" class="headerlink" title="空间复杂度：O((C))"></a>空间复杂度：O((C))</h3><p>采用了两个辅助的map，用于记录当前窗口的字符串和子串，如果子串长度为C，则空间复杂度为O((C))</p><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><p>滑动窗口算法属于比较难的一类问题，但是如果一旦确定了用滑动窗口算法就只需要套模版就行了，剩下的就是细节问题，比如对于这道题，我忽略的细节问题主要有两处：</p><ul><li>在缩小窗口，也就是移动左指针时，判断结束条件采用的是for，而不是if，因为只要当前子串满足条件，就要不断缩小窗口，这样才能找到一个最短的子串。</li><li>依旧是指针左移时，进入循环的第一件事应该是先获得一个结果，就是记录当前子串并更新最小子串，然后再试图，往移动左指针，缩小窗口。</li></ul><p>此外，还有一个小技巧，就是移动右指针和移动左指针的操作非常相似，有比较好的对称关系，这样可以方便记忆。</p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fabric 1.4源码分析:BCCSP模块</title>
      <link href="/2020/12/26/fabric-bccsp/"/>
      <url>/2020/12/26/fabric-bccsp/</url>
      
        <content type="html"><![CDATA[<h1 id="模块简介"><a href="#模块简介" class="headerlink" title="模块简介"></a>模块简介</h1><blockquote><p>注: 本文所涉及的代码均基于fabric 1.4.6的版本，其他版本可能会略有不同，但大体相似</p></blockquote><p>BCCSP ( Blockchain Cryptographic Service Provider)为 Fabric 其他模块(如 MSP 组件 等)提供密码服务套件，包括<font color="red">加密、解密、签名与验证、哈希函数</font>等方法。目前，原生fabric的BCCSP模块提供了 PKCS11类型和SW类型两种基本实现。</p><p>其中：</p><ul><li>PKCS11 (Public-Key Cryptography Standards)类型是基于 HSM ( Hardware Security Modules)硬件安全模块(https:// github.com/miekg/pkcsll )的加密服务实现,属于通用的接口标准，利 用pkcsll库提供的上下文对象pkcsl l.Ctx在SessionHandle基础上支持密码服务</li><li>SW类型是基于软件的加密服务实现的，直接使用crypto库下的包支持密码服务。同时，BCCSP 模块可提供对应的两类工厂对象，其他模块则基于这两类工厂对象调用对应的密码服务接口。</li></ul><p>本着一切从源码的角度出发，我们先来看看在fabric中的BCCSP模块的代码目录。</p><pre><code>$ tree ./bccsp -L 1./bccsp├── factory             初始化BCCSP对象及其工厂对象├── gm                  实现软件加密(国密)的BCCSP、key和keystore接口├── idemix              身份混淆器(和零知识证明有关)├── mocks               用于mock测试├── pkcs11              实现硬件加密的BCCSP、key和keystore接口├── signer              基于bccsp实现crypto.Signer├── sw                  实现软件加密(标准加密)的BCCSP、key和keystore接口└── utils               一些独立封装的辅助函数├── bccsp.go            定义BCCSP、key接口├── keystore.go         定义keystore接口├── idemixerrs.go       定义了idemix的err├── ecdsaopts.go        ├── aesopts.go├── gmopts.go├── hashopts.go         实现各自的opts接口├── idemixopts.go├── opts.go└── rsaopts.go</code></pre><p>这样过了一遍bccsp的代码目录之后，相信大家会对BCCSP模块有一些印象，但是还是没法获得一个整体的认知。下面，我们从一个更宏观的角度来理解bccsp模块的整体架构。</p><h1 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h1><p>我根据自己的理解画了一幅bccsp模块架构图，省略掉了细节，只保留了我认为的关键部分，如有不当之处还望大佬指正。</p><p><img src="http://qlkvpxmsx.hd-bkt.clouddn.com/BCCSP%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84.png" alt></p><p>如图所示，从上往下，我们依次分析。</p><h3 id="上层调用模块"><a href="#上层调用模块" class="headerlink" title="上层调用模块"></a>上层调用模块</h3><p>这一层主要是msp模块，msp模块是Fabric架构重要的系统抽象组件，为客户端、Peer<br>节点、Orderer节点等提供PKI数字证书以管理组织成员身份，从而有效控制资源实体（组<br>织、成员等）的认证、授权、撤销等身份权限操作。</p><p>而msp要实现组织和成员的认证、授权和撤销等操作就不可避免地需要用到加密、解密、签名与验证、哈希等方法，而这些方法则由BCCSP模块去完成。</p><h3 id="BCCSP模块"><a href="#BCCSP模块" class="headerlink" title="BCCSP模块"></a>BCCSP模块</h3><p>具体的，这些方法被bccsp模块拆分成了四类接口，分别是BCCSP接口、key接口、keystore接口、opts系列接口（一共有7个）。</p><p>其中：</p><ul><li>BCCSP接口定义了加密、解密、签名、验签和哈希等10个方法。</li><li>key接口定义了密钥管理等5个方法。</li><li>keystore接口定义了密钥存储等3个方法。</li><li>opts接口定义了主要用来返回参数密钥名称和是否需要持久化密钥（大部分没有给出实现）。</li></ul><p>关于这些接口下文会详细介绍，这里先简单了解一下即可。</p><p>为了实现这四套接口，目前有多种实现，主要包括fabric原生的pkcs11硬件加密插件和sw软件加密插件，以及我们自己实现的gm国密插件，其中sw和gm都属于软实现。</p><blockquote><p>扩展阅读：密码学通常有软实现和硬实现，软实现就是常用的各种加密库，比如Go中crypto包，硬实现是使用加密机提供的一套加密服务。软实现和硬实现的重要区别是，密码算法的安全性强依赖随机数，软实现利用的是OS的伪随机数，而硬实现利用的是加密机生成的随机数，所以硬实现的安全强度要高于软实现。</p></blockquote><h3 id="底层实现模块"><a href="#底层实现模块" class="headerlink" title="底层实现模块"></a>底层实现模块</h3><p>目前这些加密插件都需要依赖底层加密库实现。</p><ul><li>对于SW加密插件，目前底层直接依赖于 Go SDK 原生的加密库(主要是crypto包)；</li><li>对于pkcs11加密插件，目前主要依赖的是github上开源的第三方库<br><a href="https://github.com/miekg/pkcs11，" target="_blank" rel="noopener">https://github.com/miekg/pkcs11，</a> 该加密库是PKCS11 API的Go实现。它对库进行了严密的包装，但在有意义的地方使用了Go风格，它已经和SoftHSM测试过了。当然，它也可以直接上硬件加密机。</li><li>对于GM国密插件, 目前主要是利用开源的第三方国密库，比如同济的 <a href="https://github.com/tjfoc/gmsm/" target="_blank" rel="noopener">gmsm库</a><br>当然，也可以考虑直接用支持国密的加密机实现，只需要做一些接口的适配工作即可。</li></ul><h1 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a>运行流程</h1><p>刚才我们都是看的都是静态的代码，接下来我们要让代码动起来，了解一下bccsp模块在fabric运行过程中是如何发挥作用的。</p><h2 id="编辑bccsp配置项"><a href="#编辑bccsp配置项" class="headerlink" title="编辑bccsp配置项"></a>编辑bccsp配置项</h2><p>首先我们从配置文件出发：</p><p>在 sampleconfig 目录下的 core.yaml 文件中的BCCSP模块可以对加密实现和加密库进行选择和配置。</p><pre><code>    # BCCSP (Blockchain crypto provider): Select which crypto implementation or    # library to use    BCCSP:        # if setting is GM, chaincode.golang.dynamiclink must be false.        Default: SW        # Settings for the SW crypto provider (i.e. when DEFAULT: SW)        SW:            # TODO: The default Hash and Security level needs refactoring to be            # fully configurable. Changing these defaults requires coordination            # SHA2 is hardcoded in several places, not only BCCSP            Hash: SHA2            Security: 256            Library:            # Location of Key Store            FileKeyStore:                # If &quot;&quot;, defaults to &#39;mspConfigPath&#39;/keystore                KeyStore:        # Settings for the PKCS#11 crypto provider (i.e. when DEFAULT: PKCS11)        PKCS11:            # Location of the PKCS11 module library            Library:            # Token Label            Label:            # User PIN            Pin:            Hash:            Security:            FileKeyStore:                KeyStore:</code></pre><p>通过PEER_BCCSP_DEFAULT 字段可选择那种哪种加密方式，比如我们这边选择SW，那么下面就需要对SW的各个配置项进行配置</p><h2 id="加载BCCSP配置项"><a href="#加载BCCSP配置项" class="headerlink" title="加载BCCSP配置项"></a>加载BCCSP配置项</h2><p>如果我们熟悉fabric节点启动流程的话，就会知道在orderer和peer节点启动的时候会去加载orderer.yaml和peer.yanl配置文件，通过读取里面的配置文件对节点进行初始化。</p><h3 id="orderer节点初始化bccsp"><a href="#orderer节点初始化bccsp" class="headerlink" title="orderer节点初始化bccsp"></a>orderer节点初始化bccsp</h3><p>对于orderer节点来说，该节点的启动命令是orderer start，用于启动主程序的main()函数。 该函数会调用server.Main()主函数，初始化相关组件配置，其中就包括初始化msp组件。该函数位于orderer/common/server/main.go文件中。</p><pre><code>// main函数是orderer节点启动进程的入口func Main() {    ...    //加载orderer.yaml配置文件    conf, err := localconfig.Load()    ...    //初始化本地MSP组件    initializeLocalMsp(conf)    ...}</code></pre><p>它首先调用 localconfig.Load() 方法加载orderer.yaml配置文件<br>，读取其中的配置项，当然也包括bccsp配置项，读取完成后会返回一个TopLevel的实例conf</p><p>然后再由 initializeLocalMsp（conf）函数调用mspmgmt.LoadLocalMsp（）方法, 接受Orderer配置对象conf中的General通用配置输入参数，即MSP配置文件路径LocalMSPDir、BCCSP配置项与MSP名称LocalMSPID,以初始化本地MSP组件。</p><pre><code>// LoadLocalMsp loads the local MSP from the specified directory// 利用MSP配置文件、BCCSP配置项和MSPID初始化本地MSP组件func LoadLocalMsp(dir string, bccspConfig *factory.FactoryOpts, mspID string) error {    ..    conf, err := msp.GetLocalMspConfig(dir, bccspConfig, mspID)    ...}</code></pre><blockquote><p>这里值得注意的是，bccsp的配置项和orderer的其他配置项不太一样，orderer的其他配置项会调用uconf.completeInitialization()方法设置缺省的默认值，而bccsp的配置项则是在msp.GetLocalMspConfig方法中单独设置默认值的：</p></blockquote><pre><code>func GetLocalMspConfig(dir string, bccspConfig *factory.FactoryOpts, ID string) (*msp.MSPConfig, error) {    signcertDir := filepath.Join(dir, signcerts)    keystoreDir := filepath.Join(dir, keystore)    // 设置bccsp配置项缺省的默认值    bccspConfig = SetupBCCSPKeystoreConfig(bccspConfig, keystoreDir)    // 根据bccsp配置项初始化 bccsp factory    err := factory.InitFactories(bccspConfig)    if err != nil {        return nil, errors.WithMessage(err, &quot;could not initialize BCCSP Factories&quot;)    }    ...}</code></pre><p>如代码中所示，设置完缺省值之后就开始始化 bccsp factory，至此为止，就正式进入了我们的bccsp模块。</p><h3 id="peer节点初始化bccsp"><a href="#peer节点初始化bccsp" class="headerlink" title="peer节点初始化bccsp"></a>peer节点初始化bccsp</h3><p>此时我们在来看看peer节点的初始化过程。</p><p>Peer节点启动命令为peer node start,其入口主程序的main()主函数(peer/main.go)负 责初始化peer主命令对象，注册子命令与初始化环境配置，解析用户输入的子命令start并启动Peer节点。</p><pre><code>func main() {    ...    //     mainCmd.AddCommand(node.Cmd())    ...}</code></pre><p>在启动peer节点时会初始化本地MSP组件。通过Viper组件获取core.yaml文件中MSP组件的</p><ul><li>配置文件路径 mspMgrConfigDir</li><li>BCCSP 配置项 bccspConfig</li><li>MSP 名称 ID 即 localMSPID </li><li>MSP 组件类型localMSPType（默认为FABRIC类型）</li></ul><p>提供给common.InitCrypto()函数作为参数进行调用，以获取BCCSP区块链加密服务组件，并用于 初始化本地MSP组件。</p><pre><code>func InitCmd(cmd *cobra.Command, args []string) {    ...    // 初始化本地MSP组件对象    var mspMgrConfigDir = config.GetPath(&quot;peer.mspConfigPath&quot;) // 获取MSP配置文件路径    var mspID = viper.GetString(&quot;peer.localMspId&quot;) // 获取本地MSP名称，比如Org1MSP    var mspType = viper.GetString(&quot;peer.localMspType&quot;) // 获取本地MSP组件类型，这个没找到直接指定的地方    if mspType == &quot;&quot; {        // 应该是走了默认FABRIC路径        mspType = msp.ProviderTypeToString(msp.FABRIC)    }    // 利用上面的BCCSP组件配置信息，初始化MSP组件对象    err = InitCrypto(mspMgrConfigDir, mspID, mspType)    ...}</code></pre><p>其中 peer.mspConfigPath是通过 <strong>CORE_PEER_MSPCONFIGPATH</strong> 进行解析的，它<br>当前msp配置文件路径在byfn环境变量中有指定，比如peer0.org1节点的配置文件路径是</p><pre><code>CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp</code></pre><p>然后就是调用这个InitCrypto方法了</p><pre><code>// InitCrypto initializes crypto for this peer// 初始化MSP组件对象func InitCrypto(mspMgrConfigDir, localMSPID, localMSPType string) error {    ···    // 检查MSP配置文件路径是否存在    fi, err := os.Stat(mspMgrConfigDir)    // 检查localMSPID是否存在    if localMSPID == &quot;&quot; {        return errors.New(&quot;the local MSP must have an ID&quot;)    }    // 重新设置了BCCSP密钥存储文件的绝对路径 peer.BCCSP.SW.FileKeyStore.KeyStore    SetBCCSPKeystorePath()    //解析配置文件中的BCCSP配置信息并保存到bccspConfig变量    err = viperutil.EnhancedExactUnmarshalKey(&quot;peer.BCCSP&quot;, &amp;bccspConfig)    // 基于上述参数初始化本地MSP组件对象    err = mspmgmt.LoadLocalMspWithType(mspMgrConfigDir, bccspConfig, localMSPID, localMSPType)    ···}</code></pre><p>而最后这个 LoadLocalMspWithType 方法其实本质和orderer节点一样，最后也是调用GetLocalMspConfig，只不过多包了一层，判断msp的类型，是FABRIC还是IDEMIX啥的，目前默认是FABRIC</p><p>而我们上面将orderer节点的时候将过在GetLocalMspConfig方法中会初始化bccsp factory。至此，peer节点启动时调用bccsp模块的路径到此为止。</p><h3 id="节点初始化BCCSP流程图"><a href="#节点初始化BCCSP流程图" class="headerlink" title="节点初始化BCCSP流程图"></a>节点初始化BCCSP流程图</h3><p><img src="http://qlkvpxmsx.hd-bkt.clouddn.com/%E8%8A%82%E7%82%B9%E5%88%9D%E5%A7%8B%E5%8C%96bccsp.png" alt></p><h5 id="此外，启动客户端和实例化链码的时候应该也会初始化这个bccsp组件，这里先略了，下次补上～"><a href="#此外，启动客户端和实例化链码的时候应该也会初始化这个bccsp组件，这里先略了，下次补上～" class="headerlink" title="此外，启动客户端和实例化链码的时候应该也会初始化这个bccsp组件，这里先略了，下次补上～"></a>此外，启动客户端和实例化链码的时候应该也会初始化这个bccsp组件，这里先略了，下次补上～</h5><h1 id="接口及其实现（以SW为例）"><a href="#接口及其实现（以SW为例）" class="headerlink" title="接口及其实现（以SW为例）"></a>接口及其实现（以SW为例）</h1><p>上一节通过分析peer和orderer节点的启动流程知道了节点启动时是如何调用bccsp模块的，最终都会调用这个bccsp模块InitFactories初始化一个bccsp对象。那么这里就从这个InitFactories方法说起，介绍一下BCCSP模块内部是怎么玩的。</p><p><img src="http://qlkvpxmsx.hd-bkt.clouddn.com/%E5%88%9D%E5%A7%8B%E5%8C%96bccsp.png" alt></p><p>如图所示，initFactories会根据传入的config.opts这个字段判断创建SWFactory、GMFactory、PKCS11Factory以及PluginFactory对象，然后调用initBCCSP构造全局默认的BCCSP对象defaultBCCSP，而这个initBCCSP方法实际上是调用了BCCSPFactory接口下的Get方法创建一个BCCSP工厂对象实例的，这里就讲到了我们的第一套接口BCCSPFactory。</p><h2 id="BCCSPFactory接口"><a href="#BCCSPFactory接口" class="headerlink" title="BCCSPFactory接口"></a>BCCSPFactory接口</h2><p>BCCSPFactory接口主要用于构造一个BCCSP实例，它包含 Name 和 Get 两个方法。</p><pre><code>// BCCSPFactory is used to get instances of the BCCSP interface.// A Factory has name used to address it.// 根据 FactoryOpts 构建一个BCCSP实例type BCCSPFactory interface {    // Name returns the name of this factory    Name() string    // Get returns an instance of BCCSP using opts.    Get(opts *FactoryOpts) (bccsp.BCCSP, error)}</code></pre><h3 id="sw实现"><a href="#sw实现" class="headerlink" title="sw实现"></a>sw实现</h3><ul><li><h4 id="Name方法"><a href="#Name方法" class="headerlink" title="Name方法"></a>Name方法</h4></li></ul><pre><code>const (    SoftwareBasedFactoryName = &quot;SW&quot;)func (f *SWFactory) Name() string {    // 直接返回工厂类型的名字&quot;SW&quot;    return SoftwareBasedFactoryName}</code></pre><ul><li><h4 id="Get方法"><a href="#Get方法" class="headerlink" title="Get方法"></a>Get方法</h4></li></ul><pre><code>// 根据FactoryOpts构建一个BCCSP实例func (f *SWFactory) Get(config *FactoryOpts) (bccsp.BCCSP, error) {    // 验证参数是否为空    if config == nil || config.SwOpts == nil {        return nil, errors.New(&quot;Invalid config. It must not be nil.&quot;)    }    swOpts := config.SwOpts    var ks bccsp.KeyStore    // 如果Ephemeral字段为true，说明是一个临时密钥    if swOpts.Ephemeral == true {        // 实例化一个既不加载也不存储密钥的虚拟密钥对象        ks = sw.NewDummyKeyStore()    } else if swOpts.FileKeystore != nil {        // 如果非临时密钥，而且FileKeystore字段不为空，则实例化一个存储于文件夹中的密钥对象        fks, err := sw.NewFileBasedKeyStore(nil, swOpts.FileKeystore.KeyStorePath, false)        if err != nil {            return nil, errors.Wrapf(err, &quot;Failed to initialize software key store&quot;)        }        ks = fks    } else if swOpts.InmemKeystore != nil {        // 如果FileKeystore字段为空，实例化一个暂时存储在内存中的密钥对象        ks = sw.NewInMemoryKeyStore()    } else {        // 如果Ephemeral字段为false，但FileKeystore字段也为空，        // 那么也是默认实例化一个临时虚拟密钥存储类型        ks = sw.NewDummyKeyStore()    }    // 根据传入参数创建一个软实现的标准加密类型bccsp实例对象(sw.csp类型)    return sw.NewWithParams(swOpts.SecLevel, swOpts.HashFamily, ks)}</code></pre><p>细心的听众可能已经注意到在Get方法中调用了sw.NewDummyKeyStore方法和sw.New方法，那这两个方法又是如何实现的呢，这就涉及到我们接下来要讲的KeyStore接口和BCCSP接口了。</p><h2 id="KeyStore接口"><a href="#KeyStore接口" class="headerlink" title="KeyStore接口"></a>KeyStore接口</h2><p>KeyStore接口主要用于实现对加密密钥实例bccsp.key对象的存储和检索。它具体包含三个方法，ReadOnly、GetKey和StoreKey。</p><pre><code>type KeyStore interface {    // 返回是否是只读类型的key    ReadOnly() bool    // 根据传入的ski返回key对象    GetKey(ski []byte) (k Key, err error)    // 存储key    StoreKey(k Key) (err error)}</code></pre><h3 id="sw实现-1"><a href="#sw实现-1" class="headerlink" title="sw实现"></a>sw实现</h3><ul><li><h4 id="ReadOnly方法"><a href="#ReadOnly方法" class="headerlink" title="ReadOnly方法"></a>ReadOnly方法</h4></li></ul><pre><code>// 返回readOnly字段func (ks *fileBasedKeyStore) ReadOnly() bool {    return ks.readOnly}</code></pre><ul><li><h4 id="GetKey方法"><a href="#GetKey方法" class="headerlink" title="GetKey方法"></a>GetKey方法</h4></li></ul><pre><code>// 根据传入的ski返回key对象func (ks *fileBasedKeyStore) GetKey(ski []byte) (bccsp.Key, error) {    // 验证ski不为空    if len(ski) == 0 {        return nil, errors.New(&quot;Invalid SKI. Cannot be of zero length.&quot;)    }    // 取ski的后缀    suffix := ks.getSuffix(hex.EncodeToString(ski))    // 如果后缀是key，则    switch suffix {    case &quot;key&quot;:        // 加载AES对称密钥        key, err := ks.loadKey(hex.EncodeToString(ski))        if err != nil {            return nil, fmt.Errorf(&quot;Failed loading key [%x] [%s]&quot;, ski, err)        }        return &amp;aesPrivateKey{key, false}, nil    case &quot;sk&quot;:        // 加载私钥        key, err := ks.loadPrivateKey(hex.EncodeToString(ski))        if err != nil {            return nil, fmt.Errorf(&quot;Failed loading secret key [%x] [%s]&quot;, ski, err)        }        switch key.(type) {        case *ecdsa.PrivateKey:            return &amp;ecdsaPrivateKey{key.(*ecdsa.PrivateKey)}, nil        case *rsa.PrivateKey:            return &amp;rsaPrivateKey{key.(*rsa.PrivateKey)}, nil        default:            return nil, errors.New(&quot;Secret key type not recognized&quot;)        }    case &quot;pk&quot;:        // 加载公钥        key, err := ks.loadPublicKey(hex.EncodeToString(ski))        if err != nil {            return nil, fmt.Errorf(&quot;Failed loading public key [%x] [%s]&quot;, ski, err)        }        switch key.(type) {        case *ecdsa.PublicKey:            return &amp;ecdsaPublicKey{key.(*ecdsa.PublicKey)}, nil        case *rsa.PublicKey:            return &amp;rsaPublicKey{key.(*rsa.PublicKey)}, nil        default:            return nil, errors.New(&quot;Public key type not recognized&quot;)        }    // 如果后缀缀都不符合，则直接去keystore的路径下遍历并解析所有密钥文件，搜索其中和传入的ski相匹配的密钥    default:        return ks.searchKeystoreForSKI(ski)    }}</code></pre><ul><li><h3 id="StoreKey方法"><a href="#StoreKey方法" class="headerlink" title="StoreKey方法"></a>StoreKey方法</h3></li></ul><pre><code>// 将密钥存储在当前keystore中func (ks *fileBasedKeyStore) StoreKey(k bccsp.Key) (err error) {    // 只读类型的keystore不能存储密钥    if ks.readOnly {        return errors.New(&quot;Read only KeyStore.&quot;)    }    // 存储的密钥不能为空    if k == nil {        return errors.New(&quot;Invalid key. It must be different from nil.&quot;)    }    switch k.(type) {    // 存储ecdsa私钥    case *ecdsaPrivateKey:        kk := k.(*ecdsaPrivateKey)        err = ks.storePrivateKey(hex.EncodeToString(k.SKI()), kk.privKey)        if err != nil {            return fmt.Errorf(&quot;Failed storing ECDSA private key [%s]&quot;, err)        }    // 存储ecdsa公钥    case *ecdsaPublicKey:        kk := k.(*ecdsaPublicKey)        err = ks.storePublicKey(hex.EncodeToString(k.SKI()), kk.pubKey)        if err != nil {            return fmt.Errorf(&quot;Failed storing ECDSA public key [%s]&quot;, err)        }    // 存储rsa私钥    case *rsaPrivateKey:        kk := k.(*rsaPrivateKey)        err = ks.storePrivateKey(hex.EncodeToString(k.SKI()), kk.privKey)        if err != nil {            return fmt.Errorf(&quot;Failed storing RSA private key [%s]&quot;, err)        }    // 存储rsa公钥    case *rsaPublicKey:        kk := k.(*rsaPublicKey)        err = ks.storePublicKey(hex.EncodeToString(k.SKI()), kk.pubKey)        if err != nil {            return fmt.Errorf(&quot;Failed storing RSA public key [%s]&quot;, err)        }    // 存储aes对称密钥    case *aesPrivateKey:        kk := k.(*aesPrivateKey)        err = ks.storeKey(hex.EncodeToString(k.SKI()), kk.privKey)        if err != nil {            return fmt.Errorf(&quot;Failed storing AES key [%s]&quot;, err)        }    default:        return fmt.Errorf(&quot;Key type not reconigned [%s]&quot;, k)    }    return}</code></pre><blockquote><p>存储密钥其实就是将密钥对象通过x509序列化以及pem编码后写入磁盘文件保存，而读取密钥则是其反向操作，即从文件中读出编码后的密钥，然后使用PEM解码和X509反序列化解析出密钥对象。</p></blockquote><h2 id="BCCSP接口"><a href="#BCCSP接口" class="headerlink" title="BCCSP接口"></a>BCCSP接口</h2><p>BCCSP接口是BCCSP模块中最核心的接口，主要用于实现密钥生成、派生、签名和验签、加密和解密以及哈希等方法。具体如下。</p><pre><code>// 主要用于实现密钥生成、派生、签名和验签、加密和解密以及哈希等方法type BCCSP interface {    // 根据参数opts的值生成对应类型的密钥    KeyGen(opts KeyGenOpts) (k Key, err error)    // 根据密钥k和参数opts，派生出新的密钥    KeyDeriv(k Key, opts KeyDerivOpts) (dk Key, err error)    // 根据指定的opts从raw中导出对应类型的密钥实例    KeyImport(raw interface{}, opts KeyImportOpts) (k Key, err error)    // 根据指定的ski获取密钥    GetKey(ski []byte) (k Key, err error)    // 获取数据的摘要    Hash(msg []byte, opts HashOpts) (hash []byte, err error)    // 根据opts指定的类型获得对应的哈希方法    GetHash(opts HashOpts) (h hash.Hash, err error)    // 利用非对称密钥k对数据摘要进行签名    Sign(k Key, digest []byte, opts SignerOpts) (signature []byte, err error)    // 利用非对称密钥对数据摘要进行验签    Verify(k Key, signature, digest []byte, opts SignerOpts) (valid bool, err error)    // 利用密钥对数据进行加密    Encrypt(k Key, plaintext []byte, opts EncrypterOpts) (ciphertext []byte, err error)    // 利用密钥对数据进行解密    Decrypt(k Key, ciphertext []byte, opts DecrypterOpts) (plaintext []byte, err error)}</code></pre><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><ul><li><h4 id="SW-Wrapper"><a href="#SW-Wrapper" class="headerlink" title="SW/Wrapper"></a>SW/Wrapper</h4></li></ul><p>SW用于实现这个BCCSP接口的实例叫做CSP，定义如下:</p><pre><code>type CSP struct {    ks bccsp.KeyStore    KeyGenerators map[reflect.Type]KeyGenerator    KeyDerivers   map[reflect.Type]KeyDeriver    KeyImporters  map[reflect.Type]KeyImporter    Encryptors    map[reflect.Type]Encryptor    Decryptors    map[reflect.Type]Decryptor    Signers       map[reflect.Type]Signer    Verifiers     map[reflect.Type]Verifier    Hashers       map[reflect.Type]Hasher}</code></pre><p>这个CSP实际上是一个基于wrappers的BCCSP接口的实现。它其实就是做了一个分类，将BCCSP要实现的那些方法分成这几类：<br>KeyGenerator、KeyDeriver、KeyImporter、Encryptor、Decryptor、Signer、Verifier、Hasher。</p><p><img src="http://qlkvpxmsx.hd-bkt.clouddn.com/BCCSP%E6%8E%A5%E5%8F%A3.png" alt></p><p>然后每一类实际上是一个map，这个map的键是类型，值是一个实例，这样就可以根据传入的参数选择对应的具体算法实现，比如往KeyGenerators这个map传入一个ecdsa类型的参数，那么就会去调用ecdsa的密钥生成方法了，废话不多说了，直接看源码。</p><ul><li><h4 id="KeyGen方法"><a href="#KeyGen方法" class="headerlink" title="KeyGen方法"></a>KeyGen方法</h4></li></ul><pre><code>// 根据参数opts的值生成对应类型的密钥func (csp *CSP) KeyGen(opts bccsp.KeyGenOpts) (k bccsp.Key, err error) {    // 验证opts不为空    if opts == nil {        return nil, errors.New(&quot;Invalid Opts parameter. It must not be nil.&quot;)    }    // 根据传入的参数opts获取相应的KeyGenerator实例（aesKeyGenerator,rsaKeyGenerator,ecdsaKeyGenerator）    keyGenerator, found := csp.KeyGenerators[reflect.TypeOf(opts)]    if !found {        return nil, errors.Errorf(&quot;Unsupported &#39;KeyGenOpts&#39; provided [%v]&quot;, opts)    }    // 调用密钥生成方法生成密钥    k, err = keyGenerator.KeyGen(opts)    if err != nil {        return nil, errors.Wrapf(err, &quot;Failed generating key with opts [%v]&quot;, opts)    }    // 如果密钥的Ephemeral字段为false，则调用StoreKey存储密钥    if !opts.Ephemeral() {        err = csp.ks.StoreKey(k)        if err != nil {            return nil, errors.Wrapf(err, &quot;Failed storing key [%s]&quot;, opts.Algorithm())        }    }    return k, nil}</code></pre><ul><li><h4 id="KeyDeriv方法"><a href="#KeyDeriv方法" class="headerlink" title="KeyDeriv方法"></a>KeyDeriv方法</h4></li></ul><pre><code>// 根据密钥k和参数opts，派生出新的密钥，该方法目前只在idemix中会用到func (csp *CSP) KeyDeriv(k bccsp.Key, opts bccsp.KeyDerivOpts) (dk bccsp.Key, err error) {    //  验证传入的密钥不为空    if k == nil {        return nil, errors.New(&quot;Invalid Key. It must not be nil.&quot;)    }    // 验证传入的opts不为空    if opts == nil {        return nil, errors.New(&quot;Invalid opts. It must not be nil.&quot;)    }    // 根据传入的密钥k获取相应的KeyDeriver实例    // （ecdsaPublicKeyKeyDeriver,ecdsaPrivateKeyKeyDeriver,aesPrivateKeyKeyDeriver）    keyDeriver, found := csp.KeyDerivers[reflect.TypeOf(k)]    if !found {        return nil, errors.Errorf(&quot;Unsupported &#39;Key&#39; provided [%v]&quot;, k)    }    // 调用KeyDerive方法生成密钥（生成一个和传入密钥相同类型的密钥）    k, err = keyDeriver.KeyDeriv(k, opts)    if err != nil {        return nil, errors.Wrapf(err, &quot;Failed deriving key with opts [%v]&quot;, opts)    }    // 如果opts的Ephemeral字段为false，则调用StoreKey存储密钥    if !opts.Ephemeral() {        err = csp.ks.StoreKey(k)        if err != nil {            return nil, errors.Wrapf(err, &quot;Failed storing key [%s]&quot;, opts.Algorithm())        }    }    return k, nil}</code></pre><ul><li><h4 id="KeyImport方法"><a href="#KeyImport方法" class="headerlink" title="KeyImport方法"></a>KeyImport方法</h4></li></ul><pre><code>// 根据指定的opts从raw中导出对应类型的密钥实例func (csp *CSP) KeyImport(raw interface{}, opts bccsp.KeyImportOpts) (k bccsp.Key, err error) {    // 验证raw不为空    if raw == nil {        return nil, errors.New(&quot;Invalid raw. It must not be nil.&quot;)    }    //验证opts不为空    if opts == nil {        return nil, errors.New(&quot;Invalid opts. It must not be nil.&quot;)    }    // 根据传入的密钥k获取相应的KeyImporter实例    // aes256ImportKeyOptsKeyImporter    // hmacImportKeyOptsKeyImporter    // ecdsaPKIXPublicKeyImportOptsKeyImporter    // ecdsaPrivateKeyImportOptsKeyImporter    // ecdsaGoPublicKeyImportOptsKeyImporter    // rsaGoPublicKeyImportOptsKeyImporter    // x509PublicKeyImportOptsKeyImporter    keyImporter, found := csp.KeyImporters[reflect.TypeOf(opts)]    if !found {        return nil, errors.Errorf(&quot;Unsupported &#39;KeyImportOpts&#39; provided [%v]&quot;, opts)    }    // 调用KeyImport方法导入密钥    k, err = keyImporter.KeyImport(raw, opts)    if err != nil {        return nil, errors.Wrapf(err, &quot;Failed importing key with opts [%v]&quot;, opts)    }    // 如果opts的Ephemeral字段为false，则调用StoreKey存储密钥    if !opts.Ephemeral() {        err = csp.ks.StoreKey(k)        if err != nil {            return nil, errors.Wrapf(err, &quot;Failed storing imported key with opts [%v]&quot;, opts)        }    }    return}</code></pre><ul><li><h4 id="GetKey方法-1"><a href="#GetKey方法-1" class="headerlink" title="GetKey方法"></a>GetKey方法</h4></li></ul><pre><code>// 根据指定的ski获取当前BCCSP实例中存储的对应密钥func (csp *CSP) GetKey(ski []byte) (k bccsp.Key, err error) {    k, err = csp.ks.GetKey(ski)    if err != nil {        return nil, errors.Wrapf(err, &quot;Failed getting key for SKI [%v]&quot;, ski)    }    return}</code></pre><ul><li><h4 id="Hash方法"><a href="#Hash方法" class="headerlink" title="Hash方法"></a>Hash方法</h4></li></ul><pre><code>// 获取数据摘要func (csp *CSP) Hash(msg []byte, opts bccsp.HashOpts) (digest []byte, err error) {    // 验证opts参数不为空    if opts == nil {        return nil, errors.New(&quot;Invalid opts. It must not be nil.&quot;)    }    // 根据传入的参数opts获取相应的Hasher实例    hasher, found := csp.Hashers[reflect.TypeOf(opts)]    if !found {        return nil, errors.Errorf(&quot;Unsupported &#39;HashOpt&#39; provided [%v]&quot;, opts)    }    // 调用hash方法生成摘要    digest, err = hasher.Hash(msg, opts)    if err != nil {        return nil, errors.Wrapf(err, &quot;Failed hashing with opts [%v]&quot;, opts)    }    returni}</code></pre><ul><li><h4 id="GetHash方法"><a href="#GetHash方法" class="headerlink" title="GetHash方法"></a>GetHash方法</h4></li></ul><pre><code>// 根据opts指定的类型获得对应的哈希方法func (csp *CSP) GetHash(opts bccsp.HashOpts) (h hash.Hash, err error) {    // 验证opts参数不为空    if opts == nil {        return nil, errors.New(&quot;Invalid opts. It must not be nil.&quot;)    }    // 根据传入的参数opts获取相应的Hasher实例    hasher, found := csp.Hashers[reflect.TypeOf(opts)]    if !found {        return nil, errors.Errorf(&quot;Unsupported &#39;HashOpt&#39; provided [%v]&quot;, opts)    }    // 返回hash方法    h, err = hasher.GetHash(opts)    if err != nil {        return nil, errors.Wrapf(err, &quot;Failed getting hash function with opts [%v]&quot;, opts)    }    return}</code></pre><ul><li><h4 id="Sign方法"><a href="#Sign方法" class="headerlink" title="Sign方法"></a>Sign方法</h4></li></ul><pre><code>// 利用非对称密钥k对数据摘要进行签名func (csp *CSP) Sign(k bccsp.Key, digest []byte, opts bccsp.SignerOpts) (signature []byte, err error) {    // 验证私钥不为空    if k == nil {        return nil, errors.New(&quot;Invalid Key. It must not be nil.&quot;)    }    // 验证摘要内容不为空    if len(digest) == 0 {        return nil, errors.New(&quot;Invalid digest. Cannot be empty.&quot;)    }    // 根据传入的密钥k获取相应的signer实例    keyType := reflect.TypeOf(k)    signer, found := csp.Signers[keyType]    if !found {        return nil, errors.Errorf(&quot;Unsupported &#39;SignKey&#39; provided [%s]&quot;, keyType)    }    // 调用signer签名方法进行签名，值得注意的是，这个opts在ecdsa中没有用到    // ecdsaSigner, rsaSigner    signature, err = signer.Sign(k, digest, opts)    if err != nil {        return nil, errors.Wrapf(err, &quot;Failed signing with opts [%v]&quot;, opts)    }    return}</code></pre><ul><li><h4 id="Verify"><a href="#Verify" class="headerlink" title="Verify"></a>Verify</h4></li></ul><pre><code>// 利用非对称密钥对数据摘要进行验签func (csp *CSP) Verify(k bccsp.Key, signature, digest []byte, opts bccsp.SignerOpts) (valid bool, err error) {    // 验证传入公钥不为空    if k == nil {        return false, errors.New(&quot;Invalid Key. It must not be nil.&quot;)    }    // 验证签名不为空    if len(signature) == 0 {        return false, errors.New(&quot;Invalid signature. Cannot be empty.&quot;)    }    // 验证摘要不为空    if len(digest) == 0 {        return false, errors.New(&quot;Invalid digest. Cannot be empty.&quot;)    }    // 根据传入的密钥k获取相应的Verifier实例    // ecdsa、rsa 值得注意的是，如果这里传入的是私钥，则会根据私钥导出公钥再作验证    verifier, found := csp.Verifiers[reflect.TypeOf(k)]    if !found {        return false, errors.Errorf(&quot;Unsupported &#39;VerifyKey&#39; provided [%v]&quot;, k)    }    // 调用verify方法进行验签    valid, err = verifier.Verify(k, signature, digest, opts)    if err != nil {        return false, errors.Wrapf(err, &quot;Failed verifing with opts [%v]&quot;, opts)    }    return}</code></pre><ul><li><h4 id="Encrypt"><a href="#Encrypt" class="headerlink" title="Encrypt"></a>Encrypt</h4></li></ul><pre><code>// 利用密钥对数据进行加密func (csp *CSP) Encrypt(k bccsp.Key, plaintext []byte, opts bccsp.EncrypterOpts) ([]byte, error) {    // 验证加密密钥不为空    if k == nil {        return nil, errors.New(&quot;Invalid Key. It must not be nil.&quot;)    }    // 根据传入的密钥k获取相应的Encryptor实例，目前只支持aes    encryptor, found := csp.Encryptors[reflect.TypeOf(k)]    if !found {        return nil, errors.Errorf(&quot;Unsupported &#39;EncryptKey&#39; provided [%v]&quot;, k)    }    // 调用Encrypt方法进行加密    return encryptor.Encrypt(k, plaintext, opts)}</code></pre><ul><li><h4 id="Decrypt"><a href="#Decrypt" class="headerlink" title="Decrypt"></a>Decrypt</h4></li></ul><pre><code>// 利用密钥对数据进行加密func (csp *CSP) Encrypt(k bccsp.Key, plaintext []byte, opts bccsp.EncrypterOpts) ([]byte, error) {    // 验证加密密钥不为空    if k == nil {        return nil, errors.New(&quot;Invalid Key. It must not be nil.&quot;)    }    // 根据传入的密钥k获取相应的Encryptor实例，目前只支持aes    encryptor, found := csp.Encryptors[reflect.TypeOf(k)]    if !found {        return nil, errors.Errorf(&quot;Unsupported &#39;EncryptKey&#39; provided [%v]&quot;, k)    }    // 调用Encrypt方法进行加密    return encryptor.Encrypt(k, plaintext, opts)}</code></pre><h2 id="Key接口"><a href="#Key接口" class="headerlink" title="Key接口"></a>Key接口</h2><p>KeyStore接口主要用于实现对密钥管理，它具体包含如下方法：</p><pre><code>// key接口主要用于密钥管理type Key interface {    // 将密钥key转成bytes格式    Bytes() ([]byte, error)    // 返回密钥的key的ski    SKI() []byte    // 是否是对称加密密钥    Symmetric() bool    // 是否是私钥    Private() bool    // 返回该密钥的公钥    PublicKey() (Key, error)}</code></pre><h3 id="sw实现-2"><a href="#sw实现-2" class="headerlink" title="sw实现"></a>sw实现</h3><ul><li><h4 id="Bytes方法"><a href="#Bytes方法" class="headerlink" title="Bytes方法"></a>Bytes方法</h4></li></ul><pre><code>// 将ecdsa的公钥转成bytes形式func (k *ecdsaPublicKey) Bytes() (raw []byte, err error) {    // 调用go sdk的x509包中的方法    raw, err = x509.MarshalPKIXPublicKey(k.pubKey)    if err != nil {        return nil, fmt.Errorf(&quot;Failed marshalling key [%s]&quot;, err)    }    return}</code></pre><p>值得注意的是，对于rsa和ecdsa的私钥是不支持转成Bytes操作的，如果直接调用这个方法，会返回err</p><ul><li><h4 id="SKI方法"><a href="#SKI方法" class="headerlink" title="SKI方法"></a>SKI方法</h4></li></ul><pre><code>// 返回ecdsa公钥的skifunc (k *ecdsaPublicKey) SKI() []byte {    // 检查密钥是否为空    if k.pubKey == nil {        return nil    }    // 序列化公钥，调用go sdk的elliptic包的Marshal方法序（将一个点转化成未压缩形式）    raw := elliptic.Marshal(k.pubKey.Curve, k.pubKey.X, k.pubKey.Y)    // 将结果用sha256做哈希    hash := sha256.New()    hash.Write(raw)    return hash.Sum(nil)}</code></pre><ul><li><h4 id="Symmetric方法"><a href="#Symmetric方法" class="headerlink" title="Symmetric方法"></a>Symmetric方法</h4></li></ul><pre><code>// 返回是否是对称密钥func (k *aesPrivateKey) Symmetric() bool {    return true}</code></pre><p>只有aes返回true，rsa和ecdsa均返回false</p><ul><li><h4 id="Private方法"><a href="#Private方法" class="headerlink" title="Private方法"></a>Private方法</h4></li></ul><pre><code>// 返回是否是私钥func (k *ecdsaPrivateKey) Private() bool {    return true}</code></pre><h2 id="opts系列接口"><a href="#opts系列接口" class="headerlink" title="opts系列接口"></a>opts系列接口</h2><p>KeyStore接口主要用于实现对密钥管理，它具体包含如下方法：</p><pre><code>// 主要用来提供生成密钥的参数type KeyGenOpts interface {    Algorithm() string    Ephemeral() bool}// 主要用来从一个Key实例派生出另一个Key实例type KeyDerivOpts interface {    Algorithm() string    Ephemeral() bool}// 主要用来在密钥导入时生成参数type KeyImportOpts interface {    Algorithm() string    Ephemeral() bool}// 为hash方法提供参数选择type HashOpts interface {    Algorithm() string}// 为签名方法提供参数选择type SignerOpts interface {    crypto.SignerOpts}// 无方法，可以根据需要定义加密参数type EncrypterOpts interface{}// 无方法，可以根据需要定义加密参数type DecrypterOpts interface{}</code></pre><h3 id="sw实现-3"><a href="#sw实现-3" class="headerlink" title="sw实现"></a>sw实现</h3><ul><li><h4 id="Algorithm方法"><a href="#Algorithm方法" class="headerlink" title="Algorithm方法"></a>Algorithm方法</h4></li></ul><pre><code>func (opts *ECDSAKeyGenOpts) Algorithm() string {    return ECDSA}</code></pre><ul><li><h4 id="Ephemeral方法"><a href="#Ephemeral方法" class="headerlink" title="Ephemeral方法"></a>Ephemeral方法</h4></li></ul><pre><code>func (opts *ECDSAKeyGenOpts) Ephemeral() bool {    return opts.Temporary}</code></pre><ul><li><h4 id="HashOpts方法"><a href="#HashOpts方法" class="headerlink" title="HashOpts方法"></a>HashOpts方法</h4></li></ul><pre><code>func (opts *ECDSAKeyGenOpts) Ephemeral() bool {    return opts.Temporary}</code></pre><h2 id="接口调用关系图"><a href="#接口调用关系图" class="headerlink" title="接口调用关系图"></a>接口调用关系图</h2><h1 id="GM插件"><a href="#GM插件" class="headerlink" title="GM插件"></a>GM插件</h1><p>至于国密GM插件的实现其实与SW插件类似，基本也是仿照SW插件改造出来的，只不过中间封装了一层sm2、sm3和sm4接口:</p><pre><code>type Sm2 interface {    // 创建私钥    GenerateKey() (*crypto.PrivateKey, error)    // 数字签名和验证    Sign(priv *crypto.PrivateKey, rand io.Reader, digest []byte, opts gocrypto.SignerOpts) ([]byte, error)    Verify(pub *crypto.PublicKey, digest []byte, sign []byte) bool    // 非对称加密和解密    Encrypt(pub *crypto.PublicKey, msg []byte) ([]byte, error)    Decrypt(priv *crypto.PrivateKey, ciphertext []byte) ([]byte, error)    // 公钥和私钥的保存与加载    SavePrivateKeytoPem(fileName string, key *crypto.PrivateKey, pwd []byte) (bool, error)    LoadPrivateKeyFromPem(fileName string, pwd []byte) (*crypto.PrivateKey, error)    SavePublicKeytoPem(fileName string, key *crypto.PublicKey, _ []byte) (bool, error)    LoadPublicKeyFromPem(fileName string, pwd []byte) (*crypto.PublicKey, error)}type Sm3 interface {    // 创建符合Hash接口的sm3实例    New() hash.Hash    // 使用sm3计算数据的摘要    Sum(data []byte) []byte}type Sm4 interface {    // 创建符合Block接口的sm4实例    NewCipher(key []byte) (cipher.Block, error)    // 使用对称密钥加密和解密    Encrypt(key []byte, dst, src []byte)    Decrypt(key []byte, dst, src []byte)    // 密钥保存和加载    SaveKeyToPem(fileName string, key []byte, pwd []byte) (bool, error)    LoadKeyFromPem(fileName string, pwd []byte) ([]byte, error)}</code></pre><p>通过将国密算法需要实现的BCCSP模块中的接口整理了一下，归纳成sm2、sm3、sm4这三套接口，这样就使得国密插件的具体实现与BCCSP模块进行了解耦。理论上我们只需要实现这三套接口，就可以实现一个新的国密插件。之所以这样设计，是因为目前底层国密的加密库目前有多个选择，这样就使得国密插件的实现更灵活，可以更方便的引入和适配新的底层国密库。</p><p>具体国密插件的实现可参考 <a href="https://blog.csdn.net/weixin_39066447/article/details/111468172" target="_blank" rel="noopener">fabric国密改造</a></p><h1 id="pkcs11插件"><a href="#pkcs11插件" class="headerlink" title="pkcs11插件"></a>pkcs11插件</h1><p>1.4版本的pkcs11实现有较多的TODO以及FIXME，并不完善</p><p>通过对比pkcs11的factoryOpts和SW的factoryOpts，我们发现</p><pre><code>type FactoryOpts struct {    //     ProviderName string      `mapstructure:&quot;default&quot; json:&quot;default&quot; yaml:&quot;Default&quot;`    SwOpts       *SwOpts     `mapstructure:&quot;SW,omitempty&quot; json:&quot;SW,omitempty&quot; yaml:&quot;SwOpts&quot;`    PluginOpts   *PluginOpts `mapstructure:&quot;PLUGIN,omitempty&quot; json:&quot;PLUGIN,omitempty&quot; yaml:&quot;PluginOpts&quot;`}</code></pre><pre><code>type FactoryOpts struct {    ProviderName string             `mapstructure:&quot;default&quot; json:&quot;default&quot; yaml:&quot;Default&quot;`    SwOpts       *SwOpts            `mapstructure:&quot;SW,omitempty&quot; json:&quot;SW,omitempty&quot; yaml:&quot;SwOpts&quot;`    PluginOpts   *PluginOpts        `mapstructure:&quot;PLUGIN,omitempty&quot; json:&quot;PLUGIN,omitempty&quot; yaml:&quot;PluginOpts&quot;`    Pkcs11Opts   *pkcs11.PKCS11Opts `mapstructure:&quot;PKCS11,omitempty&quot; json:&quot;PKCS11,omitempty&quot; yaml:&quot;PKCS11&quot;`}</code></pre><p>可以发现pkcs11的FactoryOpts主要是多了Pkcs11Opts这个字段，而在这个字段中定义了library、label、pin这几个值，如果大家还有印象的话应该记得在加载配置文件core.yaml的时候pkcs11那里其实是有这些字段的。</p><pre><code>PKCS11:    # Location of the PKCS11 module library    Library: /usr/lib/softhsm/libsofthsm2.so     #/etc/hyperledger/fabric/libsofthsm2.so    # Token Label    Label: ForFabric    # User PIN    Pin: &quot;98765432&quot;    Hash: SHA2    Security: 256</code></pre><p>而查看和pkcs11的bccsp实例，我们会发现</p><pre><code>type impl struct {    // sw的bccsp实例    bccsp.BCCSP    conf *config    ks   bccsp.KeyStore    ctx      *pkcs11.Ctx    sessions chan pkcs11.SessionHandle    slot     uint    lib        string    softVerify bool    //Immutable flag makes object immutable    immutable bool}</code></pre><p>实际上pkcs11的实例中是包含了一个sw的bccsp实例的，这一点在new一个BCCSP实例的时候也得到了验证</p><pre><code>func New(opts PKCS11Opts, keyStore bccsp.KeyStore) (bccsp.BCCSP, error) {    ...    // 调用了sw的NewWithParams方法new了一个sw的bccsp实例    swCSP, err := sw.NewWithParams(opts.SecLevel, opts.HashFamily, keyStore)    if err != nil {        return nil, errors.Wrapf(err, &quot;Failed initializing fallback SW BCCSP&quot;)    }    lib := opts.Library    pin := opts.Pin    label := opts.Label    ...    sessions := make(chan pkcs11.SessionHandle, sessionCacheSize)    // 最后返回的bccsp实例包含了一个sw的bccsp的实例    csp := &amp;impl{swCSP, conf, keyStore, ctx, sessions, slot, lib, opts.SoftVerify, opts.Immutable}    return csp, nil}</code></pre><p>而pkcs11插件在实现bccsp接口的时候也多次调用了内部包含sw bccsp对应的方法。</p><p>就比如bccsp接口中的KeyGen方法</p><pre><code>func (csp *impl) KeyGen(opts bccsp.KeyGenOpts) (k bccsp.Key, err error) {    switch opts.(type) {    case *bccsp.ECDSAKeyGenOpts:        ski, pub, err := csp.generateECKey(csp.conf.ellipticCurve, opts.Ephemeral())        ···    case *bccsp.ECDSAP256KeyGenOpts:        ski, pub, err := csp.generateECKey(oidNamedCurveP256, opts.Ephemeral())        ···    case *bccsp.ECDSAP384KeyGenOpts:        ski, pub, err := csp.generateECKey(oidNamedCurveP384, opts.Ephemeral())        ···    default:        return csp.BCCSP.KeyGen(opts)    }    return k, nil}</code></pre><p>我们可以发现它都是先走自己单独的生成密钥的那套方法，走不通时再去调SW的KeyGen方法。而进一步分析发现，其实pkcs11自己的那套密钥生成方法也是一层接口封装，底层其实用的是开源的一套pkcs11标准实现加密库 <a href="https://github.com/miekg/pkcs11" target="_blank" rel="noopener">https://github.com/miekg/pkcs11</a> ，这个库是pkcs11的Go语言实现，它实现了pkcs11标准规定的那些接口，而且已经通过和SoftHSM的测试，当然底层也可以用硬件加密机实现。</p><p><img src="http://qlkvpxmsx.hd-bkt.clouddn.com/pkcs11%E7%9A%84BCCSP%E5%AE%9E%E7%8E%B0.png" alt></p><p>值得注意的是，pkcs11由于是采用硬件加密，因此它的密钥是保存在硬件加密模块中的，所以它并没有实现keystore密钥存储接口，同时，它也不会通过软件实现密钥生成、密钥派生以及密钥导入等场景，所以也就不支持opts系列接口，这一点和SW以及GM都不太一样。</p><h1 id="idemix插件"><a href="#idemix插件" class="headerlink" title="idemix插件"></a>idemix插件</h1><p>和零知识证明有关</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="http://qlkvpxmsx.hd-bkt.clouddn.com/BCCSP%E6%A8%A1%E5%9D%97%E6%80%BB%E7%BB%93.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> fabric </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
            <tag> fabric </tag>
            
            <tag> bccsp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Go特性5】锁和条件变量</title>
      <link href="/2020/12/25/go-feature-lock/"/>
      <url>/2020/12/25/go-feature-lock/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是锁？"><a href="#什么是锁？" class="headerlink" title="什么是锁？"></a>什么是锁？</h3><p>锁是某个协程（线程）在访问某个资源时先锁住，防止其它协程的访问，等访问完毕解锁后其他协程再来加锁进行访问。这和我们生活中加锁使用公共资源相似，例如：公共卫生间。</p><h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><p><font color="red">死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁。</font></p><p>常见三种死锁类型：</p><ol><li>单go程自己死锁</li></ol><p>无缓冲channel 应该在至少 2 个以上的go程中进行通信。否则死锁！！！</p><ol start="2"><li>go程间channel访问顺序导致死锁</li></ol><p>示例代码：</p><pre><code>package mainimport &quot;fmt&quot;func main() {ch := make(chan int)ch &lt;- 1           // I&#39;m blocked because there is no channel read yet. fmt.Println(&quot;send&quot;)go func() {    &lt;-ch          // I will never be called for the main routine is blocked!    fmt.Println(&quot;received&quot;)}()fmt.Println(&quot;over&quot;)}</code></pre><p>使用channel一端读（写），要保证另一端写（读）操作，同时有机会执行。否则死锁。</p><ol start="3"><li><p>多go程，多channel 交叉死锁</p><p> A go程，掌握M的同时，尝试拿N； </p><p> B go程，掌握N的同时尝试拿M。 </p></li></ol><p>各方都在请求对方的资源同时又不愿放弃手里的资源</p><ol start="4"><li><font color="red">在go语言中，尽量不要将 互斥锁、读写锁 与 channel 混用。 ——  隐性死锁。</font></li></ol><h1 id="互斥锁-建议锁"><a href="#互斥锁-建议锁" class="headerlink" title="互斥锁(建议锁)"></a>互斥锁(建议锁)</h1><p>每个资源都对应于一个可称为 “互斥锁” 的标记，这个标记用来保证在任意时刻，只能有一个协程（线程）访问该资源。其它的协程只能等待。</p><p>互斥锁是传统并发编程对共享资源进行访问控制的主要手段，它由标准库sync中的Mutex结构体类型表示。sync.Mutex类型只有两个公开的指针方法，Lock和Unlock。Lock锁定当前的共享资源，Unlock进行解锁。</p><p>在使用互斥锁时，一定要注意：<font color="red">对资源操作完成后，一定要解锁，否则会出现流程执行异常，死锁等问题。通常借助defer。锁定后，立即使用defer语句保证互斥锁及时解锁。</font></p><p>如下所示：</p><pre><code>var mutex sync.Mutex        // 定义互斥锁变量 mutex func write(){    mutex.Lock( )    defer mutex.Unlock( ) }</code></pre><p>我们可以使用互斥锁来解决前面提到的多任务编程的问题，如下所示：</p><pre><code>package main  import (    &quot;fmt&quot;    &quot;time&quot;    &quot;sync&quot; )  var mutex sync.Mutex  func printer(str string)  {    mutex.Lock()                   // 添加互斥锁    defer mutex.Unlock()             // 使用结束时解锁     for _, data := range str {        // 迭代器       fmt.Printf(&quot;%c&quot;, data)       time.Sleep(time.Second)       // 放大协程竞争效果    }    fmt.Println()               }  func person1(s1 string)  {    printer(s1) }  func person2()  {    printer(&quot;world&quot;)            // 调函数时传参 }  func main()  {    go person1(&quot;hello&quot;)           // main 中传参    go person2()    for {       ;    } }</code></pre><p>程序执行结果与多任务资源竞争时一致。最终由于添加了互斥锁，可以按序先输出hello再输出 world。但这里需要我们自行创建互斥锁，并在适当的位置对锁进行释放。</p><h1 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h1><p><font color="red">读锁和写锁是同一把锁的两个属性（以读模式和写模式枷锁），而不是两把锁，所以在同一个时刻只能加一把锁</font></p><p>互斥锁的本质是当一个goroutine访问的时候，其他goroutine都不能访问。这样在资源同步，避免竞争的同时也降低了程序的并发性能。程序由原来的并行执行变成了串行执行。</p><p>其实，当我们对一个不会变化的数据只做“读”操作的话，是不存在资源竞争的问题的。因为数据是不变的，不管怎么读取，多少goroutine同时读取，都是可以的。</p><p><font color="blue">所以问题不是出在“读”上，主要是修改，也就是“写”。修改的数据要同步，这样其他goroutine才可以感知到。所以真正的互斥应该是读取和修改、修改和修改之间，读和读是没有互斥操作的必要的。<br>因此，衍生出另外一种锁，叫做读写锁。</font></p><p>读写锁可以让多个读操作并发，同时读取，但是对于写操作是完全互斥的。也就是说，当一个goroutine进行写操作的时候，其他goroutine既不能进行读操作，也不能进行写操作。<br>GO中的读写锁由结构体类型sync.RWMutex表示。此类型的方法集合中包含两对方法：</p><p>一组是对写操作的锁定和解锁，简称“写锁定”和“写解锁”：</p><pre><code>func (*RWMutex)Lock()func (*RWMutex)Unlock()</code></pre><p>另一组表示对读操作的锁定和解锁，简称为“读锁定”与“读解锁”：</p><pre><code>func (*RWMutex)RLock()func (*RWMutex)RUlock()</code></pre><p>读写锁基本示例：</p><pre><code>package main  import (    &quot;sync&quot;    &quot;fmt&quot;    &quot;math/rand&quot; )  var count int                   // 全局变量count var rwlock sync.RWMutex           // 全局读写锁 rwlock  func read(n int)  {    rwlock.RLock()    fmt.Printf(&quot;读 goroutine %d 正在读取数据...\n&quot;, n)    num := count    fmt.Printf(&quot;读 goroutine %d 读取数据结束，读到 %d\n&quot;, n, num)    defer rwlock.RUnlock() } func write(n int)  {    rwlock.Lock()    fmt.Printf(&quot;写 goroutine %d 正在写数据...\n&quot;, n)    num := rand.Intn(1000)    count = num    fmt.Printf(&quot;写 goroutine %d 写数据结束，写入新值 %d\n&quot;, n, num)    defer rwlock.Unlock() }  func main()  {    for i:=0; i&lt;5; i++ {       go read(i+1)    }    for i:=0; i&lt;5; i++ {       go write(i+1)    }    for {       ;    } }</code></pre><p>我们在read里使用读锁，也就是RLock和RUnlock，写锁的方法名和我们平时使用的一样，是Lock和Unlock。这样，我们就使用了读写锁，可以并发地读，但是同时只能有一个写，并且写的时候不能进行读操作。</p><p>我们从结果可以看出，读取操作可以并行，例如2,3,1正在读取，但是同时只能有一个写，例如1正在写，只能等待1写完，这个过程中不允许进行其它的操作。</p><p>处于读锁定状态，那么针对它的写锁定操作将永远不会成功，且相应的Goroutine也会被一直阻塞。因为它们是互斥的。</p><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>读写锁控制下的多个写操作之间都是互斥的，并且写操作与读操作之间也都是互斥的。但是，多个读操作之间不存在互斥关系。<br>从互斥锁和读写锁的源码可以看出，它们是同源的。读写锁的内部用互斥锁来实现写锁定操作之间的互斥。可以把读写锁看作是互斥锁的一种扩展。</p><h5 id="读时共享，写时独占。写锁优先级比读锁高。"><a href="#读时共享，写时独占。写锁优先级比读锁高。" class="headerlink" title="读时共享，写时独占。写锁优先级比读锁高。"></a>读时共享，写时独占。写锁优先级比读锁高。</h5><h1 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h1><p><font color="blue">条件变量的作用并不保证在同一时刻仅有一个协程（线程）访问某个共享的数据资源，而是在对应的共享数据的状态发生变化时，通知阻塞在某个条件上的协程（线程）。</font></p><p><font color="red">条件变量不是锁，在并发中不能达到同步的目的，因此条件变量总是与锁一块使用。</font></p><p>例如，我们上面说的，如果仓库队列满了，我们可以使用条件变量让生产者对应的goroutine暂停（阻塞），但是当消费者消费了某个产品后，仓库就不再满了，应该唤醒（发送通知给）阻塞的生产者goroutine继续生产产品。</p><p>GO标准库中的sys.Cond类型代表了条件变量。条件变量要与锁（互斥锁，或者读写锁）一起使用。成员变量L代表与条件变量搭配使用的锁。</p><pre><code>type Cond struct {    noCopy noCopy    // L is held while observing or changing the condition    L Locker    notify  notifyList    checker copyChecker }</code></pre><p>对应的有3个常用方法，Wait，Signal，Broadcast。</p><h3 id="func-c-Cond-Wait"><a href="#func-c-Cond-Wait" class="headerlink" title="func ((c *Cond)) Wait(())"></a>func ((c *Cond)) Wait(())</h3><p>该函数的作用可归纳为如下三点：</p><ol><li>阻塞等待条件变量满足    </li><li>释放已掌握的互斥锁相当于cond.L.Unlock(())。 注意：两步为一个原子操作。</li></ol><p><font color="red">以上两步为原子操作，必须一起做，做完之后相当于把锁让出去了，等待对端去读或者写数据，等对段完成相应操作后，会再向这一端发送一个信号，唤醒这一端，继续向下执行。</font></p><ol start="3"><li>当被唤醒，Wait(())函数返回时，解除阻塞并重新获取互斥锁。相当于cond.L.Lock(())</li></ol><h3 id="func-c-Cond-Signal"><a href="#func-c-Cond-Signal" class="headerlink" title="func ((c *Cond)) Signal(())"></a>func ((c *Cond)) Signal(())</h3><p>单发通知，给一个正等待（阻塞）在该条件变量上的goroutine（线程）发送通知。</p><h3 id="func-c-Cond-Broadcast"><a href="#func-c-Cond-Broadcast" class="headerlink" title="func ((c *Cond)) Broadcast(())"></a>func ((c *Cond)) Broadcast(())</h3><p>广播通知，给正在等待（阻塞）在该条件变量上的所有goroutine（线程）发送通知。</p><h2 id="示例代码："><a href="#示例代码：" class="headerlink" title="示例代码："></a>示例代码：</h2><pre><code>package main import &quot;fmt&quot; import &quot;sync&quot; import &quot;math/rand&quot; import &quot;time&quot;  var cond sync.Cond             // 创建全局条件变量  // 生产者 func producer(out chan&lt;- int, idx int) {    for {       cond.L.Lock()               // 条件变量对应互斥锁加锁       for len(out) == 3 {              // 产品区满 等待消费者消费          cond.Wait()                 // 挂起当前协程， 等待条件变量满足，被消费者唤醒       }       num := rand.Intn(1000)     // 产生一个随机数       out &lt;- num                 // 写入到 channel 中 （生产）       fmt.Printf(&quot;%dth 生产者，产生数据 %3d, 公共区剩余%d个数据\n&quot;, idx, num, len(out))       cond.L.Unlock()                 // 生产结束，解锁互斥锁       cond.Signal()               // 唤醒 阻塞的 消费者       time.Sleep(time.Second)       // 生产完休息一会，给其他协程执行机会    } } //消费者 func consumer(in &lt;-chan int, idx int) {    for {       cond.L.Lock()               // 条件变量对应互斥锁加锁（与生产者是同一个）       for len(in) == 0 {          // 产品区为空 等待生产者生产          cond.Wait()                 // 挂起当前协程， 等待条件变量满足，被生产者唤醒       }       num := &lt;-in                    // 将 channel 中的数据读走 （消费）       fmt.Printf(&quot;---- %dth 消费者, 消费数据 %3d,公共区剩余%d个数据\n&quot;, idx, num, len(in))       cond.L.Unlock()                 // 消费结束，解锁互斥锁       cond.Signal()               // 唤醒 阻塞的 生产者       time.Sleep(time.Millisecond * 500)        //消费完 休息一会，给其他协程执行机会    } } func main() {    rand.Seed(time.Now().UnixNano())  // 设置随机数种子    quit := make(chan bool)           // 创建用于结束通信的 channel     product := make(chan int, 3)      // 产品区（公共区）使用channel 模拟    cond.L = new(sync.Mutex)          // 创建互斥锁和条件变量     for i := 0; i &lt; 5; i++ {          // 5个消费者       go producer(product, i+1)    }    for i := 0; i &lt; 3; i++ {          // 3个生产者       go consumer(product, i+1)    }    &lt;-quit                             // 主协程阻塞 不结束 }</code></pre><p>1)    main函数中定义quit，其作用是让主协程阻塞。<br>2)    定义product作为队列，生产者产生数据保存至队列中，最多存储3个数据，消费者从中取出数据模拟消费<br>3)    条件变量要与锁一起使用，这里定义全局条件变量cond，它有一个属性：L Locker。是一个互斥锁。<br>4)    开启5个消费者协程，开启3个生产者协程。<br>5)    producer生产者，在该方法中开启互斥锁，保证数据完整性。并且判断队列是否满，如果已满，调用wait(())让该goroutine阻塞。当消费者取出数后执行cond.Signal(())，会唤醒该goroutine，继续生产数据。<br>6)    consumer消费者，同样开启互斥锁，保证数据完整性。判断队列是否为空，如果为空，调用wait(())使得当前goroutine阻塞。当生产者产生数据并添加到队列，执行cond.Signal(()) 唤醒该goroutine。</p><h2 id="条件变量使用流程"><a href="#条件变量使用流程" class="headerlink" title="条件变量使用流程"></a>条件变量使用流程</h2><ol><li><p>创建条件变量： </p><pre><code>var cond    sync.Cond</code></pre></li><li><p>指定条件变量用的锁： </p><pre><code>cond.L = new(sync.Mutex)</code></pre></li><li><p>给公共区加锁（互斥量）</p><pre><code>cond.L.Lock()    </code></pre></li><li><p>判断是否到达 阻塞条件（缓冲区满/空）    —— for 循环判断</p><pre><code>for  len(ch) == cap(ch) {   cond.Wait()     // 1) 阻塞 2) 解锁 3) 加锁}</code></pre></li><li><p>访问公共区 —— 读、写数据、打印 </p></li><li><p>解锁条件变量用的锁  </p><pre><code>cond.L.Unlock()</code></pre></li><li><p>唤醒阻塞在条件变量上的对端。 </p><ul><li>signal(()) </li><li>Broadcast(())</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Go特性4】select</title>
      <link href="/2020/12/24/go-feature-select/"/>
      <url>/2020/12/24/go-feature-select/</url>
      
        <content type="html"><![CDATA[<h1 id="select"><a href="#select" class="headerlink" title="select"></a>select</h1><h2 id="select作用"><a href="#select作用" class="headerlink" title="select作用"></a>select作用</h2><p>Go里面提供了一个关键字select，通过select可以监听channel上的数据流动。</p><p>select的用法与switch语言非常类似，由select开始一个新的选择块，每个选择条件由case语句来描述。</p><blockquote><p><font color="red">与switch语句相比， select有比较多的限制，其中最大的一条限制就是每个case语句里必须是一个IO操作</font></p></blockquote><p>大致的结构如下：</p><pre><code>    select {    case &lt;-chan1:        // 如果chan1成功读到数据，则进行该case处理语句    case chan2 &lt;- 1:        // 如果成功向chan2写入数据，则进行该case处理语句    default:        // 如果上面都没有成功，则进入default处理流程    }</code></pre><p>在一个select语句中，Go语言会按顺序从头至尾评估每一个发送和接收的语句。</p><ul><li><p>如果其中的任意一语句可以继续执行(即没有被阻塞)，那么就从那些可以执行的语句中任意选择一条来使用。</p></li><li><p>如果没有任意一条语句可以执行(即所有的通道都被阻塞)，那么有两种可能的情况：</p><ol><li>如果给出了default语句，那么就会执行default语句，同时程序的执行会从select语句后的语句中恢复。</li><li>如果没有default语句，那么select语句将被阻塞，直到至少有一个通信可以进行下去。</li></ol></li></ul><p>示例代码：</p><pre><code>package mainimport (    &quot;fmt&quot;)func fibonacci(c, quit chan int) {    x, y := 1, 1    for {        select {        case c &lt;- x:            x, y = y, x+y        case &lt;-quit:            fmt.Println(&quot;quit&quot;)            return        }    }}func main() {    c := make(chan int)    quit := make(chan int)    go func() {        for i := 0; i &lt; 6; i++ {            fmt.Println(&lt;-c)        }        quit &lt;- 0    }()    fibonacci(c, quit)}</code></pre><p>运行结果如下：</p><pre><code>112348quit</code></pre><h2 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h2><p>有时候会出现goroutine阻塞的情况，那么我们如何避免整个程序进入阻塞的情况呢？我们可以利用select来设置超时，通过如下的方式实现：</p><pre><code>func main() {    c := make(chan int)    o := make(chan bool)    go func() {        for {            select {            case v := &lt;-c:                fmt.Println(v)            case &lt;-time.After(5 * time.Second):                fmt.Println(&quot;timeout&quot;)                o &lt;- true                break            }        }    }()    //c &lt;- 666 // 注释掉，引发 timeout    &lt;-o}</code></pre><h2 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h2><ol><li><p>监听的case中，没有满足监听条件，阻塞。</p></li><li><p>监听的case中，有多个满足监听条件，任选一个执行。</p></li><li><p>可以使用default来处理所有case都不满足监听条件的状况。 通常不用（会产生忙轮询）</p></li><li><p>select 自身不带有循环机制，需借助外层 for 来循环监听</p></li><li><p>break 跳出 select中的一个case选项 。类似于switch中的用法。</p></li><li><p>case 后面的语句在监听数据的同时需要拿出数据，如果分两步做，会丢失数据，因为相当于拿了两次，但只用了第二次</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Go特性3】channel</title>
      <link href="/2020/12/23/go-feature-channel/"/>
      <url>/2020/12/23/go-feature-channel/</url>
      
        <content type="html"><![CDATA[<h1 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h1><p>channel是Go语言中的一个核心类型，可以把它看成管道。并发核心单元通过它就可以发送或者接收数据进行通讯，这在一定程度上又进一步降低了编程的难度。</p><p>channel是一个数据类型，<font color="red">主要用来解决协程的同步问题以及协程之间数据共享（数据传递）的问题</font>。</p><p>goroutine运行在相同的地址空间，因此访问共享内存必须做好同步。<font color="red">goroutine 奉行通过通信来共享内存，而不是共享内存来通信</font>。<br>引⽤类型 channel可用于多个 goroutine 通讯。其内部实现了同步，确保并发安全。</p><h3 id="channel的定义"><a href="#channel的定义" class="headerlink" title="channel的定义"></a>channel的定义</h3><p>和map类似，channel也一个对应make创建的底层数据结构的引用。</p><p>channel或用于函数参数传递时，传的是引用。</p><pre><code>make(chan Type)  //等价于make(chan Type, 0)make(chan Type, capacity)</code></pre><p>chan是创建channel所需使用的关键字。Type 代表指定channel收发数据的类型。</p><p><font color="red">当 参数capacity= 0 时，channel 是无缓冲阻塞读写的；当capacity &gt; 0 时，channel 有缓冲、是非阻塞的，直到写满 capacity个元素才阻塞写入。<br></font></p><h3 id="无缓冲的channel（读写必须同步，相当于打电话）"><a href="#无缓冲的channel（读写必须同步，相当于打电话）" class="headerlink" title="无缓冲的channel（读写必须同步，相当于打电话）"></a>无缓冲的channel（读写必须同步，相当于打电话）</h3><p>无缓冲的通道（unbuffered channel）是指在接收前没有能力保存任何值的通道。</p><p>这种类型的通道要求发送goroutine和接收goroutine同时准备好，才能完成发送和接收操作。否则，<font color="red">通道会导致先执行发送或接收操作的 goroutine 阻塞等待<big>,如果只有或写的操作，会导致死锁</big></font>。</p><p>无缓冲的channel创建格式：</p><pre><code>make(chan Type)   //等价于make(chan Type, 0)</code></pre><p>如果没有指定缓冲区容量，那么该通道就是同步的，因此会阻塞到发送者准备好发送和接收者准备好接收。</p><p>示例代码：</p><pre><code>func main() {    c := make(chan int, 0) //创建无缓冲的通道 c     //内置函数 len 返回未被读取的缓冲元素数量，cap 返回缓冲区大小    fmt.Printf(&quot;len(c)=%d, cap(c)=%d\n&quot;, len(c), cap(c))    go func() {        defer fmt.Println(&quot;子协程结束&quot;)        for i := 0; i &lt; 3; i++ {            c &lt;- i            fmt.Printf(&quot;子协程正在运行[%d]: len(c)=%d, cap(c)=%d\n&quot;, i, len(c), cap(c))        }    }()    time.Sleep(2 * time.Second) //延时2s    for i := 0; i &lt; 3; i++ {        num := &lt;-c //从c中接收数据，并赋值给num        fmt.Println(&quot;num = &quot;, num)    }    fmt.Println(&quot;main协程结束&quot;)}</code></pre><blockquote><p>IO操作会比较慢，导致显示出来的结果和实际结果可能不一致</p></blockquote><h3 id="有缓冲的channel（读写可以异步，相当于发微信）"><a href="#有缓冲的channel（读写可以异步，相当于发微信）" class="headerlink" title="有缓冲的channel（读写可以异步，相当于发微信）"></a>有缓冲的channel（读写可以异步，相当于发微信）</h3><p>有缓冲的通道（buffered channel）是一种在被接收前能存储一个或者多个数据值的通道。</p><p>这种类型的通道并不强制要求 goroutine 之间必须同时完成发送和接收。通道会阻塞发送和接收动作的条件也不同。</p><ul><li><p>只有通道中没有要接收的值时，接收动作才会阻塞。</p></li><li><p>只有通道没有可用缓冲区容纳被发送的值时，发送动作才会阻塞。</p></li></ul><p>这导致有缓冲的通道和无缓冲的通道之间的一个很大的不同：无缓冲的通道保证进行发送和接收的 goroutine 会在同一时间进行数据交换；有缓冲的通道没有这种保证。</p><p>有缓冲的channel创建格式：</p><pre><code>    make(chan Type, capacity)</code></pre><p>如果给定了一个缓冲区容量，通道就是异步的。只要缓冲区有未使用空间用于发送数据，或还包含可以接收的数据，那么其通信就会无阻塞地进行。</p><p>示例代码：</p><pre><code>func main() {    c := make(chan int, 3) //带缓冲的通道    //内置函数 len 返回未被读取的缓冲元素数量， cap 返回缓冲区大小    fmt.Printf(&quot;len(c)=%d, cap(c)=%d\n&quot;, len(c), cap(c))    go func() {        defer fmt.Println(&quot;子协程结束&quot;)        for i := 0; i &lt; 3; i++ {            c &lt;- i            fmt.Printf(&quot;子协程正在运行[%d]: len(c)=%d, cap(c)=%d\n&quot;, i, len(c), cap(c))        }    }()    time.Sleep(2 * time.Second) //延时2s    for i := 0; i &lt; 3; i++ {        num := &lt;-c //从c中接收数据，并赋值给num        fmt.Println(&quot;num = &quot;, num)    }    fmt.Println(&quot;main协程结束&quot;)}</code></pre><blockquote><p>内置函数 len 返回未被读取的缓冲元素数量， cap 返回缓冲区大小</p></blockquote><h4 id="关闭channel"><a href="#关闭channel" class="headerlink" title="关闭channel"></a>关闭channel</h4><p>如果发送者知道，没有更多的值需要发送到channel的话，那么让接收者也能及时知道没有多余的值可接收将是有用的，因为接收者可以停止不必要的接收等待。这可以通过内置的close函数来关闭channel实现。</p><p>确定不再相对端发送、接收数据。关闭channel。 使用 close(ch) 关闭channel</p><p>对端可以判断 channel 是否关闭：</p><pre><code>if num， ok := &lt;-ch ;  ok == true {</code></pre><ul><li><p>如果对端已经关闭， ok –&gt; false . num无数据。</p></li><li><p>如果对端没有关闭， ok –&gt; true . num保存读到的数据。</p></li></ul><p>可以使用 range 替代 ok：</p><pre><code>for num := range ch {        // ch 不能替换为 &lt;-ch}</code></pre><p>总结：    </p><ol><li><p>数据不发送完，不应该关闭。</p></li><li><p>已经关闭的channel， 不能再向其写数据。 报错：panic: send on closed channel</p></li><li><p>写端已经关闭channel， 可以从中读取数据。</p></li></ol><p>读无缓冲channel： 读到0 。 —— 说明：写端关闭。</p><p>读有缓冲channel： 如果缓冲区内有数据，先读数据。读完数据后，可以继续读。 读到 0</p><h4 id="单向channel"><a href="#单向channel" class="headerlink" title="单向channel"></a>单向channel</h4><p>默认情况下，通道channel是双向的，也就是，既可以往里面发送数据也可以同里面接收数据。</p><p>但是，我们经常见一个<font color="red">通道作为参数进行传递而值希望对方是单向使用的，要么只让它发送数据，要么只让它接收数据，这时候我们可以指定通道的方向</font>。</p><p>默认的channel 是双向的。 </p><p>var ch chan int<br>ch = make(chan int)</p><p>单向写channel:    </p><pre><code>var  sendCh chan &lt;-     int    sendCh = make(chan &lt;- int)    不能读操作</code></pre><p>单向读channel:    </p><pre><code>var  recvCh  &lt;- chan int    recvCh = make(&lt;-chan int)</code></pre><p>转换：</p><ol><li>双向channel 可以 隐式转换为 任意一种单向channel <pre><code>sendCh  = ch</code></pre></li><li>单向 channel 不能转换为 双向 channel<pre><code>ch = sendCh/recvCh   error！！！</code></pre></li></ol><blockquote><p>传参： 传【引用】</p></blockquote><h2 id="生产者消费者模型"><a href="#生产者消费者模型" class="headerlink" title="生产者消费者模型"></a>生产者消费者模型</h2><p>单向channel最典型的应用是“生产者消费者模型”</p><p>所谓“生产者消费者模型”: 某个模块（函数等）负责产生数据，这些数据由另一个模块来负责处理（此处的模块是广义的，可以是类、函数、协程、线程、进程等）。产生数据的模块，就形象地称为生产者；而处理数据的模块，就称为消费者。</p><h3 id="缓冲区的好处："><a href="#缓冲区的好处：" class="headerlink" title="缓冲区的好处："></a>缓冲区的好处：</h3><ul><li>解耦</li></ul><p>假设生产者和消费者分别是两个类。如果让生产者直接调用消费者的某个方法，那么生产者对于消费者就会产生依赖（也就是耦合）。将来如果消费者的代码发生变化，可能会直接影响到生产者。而如果两者都依赖于某个缓冲区，两者之间不直接依赖，耦合度也就相应降低了。</p><ul><li>处理并发</li></ul><p>生产者直接调用消费者的某个方法，还有另一个弊端。由于函数调用是同步的（或者叫阻塞的），在消费者的方法没有返回之前，生产者只好一直等在那边。万一消费者处理数据很慢，生产者只能无端浪费时间。</p><ul><li>缓存</li></ul><p>如果生产者制造数据的速度时快时慢，缓冲区的好处就体现出来了。当数据制造快的时候，消费者来不及处理，未处理的数据可以暂时存在缓冲区中。等生产者的制造速度慢下来，消费者再慢慢处理掉。</p><blockquote><p>使用有缓冲的channel和有缓冲的channel能实现生产者消费者模型，无缓冲的channel是同步通信，使用有缓冲的channel是异步通信</p></blockquote><h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><h2 id="time-Timer"><a href="#time-Timer" class="headerlink" title="time.Timer"></a>time.Timer</h2><p>Timer是一个定时器。代表未来的一个单一事件，你可以告诉timer你要等待多长时间。</p><pre><code>type Timer struct {    C &lt;-chan Time    r runtimeTimer }</code></pre><p>它提供一个channel，在定时时间到达之前，没有数据写入timer.C会一直阻塞。直到定时时间到，向channel写入值，阻塞解除，可以从中读取数据。</p><h3 id="定时器的常用操作："><a href="#定时器的常用操作：" class="headerlink" title="定时器的常用操作："></a>定时器的常用操作：</h3><h4 id="实现延迟功能"><a href="#实现延迟功能" class="headerlink" title="实现延迟功能"></a>实现延迟功能</h4><ul><li><p>&lt;-time.After(2 * time.Second) //定时2s，阻塞2s,2s后产生一个事件，往channel写内容<br>fmt.Println(“时间到”)</p></li><li><p>time.Sleep(2 * time.Second)<br>fmt.Println(“时间到”)</p></li><li><p>延时2s后打印一句话<br>timer := time.NewTimer(2 * time.Second)<br>&lt;- timer.C<br>fmt.Println(“时间到”)</p></li></ul><h4 id="定时器停止"><a href="#定时器停止" class="headerlink" title="定时器停止"></a>定时器停止</h4><p>time.stop</p><pre><code>timer := time.NewTimer(3 * time.Second)    go func() {        &lt;-timer.C        fmt.Println(&quot;子协程可以打印了，因为定时器的时间到&quot;)    }()    timer.Stop() //停止定时器    for {    }</code></pre><h4 id="定时器重置"><a href="#定时器重置" class="headerlink" title="定时器重置"></a>定时器重置</h4><p>time.reset</p><pre><code>timer := time.NewTimer(3 * time.Second)    go func() {        &lt;-timer.C        fmt.Println(&quot;子协程可以打印了，因为定时器的时间到&quot;)    }()    timer.Stop() //停止定时器    for {    }</code></pre><h4 id="周期定时"><a href="#周期定时" class="headerlink" title="周期定时"></a>周期定时</h4><p>Ticker是一个周期触发定时的计时器，它会按照一个时间间隔往channel发送系统当前时间，而channel的接收者可以以固定的时间间隔从channel中读取事件。</p><pre><code>type Ticker struct {    C &lt;-chan Time     // The channel on which the ticks are delivered.    r runtimeTimer }</code></pre><p>示例代码：</p><pre><code>package mainimport (    &quot;fmt&quot;    &quot;time&quot;)func main() {    //创建定时器，每隔1秒后，定时器就会给channel发送一个事件(当前时间)    ticker := time.NewTicker(time.Second * 1)    i := 0    go func() {        for { //循环            &lt;-ticker.C            i++            fmt.Println(&quot;i = &quot;, i)            if i == 5 {                ticker.Stop() //停止定时器            }        }    }() //别忘了()    //死循环，特地不让main goroutine结束    for {    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Go特性2】Goroutine</title>
      <link href="/2020/12/22/go-feature-goroutine/"/>
      <url>/2020/12/22/go-feature-goroutine/</url>
      
        <content type="html"><![CDATA[<h1 id="Go-并发"><a href="#Go-并发" class="headerlink" title="Go 并发"></a>Go 并发</h1><p>Go 在语言级别支持协程，叫goroutine。Go 语言标准库提供的所有系统调用操作（包括所有同步IO操作），都会出让CPU给其他goroutine。这让轻量级线程的切换管理不依赖于系统的线程和进程，也不需要依赖于CPU的核心数量。</p><p><font color="red">Go从语言层面就支持并行</font>。同时，并发程序的内存管理有时候是非常复杂的，而<font color="red">Go语言提供了自动垃圾回收机制</font>。</p><p>Go语言为并发编程而内置的上层API基于顺序通信进程模型CSP(communicating sequential processes)。这就意味着显式锁都是可以避免的，因为Go通过相对安全的通道发送和接受数据以实现同步，这大大地简化了并发程序的编写。</p><p><font color="red">Go语言中的并发程序主要使用两种手段来实现。goroutine和channel。</font></p><h1 id="Goroutine"><a href="#Goroutine" class="headerlink" title="Goroutine"></a>Goroutine</h1><h3 id="什么是Goroutine？"><a href="#什么是Goroutine？" class="headerlink" title="什么是Goroutine？"></a>什么是Goroutine？</h3><p>goroutine是Go并行设计的核心。<font color="red">goroutine说到底其实就是协程</font>，它比线程更小，十几个goroutine可能体现在底层就是五六个线程，Go语言内部帮你实现了这些goroutine之间的内存共享。执行goroutine只需极少的栈内存(大概是4~5KB)，当然会根据相应的数据伸缩。也正因为如此，可同时运行成千上万个并发任务。goroutine比thread更易用、更高效、更轻便。</p><p>一般情况下，一个普通计算机跑几十个线程就有点负载过大了，但是同样的机器却可以轻松地让成百上千个goroutine进行资源竞争。</p><h3 id="Goroutine的创建"><a href="#Goroutine的创建" class="headerlink" title="Goroutine的创建"></a>Goroutine的创建</h3><p>只需在函数调⽤语句前添加 go 关键字，就可创建并发执⾏单元。</p><p>在并发编程中，我们通常想将一个过程切分成几块，然后让每个goroutine各自负责一块工作，当一个程序启动时，主函数在一个单独的goroutine中运行，我们叫它main goroutine。新的goroutine会用go语句来创建。</p><p>代码示例：</p><pre><code>package mainimport (    &quot;fmt&quot;    &quot;time&quot;)func newTask() {    i := 0    for {        i++        fmt.Printf(&quot;new goroutine: i = %d\n&quot;, i)        time.Sleep(1 * time.Second) //延时1s    }}func main() {    //创建一个 goroutine，启动另外一个任务    go newTask()    i := 0    //main goroutine 循环打印    for {        i++        fmt.Printf(&quot;main goroutine: i = %d\n&quot;, i)        time.Sleep(1 * time.Second) //延时1s    }}</code></pre><h3 id="Goroutine特性"><a href="#Goroutine特性" class="headerlink" title="Goroutine特性"></a>Goroutine特性</h3><p>主goroutine退出后（相当于进程结束），其它的工作goroutine也会自动退出。</p><h4 id="runtime包"><a href="#runtime包" class="headerlink" title="runtime包"></a>runtime包</h4><ul><li>runtime.Gosched() </li></ul><p>用于让出CPU时间片，让出当前goroutine的执行权限，调度器安排其他等待的任务运行，并在下次再获得cpu时间轮片的时候，从该出让cpu的位置恢复执行。</p><p>有点像跑接力赛，A跑了一会碰到代码runtime.Gosched() 就把接力棒交给B了，A歇着了，B继续跑。<br>示例代码：</p><pre><code>package mainimport (&quot;fmt&quot;&quot;runtime&quot;)func main() {    //创建一个goroutine    go func(s string) {        for i := 0; i &lt; 2; i++ {            fmt.Println(s)        }    }(&quot;world&quot;)    for i := 0; i &lt; 2; i++ {        runtime.Gosched()  //import &quot;runtime&quot; 包        /*            屏蔽runtime.Gosched()运行结果如下：                hello                hello            没有runtime.Gosched()运行结果如下：                world                world                hello                hello        */        fmt.Println(&quot;hello&quot;)    }}</code></pre><p>以上程序的执行过程如下：</p><p>主协程进入main()函数，进行代码的执行。当执行到go func()匿名函数时，创建一个新的协程，开始执行匿名函数中的代码，主协程继续向下执行，执行到runtime.Gosched( )时会暂停向下执行，直到其它协程执行完后，再回到该位置，主协程继续向下执行。</p><h4 id="Goexit"><a href="#Goexit" class="headerlink" title="Goexit"></a>Goexit</h4><p>调用 runtime.Goexit() 将立即终止当前 goroutine 执⾏，调度器确保所有已注册 defer延迟调用被执行。</p><p>示例代码：</p><pre><code>package mainimport (&quot;fmt&quot;&quot;runtime&quot;)func main() {    go func() {        defer fmt.Println(&quot;A.defer&quot;)        func() {            defer fmt.Println(&quot;B.defer&quot;)            runtime.Goexit() // 终止当前 goroutine, import &quot;runtime&quot;            fmt.Println(&quot;B&quot;) // 不会执行        }()        fmt.Println(&quot;A&quot;) // 不会执行    }()     //不要忘记()    //死循环，目的不让主goroutine结束    for {    }}</code></pre><p>程序运行结果：</p><h4 id="GOMAXPROCS"><a href="#GOMAXPROCS" class="headerlink" title="GOMAXPROCS"></a>GOMAXPROCS</h4><ul><li>runtime.GOMAXPROCS()</li></ul><p>用来设置可以并行计算的CPU核数的最大值，并返回之前的值。</p><p>示例代码：</p><pre><code>package mainimport (    &quot;fmt&quot;)func main() {//n := runtime.GOMAXPROCS(1)     // 第一次 测试//打印结果：111111111111111111110000000000000000000011111...n := runtime.GOMAXPROCS(2)         // 第二次 测试//打印结果：010101010101010101011001100101011010010100110...    fmt.Printf(&quot;n = %d\n&quot;, n)    for {        go fmt.Print(0)        fmt.Print(1)    }}</code></pre><p>在第一次执行runtime.GOMAXPROCS(1) 时，最多同时只能有一个goroutine被执行。所以会打印很多1。过了一段时间后，GO调度器会将其置为休眠，并唤醒另一个goroutine，这时候就开始打印很多0了，在打印的时候，goroutine是被调度到操作系统线程上的。</p><p>在第二次执行runtime.GOMAXPROCS(2) 时， 我们使用了两个CPU，所以两个goroutine可以一起被执行，以同样的频率交替打印0和1。</p>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【leetcode-704】二分查找</title>
      <link href="/2020/12/20/leetcode-704/"/>
      <url>/2020/12/20/leetcode-704/</url>
      
        <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/binary-search/" target="_blank" rel="noopener">704. 二分查找</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p><p>示例 1:</p><pre><code>输入: nums = [-1,0,3,5,9,12], target = 9输出: 4解释: 9 出现在 nums 中并且下标为 4</code></pre><p>示例 2:</p><pre><code>输入: nums = [-1,0,3,5,9,12], target = 2输出: -1解释: 2 不存在 nums 中因此返回 -1</code></pre><p>提示：</p><ul><li>你可以假设 nums 中的所有元素是不重复的。</li><li>n 将在 [1, 10000]之间。</li><li>nums 的每个元素都将在 [-9999, 9999]之间。</li></ul><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>直接套用二分查找的模版，重点注意细节问题，比如边界值（等号取不取得到）等。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code>func search(nums []int, target int) int {    low, high := 0, len(nums) - 1    for low &lt;= high  {        mid := (low + high)/2        if nums[mid] == target {            return mid        } else if nums[mid] &lt; target {            low = mid + 1        } else {            high = mid - 1        }    }    return -1}</code></pre><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><h3 id="时间复杂度：O-logN"><a href="#时间复杂度：O-logN" class="headerlink" title="时间复杂度：O((logN))"></a>时间复杂度：O((logN))</h3><h3 id="空间复杂度：O-1"><a href="#空间复杂度：O-1" class="headerlink" title="空间复杂度：O((1))"></a>空间复杂度：O((1))</h3><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><p>关于二分查找，后面会专门有一个专题来练习，这里是一个最基本的题型，相当于初探，就不细致讲解了。</p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【剑指offer-57】和为s的两个数字</title>
      <link href="/2020/12/20/offer-57/"/>
      <url>/2020/12/20/offer-57/</url>
      
        <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/" target="_blank" rel="noopener">57. 和为s的两个数字</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。</p><p>示例 1：</p><pre><code>输入：nums = [2,7,11,15], target = 9输出：[2,7] 或者 [7,2]</code></pre><p>示例 2：</p><pre><code>输入：nums = [10,26,30,31,47,60], target = 40输出：[10,30] 或者 [30,10]</code></pre><p>限制：</p><ul><li>1 &lt;= nums.length &lt;= 10^5</li><li>1 &lt;= nums[i] &lt;= 10^6</li></ul><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>考虑到数组有序，可以用双指针技巧，这题的解法有点类似于二分查找，通过sum的大小来调节左右指针的移动。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code>func twoSum(nums []int, target int) []int {    // 让左右指针在两端初始化    left, right := 0, len(nums) - 1    for left &lt; right  {        // 将当前和的大小和目标数字进行比较        sum := nums[left] + nums[right]        if sum == target {            return []int{nums[left], nums[right]}        } else if sum &gt; target {            // 右指针左移            right--        } else {            // 左指针右移            left++        }    }    return []int{}}</code></pre><h1 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h1><h3 id="时间复杂度-O-N"><a href="#时间复杂度-O-N" class="headerlink" title="时间复杂度 O(()N))"></a>时间复杂度 O(()N))</h3><p>N 为数组 nums 的长度；双指针共同线性遍历整个数组。</p><h3 id="空间复杂度-O-1"><a href="#空间复杂度-O-1" class="headerlink" title="空间复杂度 O((1))"></a>空间复杂度 O((1))</h3><p>双指针 left , right 使用常数大小的额外空间。</p><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><ol><li>这题还可以用哈希表法和二分查找法解决，但是时间复杂度和空间复杂度会有所增加，不是最优解法，具体可以参考 <a href="https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/solution/hasher-fen-shuang-zhi-zhen-jie-jue-liang-shu-zhi-h/" target="_blank" rel="noopener">hash\二分\双指针 解决两数之和</a></li><li>只要数组有序，就应该想到双指针技巧，但是，如果数组无序的话，情况就不一样了，比如leetcode第一题<a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener"> 两数之和</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 二分 </tag>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【剑指offer-22】链表中倒数第k个节点</title>
      <link href="/2020/12/19/offer-22/"/>
      <url>/2020/12/19/offer-22/</url>
      
        <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/" target="_blank" rel="noopener">22. 链表中倒数第k个节点</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。</p><p>示例：</p><pre><code>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2.返回链表 4-&gt;5.</code></pre><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>第一时间想到的解法：</p><ul><li>先遍历统计链表长度，记为 n ；</li><li>设置一个指针走 ((n-k)) 步，即可找到链表倒数第 k 个节点。</li></ul><p>当然实际上这题如果用快慢指针做, 不需要知道链表长度，只要指针1先走k-1步，然后指针2和指针1同时前进，当指针1指向链表最后一个元素时，指针2即为所求。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code>func getKthFromEnd(head *ListNode, k int) *ListNode {    p1, p2 := head, head    // 指针p1先走k-1步    for ; k-1 &gt; 0 ; k-- {        p1 = p1.Next    }    for p2.Next != nil {        p1 = p1.Next        p2 = p2.Next    }    return p2}</code></pre><h1 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h1><h3 id="时间复杂度-O-N"><a href="#时间复杂度-O-N" class="headerlink" title="时间复杂度 O((N))"></a>时间复杂度 O((N))</h3><p>N 为链表长度；总体看， p1 走了 N 步， p2 走了 ((N-k)) 步。</p><h3 id="空间复杂度-O-1"><a href="#空间复杂度-O-1" class="headerlink" title="空间复杂度 O((1))"></a>空间复杂度 O((1))</h3><p>双指针 p1 , p2 使用常数大小的额外空间。</p><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><blockquote><p> 在链表相关的题目中，双指针的用法非常广泛，很多时候可以降低算法的时间复杂度或空间复杂度，我们在解决链表类的题目时，应该多多考虑尝试这种方法。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【leetcode-141】环形链表</title>
      <link href="/2020/12/19/leetcode-141/"/>
      <url>/2020/12/19/leetcode-141/</url>
      
        <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener">141. 环形链表</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p><p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。</p><p>说明：不允许修改给定的链表。</p><p>进阶：</p><p>你是否可以使用 O((1)) 空间解决此题？</p><p>示例 1：</p><pre><code>输入：head = [3,2,0,-4], pos = 1输出：返回索引为 1 的链表节点解释：链表中有一个环，其尾部连接到第二个节点。</code></pre><p>示例 2：</p><pre><code>输入：head = [1,2], pos = 0输出：返回索引为 0 的链表节点解释：链表中有一个环，其尾部连接到第一个节点。</code></pre><p>示例 3：</p><pre><code>输入：head = [1], pos = -1输出：返回 null解释：链表中没有环。</code></pre><p>提示：</p><ul><li>链表中节点的数目范围在范围 [0, 104] 内</li><li>-105 &lt;= Node.val &lt;= 105</li><li>pos 的值为 -1 或者链表中的一个有效索引</li></ul><h1 id="解法一：哈希表"><a href="#解法一：哈希表" class="headerlink" title="解法一：哈希表"></a>解法一：哈希表</h1><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>最容易想到的方法是遍历所有节点，每次遍历到一个节点时，判断该节点此前是否被访问过。</p><p>具体地，我们可以使用哈希表来存储所有已经访问过的节点。每次我们到达一个节点，如果该节点已经存在于哈希表中，则说明该链表是环形链表，否则就将该节点加入哈希表中。重复这一过程，直到我们遍历完整个链表即可。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code>func hasCycle(head *ListNode) bool {    visited := make(map[*ListNode]bool)    for p := head; p != nil ; p = p.Next {        if visited[p] {            return true        }        visited[p] = true    }    return false}</code></pre><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><h5 id="时间复杂度：O-N"><a href="#时间复杂度：O-N" class="headerlink" title="时间复杂度：O((N))"></a>时间复杂度：O((N))</h5><p>其中 N 为链表中节点的数目。最坏情况下我们需要遍历每个节点一次。</p><h5 id="空间复杂度：O-N"><a href="#空间复杂度：O-N" class="headerlink" title="空间复杂度：O((N))"></a>空间复杂度：O((N))</h5><p>其中 N 是链表中的节点数。主要为哈希表的开销，最坏情况下我们需要将每个节点插入到哈希表中一次。</p><h1 id="解法二：快慢指针"><a href="#解法二：快慢指针" class="headerlink" title="解法二：快慢指针"></a>解法二：快慢指针</h1><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>本方法需要读者对「Floyd 判圈算法」（又称龟兔赛跑算法）有所了解。</p><p>假想「乌龟」和「兔子」在链表上移动，「兔子」跑得快，「乌龟」跑得慢。当「乌龟」和「兔子」从链表上的同一个节点开始移动时，如果该链表中没有环，那么「兔子」将一直处于「乌龟」的前方；如果该链表中有环，那么「兔子」会先于「乌龟」进入环，并且一直在环内移动。等到「乌龟」进入环时，由于「兔子」的速度快，它一定会在某个时刻与乌龟相遇，即套了「乌龟」若干圈。</p><p>我们可以根据上述思路来解决本题。具体地，我们定义两个指针，一快一满。慢指针每次只移动一步，而快指针每次移动两步。初始时，慢指针在位置 head，而快指针在位置 head.next。这样一来，如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。否则快指针将到达链表尾部，该链表不为环形链表。</p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><pre><code>func hasCycle(head *ListNode) bool {    slow, fast := head, head    // 避免空指针的情况    for fast != nil &amp;&amp; fast.Next != nil {         slow = slow.Next         fast = fast.Next.Next        // 只要快慢指针相遇，就说明有环        if slow == fast {            return true        }    }    // 其他情况均返回false    return false}</code></pre><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><h5 id="时间复杂度：O-N-1"><a href="#时间复杂度：O-N-1" class="headerlink" title="时间复杂度：O((N))"></a>时间复杂度：O((N))</h5><p>其中 N 是链表中的节点数。</p><p>当链表中不存在环时，快指针将先于慢指针到达链表尾部，链表中每个节点至多被访问两次。</p><p>当链表中存在环时，每一轮移动后，快慢指针的距离将减小一。而初始距离为环的长度，因此至多移动 N 轮。</p><h5 id="空间复杂度：O-1-。"><a href="#空间复杂度：O-1-。" class="headerlink" title="空间复杂度：O((1))。"></a>空间复杂度：O((1))。</h5><p>我们只使用了两个指针的额外空间。</p><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><p>这道题有两种解法，第一种哈希表是常规思路，第二种快慢指针法则有较强的技巧型。相比较而言，第一种方法更为通用，在做题时，我们首先想到的应该是第一种思路。而第二种思路重在理解，当然，其空间复杂度只有O((1))，会更优。</p><blockquote><p> 在链表相关的题目中，快慢指针的用法非常广泛，很多时候可以降低算法的时间复杂度或空间复杂度，我们在解决链表类的题目时，应该多多考虑尝试这种方法。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【leetcode-142】环形链表2</title>
      <link href="/2020/12/18/leetcode-142/"/>
      <url>/2020/12/18/leetcode-142/</url>
      
        <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">142. 环形链表2</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p><p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。</p><p>说明：不允许修改给定的链表。</p><p>进阶：</p><p>你是否可以使用 O((1)) 空间解决此题？</p><p>示例 1：</p><pre><code>输入：head = [3,2,0,-4], pos = 1输出：返回索引为 1 的链表节点解释：链表中有一个环，其尾部连接到第二个节点。</code></pre><p>示例 2：</p><pre><code>输入：head = [1,2], pos = 0输出：返回索引为 0 的链表节点解释：链表中有一个环，其尾部连接到第一个节点。</code></pre><p>示例 3：</p><pre><code>输入：head = [1], pos = -1输出：返回 null解释：链表中没有环。</code></pre><p>提示：</p><ul><li>链表中节点的数目范围在范围 [0, 104] 内</li><li>-105 &lt;= Node.val &lt;= 105</li><li>pos 的值为 -1 或者链表中的一个有效索引</li></ul><h1 id="解法一：哈希表"><a href="#解法一：哈希表" class="headerlink" title="解法一：哈希表"></a>解法一：哈希表</h1><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>一个非常直观的思路是：我们遍历链表中的每个节点，并将它记录下来；一旦遇到了此前遍历过的节点，就可以判定链表中存在环。借助哈希表可以很方便地实现。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><pre><code>func detectCycle(head *ListNode) *ListNode {    visited := make(map[*ListNode]bool)    for  p := head ; p != nil &amp;&amp; p.Next != nil; p = p.Next {        // 如果访问过，就返回true        if visited[p] {            return p        }        visited[p] = true    }    // 其他情况都是false    return nil}</code></pre><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><h5 id="时间复杂度：O-N"><a href="#时间复杂度：O-N" class="headerlink" title="时间复杂度：O((N))"></a>时间复杂度：O((N))</h5><p>其中 N 为链表中节点的数目。我们恰好需要访问链表中的每一个节点。</p><h5 id="空间复杂度：O-N"><a href="#空间复杂度：O-N" class="headerlink" title="空间复杂度：O((N))"></a>空间复杂度：O((N))</h5><p>其中 N 为链表中节点的数目。我们需要将链表中的每个节点都保存在哈希表当中。</p><h1 id="解法二：快慢指针"><a href="#解法二：快慢指针" class="headerlink" title="解法二：快慢指针"></a>解法二：快慢指针</h1><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>第二种是快慢指针，这种方法具有一定技巧性。</p><p>我们使用两个指针，fast 与 slow。它们起始都位于链表的头部。随后，slow 指针每次向后移动一个位置，而 fast 指针向后移动两个位置。如果链表中存在环，则 fast 指针最终将再次与 slow 指针在环中相遇。</p><p>如下图所示，设链表中环外部分的长度为 a。slow 指针进入环后，又走了 b 的距离与 fast 相遇。此时，fast 指针已经走完了环的 n 圈，因此它走过的总距离为 a+n((b+c))+b=a+((n+1))b+nc。</p><p><img src="https://i.ibb.co/cc6mBgt/142-fig1.png" alt></p><p>根据题意，任意时刻，fast 指针走过的距离都为 slow 指针的 22 倍。因此，我们有</p><p>a+((n+1))b+nc=2((a+b)) ⟹ a=c+((n-1))((b+c))</p><p>有了 a=c+((n-1))((b+c)) 的等量关系，我们会发现：从相遇点到入环点的距离加上 n-1 圈的环长，恰好等于从链表头部到入环点的距离。</p><p>因此，当发现 slow 与 fast 相遇时，我们再额外使用一个指针 ptr。起始，它指向链表头部；随后，它和 slow 每次向后移动一个位置。最终，它们会在入环点相遇。</p><p>以上是数学证明，抛开以上数学证明，最终的解题思路就是：</p><ol><li>设置一个快指针，一个慢指针</li><li>快慢指针同时出发（快指针的速度是慢指针的两倍），相遇则停下来</li><li>让慢指针再次指向头节点</li><li>两个指针<font color="red">以相同的速度</font>继续走，相遇则返回其中一个指针</li></ol><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><pre><code>func detectCycle(head *ListNode) *ListNode {    // 设置一个快指针，一个慢指针    fast, slow := head, head    // 这里是为了防止出现空指针报错的情况    for fast != nil &amp;&amp; fast.Next != nil  {        // 设置一个快指针，一个慢指针        fast = fast.Next.Next        slow = slow.Next        if fast == slow {            // 让慢指针再次指向头节点            slow = head            break        }    }    // 如果只有一个节点或者没有节点直接返回无环    if fast == nil || fast.Next == nil {        return nil    }    // 两个指针以相同的速度继续走，相遇则返回其中一个的指针    for fast != slow {        fast = fast.Next        slow = slow.Next    }    return slow}</code></pre><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><h5 id="时间复杂度：O-N-1"><a href="#时间复杂度：O-N-1" class="headerlink" title="时间复杂度：O((N))"></a>时间复杂度：O((N))</h5><p>其中 NN 为链表中节点的数目。在最初判断快慢指针是否相遇时，slow 指针走过的距离不会超过链表的总长度；随后寻找入环点时，走过的距离也不会超过链表的总长度。因此，总的执行时间为 O(N)+O(N)=O(N)。</p><h5 id="空间复杂度：O-1"><a href="#空间复杂度：O-1" class="headerlink" title="空间复杂度：O((1))"></a>空间复杂度：O((1))</h5><p>我们只使用了slow, fast, ptr 三个指针。</p><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><p>这道题有两种解法，第一种哈希表是常规思路，第二种快慢指针法则有较强的技巧型。相比较而言，第一种方法更为通用，在做题时，我们首先想到的应该是第一种思路。而第二种思路重在理解，当然，其空间复杂度只有O(1)，会更优。</p><blockquote><p>其实这道题是<a href="https://vegard-bear.github.io/2020/12/19/leetcode-141/">141. 环形链表</a>的变体，只不过判断链表有无环只需做前面两步即可。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Go特性1】并发编程技术</title>
      <link href="/2020/12/17/go-feature-concurrent/"/>
      <url>/2020/12/17/go-feature-concurrent/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Go最突出的特性之一就在于其对并发编程的支持很好，本文是作为Go并发特性介绍的预备知识</p></blockquote><h1 id="并行和并发"><a href="#并行和并发" class="headerlink" title="并行和并发"></a>并行和并发</h1><h3 id="并行-parallel"><a href="#并行-parallel" class="headerlink" title="并行 ((parallel))"></a>并行 ((parallel))</h3><p>指在同一时刻，有<font color="red">多条指令在多个处理器上同时执行</font>。</p><h3 id="并发-concurrency"><a href="#并发-concurrency" class="headerlink" title="并发 ((concurrency))"></a>并发 ((concurrency))</h3><p>指在<font color="red">同一时刻只能有一条指令执行</font>，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，<font color="red">通过cpu时间片轮转使多个进程快速交替的执行</font>。</p><h1 id="程序和进程"><a href="#程序和进程" class="headerlink" title="程序和进程"></a>程序和进程</h1><ul><li><p>程序，是指编译好的二进制文件，在磁盘上，不占用系统资源(cpu、内存、打开的文件、设备、锁….)</p></li><li><p>进程，是一个抽象的概念，与操作系统原理联系紧密。进程是活跃的程序，占用系统资源。在内存中执行。(程序运行起来，产生一个进程)</p></li></ul><h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><p>进程基本的状态有5种，分别为初始态，就绪态，运行态，挂起态与终止态。</p><h3 id="进程并发"><a href="#进程并发" class="headerlink" title="进程并发"></a>进程并发</h3><p>存在问题：</p><ol><li>系统开销比较大，占用资源比较多，开启进程数量比较少。</li><li>在unix/linux系统下，还会产生“孤儿进程”和“僵尸进程”。</li></ol><ul><li>孤儿进程</li><li>僵尸进程</li></ul><p>在操作系统中，可以产生很多的进程。在unix/linux系统中，正常情况下，<font color="red">子进程是通过父进程fork创建的，子进程再创建新的进程</font>。并且父进程永远无法预测子进程 到底什么时候结束。 当一个 进程完成它的工作终止之后，它的父进程需要调用系统调用取得子进程的终止状态。</p><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><h3 id="线程并发"><a href="#线程并发" class="headerlink" title="线程并发"></a>线程并发</h3><p>什么是线程？</p><p>LWP：light weight process 轻量级的进程，本质仍是进程 (Linux下)。</p><ul><li><p>进程：独立地址空间，拥有PCB </p></li><li><p>线程：有独立的PCB，但没有独立的地址空间(共享)</p></li></ul><p>区别：在于是否共享地址空间。独居(进程)；合租(线程)。<br><big></big></p><ul><li>线程：最小的执行单位</li><li>进程：最小分配资源单位，可看成是只有一个线程的进程。</li></ul><h4 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h4><p>线程同步，指一个线程发出某一功能调用时，在没有得到结果之前，该调用不返回。同时其它线程为保证数据一致性，不能调用该功能。</p><p>“同步”的目的，是为了避免数据混乱，解决与时间有关的错误。实际上，不仅线程间需要同步，进程间、信号间等等都需要同步机制。</p><blockquote><p>所有“多个控制流，共同操作一个共享资源”的情况，都需要同步。</p></blockquote><h1 id="锁的应用"><a href="#锁的应用" class="headerlink" title="锁的应用"></a>锁的应用</h1><h3 id="互斥锁-mutex"><a href="#互斥锁-mutex" class="headerlink" title="互斥锁 mutex"></a>互斥锁 mutex</h3><p>Linux中提供一把互斥锁mutex（也称之为互斥量）。<br>每个线程在对资源操作前都尝试先加锁，成功加锁才能操作，操作结束解锁。同一时刻，只能有一个线程持有该锁。</p><p>互斥锁实质上是操作系统提供的一把“建议锁”（又称“协同锁”），建议程序中有多线程访问共享资源的时候使用该机制。但，并没有强制限定。因此，<font color="red">即使有了mutex，如果有线程不按规则来访问数据，依然会造成数据混乱。</font></p><h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>与互斥量类似，但读写锁允许更高的并行性。其特性为：写独占，读共享。</p><h5 id="读写锁特性："><a href="#读写锁特性：" class="headerlink" title="读写锁特性："></a>读写锁特性：</h5><ol><li>读写锁是“写模式加锁”时， 解锁前，所有对该锁加锁的线程都会被阻塞。</li><li>读写锁是“读模式加锁”时， 如果线程以读模式对其加锁会成功；如果线程以写模式加锁会阻塞。</li><li>读写锁是“读模式加锁”时， 既有试图以写模式加锁的线程，也有试图以读模式加锁的线程。那么读写锁会阻塞随后的读模式锁请求。优先满足写模式锁。<font color="red">读锁、写锁并行阻塞，写锁优先级高</font>。</li></ol><p>读写锁也叫共享-独占锁。当读写锁以读模式锁住时，它是以共享模式锁住的；当它以写模式锁住时，它是以独占模式锁住的。写独占、读共享。</p><p>读写锁非常适合于对数据结构读的次数远大于写的情况。</p><h1 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h1><p>协程((coroutine)), 也叫轻量级线程。</p><ul><li><p>与传统的系统级线程和进程相比，协程最大的优势在于“轻量级”。可以轻松创建上万个而不会导致系统资源衰竭。而线程和进程通常很难超过1万个。这也是协程别称“轻量级线程”的原因。</p></li><li><p>一个线程中可以有任意多个协程，但某一时刻只能有一个协程在运行，多个协程分享该线程分配到的计算机资源。</p></li><li><p>除了Python、Lua、Ruset,go等，多数语言在语法层面并不直接支持协程。</p></li><li><p>在协程中，调用一个任务就像调用一个函数一样，消耗的系统资源最少！但能达到进程、线程并发相同的效果。<br>从系统资源消耗的角度出发来看，进程相当多，线程次之，协程最少。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Go 基础】</title>
      <link href="/2020/12/16/go-basic/"/>
      <url>/2020/12/16/go-basic/</url>
      
        <content type="html"><![CDATA[<h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><p>Go语言保留了指针，但与C语言指针有所不同。主要体现在：</p><ul><li>默认值 nil</li><li>操作符 “&amp;” 取变量地址， “*” 通过指针访问目标对象</li><li>不支持指针运算，不支持 “-&gt;” 运算符，直接⽤ “.” 访问目标成员</li></ul><h4 id="函数new"><a href="#函数new" class="headerlink" title="函数new"></a>函数new</h4><p>表达式new(T)将创建一个T类型的<strong>匿名变量</strong>，所做的是为T类型的新值分配并清零一块内存空间，然后将这块内存空间的地址作为结果返回，而这个结果就是指向这个新的T类型值的指针值，返回的指针类型为*T。</p><p>new创建的内存空间位于heap上，空间的默认值为数据类型默认值。如：new(int) 则 <em>p为0，new(bool) 则 </em>p为false</p><pre><code>func main() {     var p1 *int     p1 = new(int)                         //p1为*int 类型, 指向匿名的int变量     fmt.Println(&quot;*p1 = &quot;, *p1)          //*p1 =  0      p2 := new(bool)                      //p2为*bool 类型, 指向匿名的bool变量     fmt.Println(&quot;*p2 = &quot;, *p2)          //*p2 = false     *p2 = true     fmt.Println(&quot;*p2 = &quot;, *p2)          //*p1 = true }</code></pre><h4 id="指针做函数参数"><a href="#指针做函数参数" class="headerlink" title="指针做函数参数"></a>指针做函数参数</h4><pre><code>func swap01(a, b int) {    a, b = b, a    fmt.Printf(&quot;swap01 a = %d, b = %d\n&quot;, a, b)}func swap02(x, y *int) {    *x, *y = *y, *x}func main() {    a := 10    b := 20    //swap01(a, b)     //值传递（传值）    swap02(&amp;a, &amp;b)     //地址传递（传引用）    fmt.Printf(&quot;a = %d, b = %d\n&quot;, a, b)}</code></pre><h4 id="关于多重赋值"><a href="#关于多重赋值" class="headerlink" title="关于多重赋值"></a>关于多重赋值</h4><p><a href="https://www.jianshu.com/p/de95ef71162d" target="_blank" rel="noopener">https://www.jianshu.com/p/de95ef71162d</a></p><h1 id="切片（slice）"><a href="#切片（slice）" class="headerlink" title="切片（slice）"></a>切片（slice）</h1><h4 id="为什么要有切片"><a href="#为什么要有切片" class="headerlink" title="为什么要有切片?"></a>为什么要有切片?</h4><ol><li>数组的容量固定，不能自动拓展。</li><li>值传递。 数组作为函数参数时，将整个数组值拷贝一份给形参（值拷贝内存消耗大）。</li></ol><p>在Go语言中，我们几乎可以在所有的场景中，使用切片替换数组使用。</p><ul><li>一个slice由三个部分构成：指针、长度和容量。</li></ul><p><font color="red">切片并不是数组或数组指针，它通过内部指针和相关属性引⽤数组⽚段，以实现变⻓⽅案。（后续通过阅读源码深入了解）</font></p><h4 id="切片创建"><a href="#切片创建" class="headerlink" title="切片创建"></a>切片创建</h4><p>可以用make关键字:</p><pre><code>s := make([]int, 5)</code></pre><blockquote><p>注意：make只能创建slice、map和channel，并且返回一个有初始值(非零)的对象。</p></blockquote><h4 id="切片截取"><a href="#切片截取" class="headerlink" title="切片截取"></a>切片截取</h4><p>截取可表示为s[low：high：max]。</p><ul><li>low：表示下标的起点。</li><li>high：表示下标的终点<font color="red">（左闭右开，不包括此下标）</font>。 </li><li>长度 len = high – low。</li><li>容量 cap = max – low。</li></ul><p>长度对应slice中元素的数目；长度不能超过容量，容量一般是从slice的开始位置到底层数据的结尾位置。</p><blockquote><p>切片作为函数参数时，传引用</p></blockquote><h4 id="append函数"><a href="#append函数" class="headerlink" title="append函数"></a>append函数</h4><p>append函数会智能的将底层数组的容量增长，一旦超过原底层数组容量，通常以2倍（1024以下）容量重新分配底层数组，并复制原来的数据。</p><p>因此，使用append 给切片做扩充时，切片的地址可能发生变化。但，数据都被重新保存了，不影响使用</p><h4 id="copy函数"><a href="#copy函数" class="headerlink" title="copy函数"></a>copy函数</h4><p>函数 copy 在两个 slice 间复制数据，复制⻓度以 len 小的为准，两个 slice 指向同⼀底层数组。直接对应位置覆盖。</p><ul><li>copy（目标位置切片， 源切片）</li></ul><h1 id="map"><a href="#map" class="headerlink" title="map"></a>map</h1><p>Go语言中的map(映射、字典)是一种内置的数据结构，它是一个<font color="red">无序</font>的key-value对的集合，比如以身份证号作为唯一键来标识一个人的信息。</p><p>Go语言中并没有提供一个set类型，但是map中的key也是不相同的，可以用map实现类似set的功能。</p><p>map的格式:</p><pre><code>map[keyType]valueType</code></pre><p><strong>在一个map里所有的键都是唯一的，而且必须是支持==和!=操作符的类型，切片、函数以及包含切片的结构类型这些类型由于具有引用语义，不能作为映射的键，使用这些类型会造成编译错误。</strong></p><blockquote><p>注意：map是无序的，我们无法决定它的返回顺序，所以，每次打印结果的顺利有可能不同。</p></blockquote><h4 id="创建map"><a href="#创建map" class="headerlink" title="创建map"></a>创建map</h4><pre><code>m := make(map[int]string, 10)   //第2个参数指定容量</code></pre><h4 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h4><ul><li><p>如果新map元素的key与原map元素key相同     ——&gt; 覆盖（替换）</p></li><li><p>如果新map元素的key与原map元素key不同    ——&gt; 添加</p></li></ul><h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><p>Map的迭代顺序是不确定的，并且不同的哈希函数实现可能导致不同的遍历顺序。在实践中，遍历的顺序是随机的，每一次遍历的顺序都不相同。</p><p>判断map中key是否存在：</p><pre><code>value, ok := m[1]</code></pre><ul><li><p>如果key存在，第一个返回值返回value的值。第二个返回值为 true。</p></li><li><p>如果key存在，第一个返回值返回value的值。第二个返回值为 true。</p></li></ul><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>使用delete()函数，指定key值可以方便的删除map中的k-v映射。</p><pre><code>delete(m1, 2)         //删除key值为2的map</code></pre><blockquote><p>map 做函数参数和返回值，传引用。</p></blockquote><h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><p>如果结构体的全部成员都是可以比较的，那么结构体也是可以比较的，那样的话两个结构体将可以使用 == 或 != 运算符进行比较，但不支持 &gt; 或 &lt;</p><h4 id="做函数参数"><a href="#做函数参数" class="headerlink" title="做函数参数"></a>做函数参数</h4><p>传参过程中，实参会将自己的值拷贝一份给形参。因此结构体“传值”操作几乎不会在实际开发中被使用到。近乎100%的使用都采用“传址”的方式，将结构体的引用传递给所需函数。</p><h1 id="字符串处理函数"><a href="#字符串处理函数" class="headerlink" title="字符串处理函数"></a>字符串处理函数</h1><p>具体可参考<a href="https://studygolang.com/pkgdoc" target="_blank" rel="noopener">Golang标准库文档</a></p><p>除Contains、Join、Trim、Replace等我们学过的字符串处理函数之外，以下函数也常常会被用到。</p><h4 id="字符串分割"><a href="#字符串分割" class="headerlink" title="字符串分割"></a>字符串分割</h4><ul><li>func Split(s, sep string) []string</li></ul><p>功能：把s字符串按照sep分割，返回slice</p><h4 id="按空格拆分字符串"><a href="#按空格拆分字符串" class="headerlink" title="按空格拆分字符串"></a>按空格拆分字符串</h4><ul><li>func Split(s, sep string) []string<br>功能：把s字符串按照sep分割，返回slice</li></ul><h4 id="判断字符串后缀"><a href="#判断字符串后缀" class="headerlink" title="判断字符串后缀"></a>判断字符串后缀</h4><ul><li>func HasSuffix(s, suffix string) bool<br>功能：判断s字符串是否有后缀子串suffix</li></ul><h4 id="判断字符串前缀"><a href="#判断字符串前缀" class="headerlink" title="判断字符串前缀"></a>判断字符串前缀</h4><ul><li>func HasPrefix(s, prefix string) bool<br>功能：判断s字符串是否有前缀子串suffix</li></ul><h1 id="文件IO"><a href="#文件IO" class="headerlink" title="文件IO"></a>文件IO</h1><h2 id="打开、创建文件："><a href="#打开、创建文件：" class="headerlink" title="打开、创建文件："></a>打开、创建文件：</h2><ol><li>创建文件  Create：     文件不存在创建，文件存在，将文件内容清空。</li></ol><ul><li>参数：name， 打开文件的路径： 绝对路径、相对路径        目录分割符：/ </li></ul><ol start="2"><li>打开文件 Open：        以只读方式打开文件。文件不存在，打开失败。</li></ol><ul><li>参数：name， 打开文件的路径： 绝对路径、相对路径</li></ul><ol start="3"><li>打开文件 OpenFile：    以只读、只写、读写 方式打开文件。文件不存在，打开失败。</li></ol><ul><li><p>参1：name， 打开文件的路径： 绝对路径、相对路径</p></li><li><p>参2：打开文件权限： O_RDONLY、O_WRONLY、O_RDWR</p></li><li><p>参3：一般传 6</p></li></ul><h2 id="写文件："><a href="#写文件：" class="headerlink" title="写文件："></a>写文件：</h2><h4 id="按字符串写："><a href="#按字符串写：" class="headerlink" title="按字符串写："></a>按字符串写：</h4><p>WriteString（）    –&gt; n个写入的字符个数</p><pre><code>n, err := f.WriteString(&quot;123&quot;)</code></pre><p>回车换行：    windows： \r\n    Linux: \n</p><h4 id="按位置写"><a href="#按位置写" class="headerlink" title="按位置写:"></a>按位置写:</h4><p>Seek():     修改文件的读写指针位置。</p><ul><li><p>参1： 偏移量。 正：向文件尾偏， 负：向文件头偏</p></li><li><p>参2： 偏移起始位置：    </p></li></ul><p>io.SeekStart: 文件起始位置</p><p>io.SeekCurrent： 文件当前位置</p><p>io.SeekEnd: 文件结尾位置</p><p>返回值：表示从文件起始位置，到当前文件读写指针位置的偏移量。</p><pre><code>off, _ := f.Seek(-5, io.SeekEnd)</code></pre><h4 id="按字节写："><a href="#按字节写：" class="headerlink" title="按字节写："></a>按字节写：</h4><p>writeAt():  在文件制定偏移位置，写入 []byte ,  通常搭配 Seek()</p><ul><li><p>参1： 待写入的数据</p></li><li><p>参2：偏移量</p></li></ul><p>返回：实际写出的字节数。</p><p>n, _ = f.WriteAt([]byte(“1111”), off)    </p><h2 id="读文件："><a href="#读文件：" class="headerlink" title="读文件："></a>读文件：</h2><h4 id="按行读"><a href="#按行读" class="headerlink" title="按行读"></a>按行读</h4><ol><li>创建一个带有缓冲区的 Reader（读写器）</li></ol><pre><code>reader : = bufio.NewReader(打开的文件指针)</code></pre><ol start="2"><li>从reader的缓冲区中 ，读取指定长度的数据。数据长度取决于 参数 dlime</li></ol><pre><code>buf, err := reader.ReadBytes(&#39;\n&#39;)  按行读。</code></pre><p>判断到达文件结尾： </p><pre><code>if err != nil &amp;&amp; err == io.EOF</code></pre><p>到文件结尾。</p><p>文件结束标记，是要单独读一次获取到的。</p><blockquote><p>缓冲区：内存中的一块区域，用来减少物理磁盘访问操作。《计算硬件及组成原理》 —— 机械工业出版社。</p></blockquote><p>按字节读、写文件。</p><ul><li><p>read([]byte):  按字节读文件</p></li><li><p>write([]byte)：按字节字节</p></li></ul><h2 id="目录操作："><a href="#目录操作：" class="headerlink" title="目录操作："></a>目录操作：</h2><h4 id="打开目录：-OpenFile"><a href="#打开目录：-OpenFile" class="headerlink" title="打开目录： OpenFile"></a>打开目录： OpenFile</h4><p>打开目录 OpenFile：    以只读方式打开目录。</p><ul><li><p>参1：name， 打开目录的路径： 绝对路径、相对路径</p></li><li><p>参2：打开目录权限： O_RDONLY</p></li><li><p>参3：os.ModeDir</p></li></ul><p>返回值： 返回一个可以读目录的 文件指针。</p><h4 id="读目录：Readdir"><a href="#读目录：Readdir" class="headerlink" title="读目录：Readdir"></a>读目录：Readdir</h4><p>函数原型：</p><pre><code>func (f *File) Readdir(n int) ([]FileInfo, error) {    //参数: 欲打开的目录项个数。 -1 ， 表所有    //返回值：FileInfo ：}type FileInfo interface {    Name() string               // base name of the file    Size() int64                // length in bytes for regular files; system-dependent for others    Mode() FileMode             // file mode bits    ModTime() time.Time     // modification time    IsDir() bool                // abbreviation for Mode().IsDir()    Sys() interface{}           // underlying data source (can return nil)}    </code></pre>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【leetcode-51】N皇后</title>
      <link href="/2020/12/15/leetcode-51/"/>
      <url>/2020/12/15/leetcode-51/</url>
      
        <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/n-queens/" target="_blank" rel="noopener">46. N皇后</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><p><img src="https://i.niupic.com/images/2020/12/15/97fx.png" alt></p><p>上图为 8 皇后问题的一种解法。</p><p>给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。</p><p>每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p><p>示例：</p><pre><code>输入：4输出：[ [&quot;.Q..&quot;,  // 解法 1  &quot;...Q&quot;,  &quot;Q...&quot;,  &quot;..Q.&quot;], [&quot;..Q.&quot;,  // 解法 2  &quot;Q...&quot;,  &quot;...Q&quot;,  &quot;.Q..&quot;]]解释: 4 皇后问题存在两个不同的解法。</code></pre><p>提示：</p><p>皇后彼此不能相互攻击，也就是说：任何两个皇后都不能处于同一条横行、纵行或斜线上。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>N 皇后是非常经典的题，这题的解题思路也非常清晰，就是通过回溯剪枝进行穷举就行了。这里我们套用框架：</p><pre><code>result = []func backtrack(路径，选择列表) {    if 满足结束条件 {        result.add(路径)    }    return    for 选择 in 选择列表 {        做选择        backtrack(路径，选择列表)        撤销选择    }}</code></pre><p>想清楚几个问题</p><ol><li>起点是什么？<ul><li>从第一行开始遍历</li></ul></li><li>结束条件是什么？<ul><li>遍历到最后一行</li></ul></li><li>怎么定义走过的路径？<ul><li>这里一条路就是一个棋盘的排列方式</li></ul></li><li>如何做选择？<ul><li>在当前行依次遍历所有的列，要保证选中列、行和斜对角都没有冲突</li></ul></li></ol><p>想清楚这几个问题就可以开始写代码了，剩下的就是细节问题了（比如选用什么数据结构）</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// 最终符合要求的若干个棋盘</span><span class="token keyword">var</span> results <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token keyword">func</span> <span class="token function">solveNQueens</span><span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 全局变量需要重置</span>    results <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 定义一个 n * n 的空棋盘</span>    <span class="token keyword">var</span> board <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>        row <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> j <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n <span class="token punctuation">;</span> j<span class="token operator">++</span> <span class="token punctuation">{</span>            row <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>row<span class="token punctuation">,</span> <span class="token function">byte</span><span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>        board <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>board<span class="token punctuation">,</span> <span class="token function">string</span><span class="token punctuation">(</span>row<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 从第 0 行开始遍历</span>    <span class="token function">backTrack</span><span class="token punctuation">(</span>board<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> results<span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">backTrack</span><span class="token punctuation">(</span>board <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">,</span> row <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 结束条件, 最后一行也放好了</span>    <span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>board<span class="token punctuation">)</span> <span class="token operator">==</span> row <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 注意这里用于拷贝的临时变量一定要用 make 开辟空间，分配地址，</span>        <span class="token comment" spellcheck="true">// 不能用 var tmp []string{} 进行声明，否则无法拷贝成功</span>        tmp <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>board<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token function">copy</span><span class="token punctuation">(</span>tmp<span class="token punctuation">,</span> board<span class="token punctuation">)</span>        results <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>results<span class="token punctuation">,</span> tmp<span class="token punctuation">)</span>        <span class="token keyword">return</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 选定当前行，从第一列开始遍历</span>    <span class="token keyword">for</span> col <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> col <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>board<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">;</span> col<span class="token operator">++</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 如果会冲突，跳过这个点</span>        <span class="token keyword">if</span> <span class="token operator">!</span><span class="token function">isValid</span><span class="token punctuation">(</span>board<span class="token punctuation">,</span> row<span class="token punctuation">,</span> col<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">continue</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 如果不冲突，将该节点加入选择（放个皇后）</span>        <span class="token comment" spellcheck="true">// 注意这里的字符赋值方式，需要通过[]byte这种切片形式进行转化，</span>        <span class="token comment" spellcheck="true">// 不能直接给string中的某个字符进行赋值</span>        b <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span>board<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">)</span>        b<span class="token punctuation">[</span>col<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">byte</span><span class="token punctuation">(</span><span class="token string">'Q'</span><span class="token punctuation">)</span>        board<span class="token punctuation">[</span>row<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">string</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// 进入下一行</span>        <span class="token function">backTrack</span><span class="token punctuation">(</span>board<span class="token punctuation">,</span> row <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// 撤销选择，回退一行（把皇后拿掉）</span>        b <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span>board<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">)</span>        b<span class="token punctuation">[</span>col<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">byte</span><span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span>        board<span class="token punctuation">[</span>row<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">string</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 判断当前位置是否合法，这里需要专门写个函数进行处理</span><span class="token keyword">func</span> <span class="token function">isValid</span><span class="token punctuation">(</span>board <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">,</span> row<span class="token punctuation">,</span> col <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">bool</span>  <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 从上往下，检查当前列是否存在冲突（列不变，行--）</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> row <span class="token operator">-</span> <span class="token number">1</span> <span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i<span class="token operator">--</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'Q'</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 左下角是否存在冲突（行--，列--）</span>    <span class="token keyword">for</span> i<span class="token punctuation">,</span> j <span class="token operator">:=</span> row <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> col <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> j <span class="token operator">>=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i<span class="token punctuation">,</span> j <span class="token operator">=</span> i<span class="token number">-1</span><span class="token punctuation">,</span> j<span class="token number">-1</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'Q'</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 右下角是否存在冲突（行--，列++）</span>    <span class="token keyword">for</span> i<span class="token punctuation">,</span> j <span class="token operator">:=</span> row <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> col <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>board<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token punctuation">,</span> j <span class="token operator">=</span> i<span class="token number">-1</span><span class="token punctuation">,</span> j<span class="token operator">+</span><span class="token number">1</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'Q'</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h1><h3 id="时间复杂度：O-N"><a href="#时间复杂度：O-N" class="headerlink" title="时间复杂度：O((N!))"></a>时间复杂度：O((N!))</h3><p>其中 N 是皇后数量。</p><h3 id="空间复杂度：O-N"><a href="#空间复杂度：O-N" class="headerlink" title="空间复杂度：O((N))"></a>空间复杂度：O((N))</h3><p>其中 N 是皇后数量。空间复杂度主要取决于递归调用层数、记录每行放置的皇后的列下标的数组以及三个集合，递归调用层数不会超过 N，数组的长度为 N，每个集合的元素个数都不会超过 N。</p><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><p>这道题有两个需要着重注意的点，特别容易错，我自己做的时候在这里踩了坑：</p><ol><li>对字符串重的某个字符进行赋值时，需要通过[]byte这种切片形式进行转化，不能直接给string中的某个字符进行赋值。</li><li>用于拷贝其一条路径的临时变量一定要用 make 开辟空间，分配地址，不能用 var tmp []string{} 进行声明，否则无法拷贝成功。</li></ol>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 回溯剪枝 </tag>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【leetcode-46】全排列</title>
      <link href="/2020/12/14/leetcode-46/"/>
      <url>/2020/12/14/leetcode-46/</url>
      
        <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/permutations/" target="_blank" rel="noopener">46. 全排列</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个 没有重复 数字的序列，返回其所有可能的全排列。</p><p>示例:</p><pre><code>输入: [1,2,3]输出:[  [1,2,3],  [1,3,2],  [2,1,3],  [2,3,1],  [3,1,2],  [3,2,1]]</code></pre><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>这是一个高中的排列组合问题，我们可以先想一想当时的我们是怎么做的，很明显就是穷举。</p><p>1，2，3，4</p><p>1，2，4，3</p><p>1，3，2，4</p><p>……</p><p>如此下去，其实就是用回溯法剪枝的方法遍历一棵二叉树，或者说深度优先遍历，是一个意思。</p><p>确定用回溯剪枝的方法后，就可以套用回溯剪枝的框架了</p><pre><code>result = []func backtrack(路径，选择列表) {    if 满足结束条件 {        result.add(路径)    }    return    for 选择 in 选择列表 {        做选择        backtrack(路径，选择列表)        撤销选择    }}</code></pre><p>想清楚几个问题</p><ol><li>结束条件是什么？（所有数字都用了一遍）</li><li>怎么定义走过的路径？（用一个数组保存一种排列方式）</li><li>如何做选择？（在给出的数字列表里面依次选）</li></ol><p>想清楚这几个问题就可以开始写代码了。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// 返回的全排列结果</span><span class="token keyword">var</span> res <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token keyword">func</span> <span class="token function">permute</span><span class="token punctuation">(</span>nums <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 注意：这里要重置一下全局数组（leetcode多次执行全局变量不会消失），防止多个测试用例的结果都放到一起</span>    res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 用一个数组维护走过的路径</span>    visited <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token builtin">bool</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 用 path 保存当前路径</span>    <span class="token keyword">var</span> path <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span>    <span class="token comment" spellcheck="true">// 回溯剪枝</span>    <span class="token function">backTrack</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> path<span class="token punctuation">,</span> visited<span class="token punctuation">)</span>    <span class="token keyword">return</span> res<span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">backTrack</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> path <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> visited  <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token builtin">bool</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 先判断结束条件, 走过的路径包含了所有的选择，说明已经得到一种排列方式</span>    <span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token function">len</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 注意：这里不能直接append，因为切片底层共用数据，</span>        <span class="token comment" spellcheck="true">// 这意味着下面切片path一旦改变了，res也会随之改变，而这不是我们希望看到的</span>        <span class="token comment" spellcheck="true">// 所以只能重新开辟一个新的切片将内容拷贝过去</span>        tmp <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token function">copy</span><span class="token punctuation">(</span>tmp<span class="token punctuation">,</span> path<span class="token punctuation">)</span>        res <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> tmp<span class="token punctuation">)</span>        <span class="token keyword">return</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 遍历选择列表，做选择</span>    <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> num <span class="token operator">:=</span> <span class="token keyword">range</span> nums <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 走过的分支直接跳过，直接走下一个分支，避免进入死循环</span>        <span class="token keyword">if</span> visited<span class="token punctuation">[</span>num<span class="token punctuation">]</span> <span class="token punctuation">{</span>            <span class="token keyword">continue</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 将这个选择加入当前路径</span>        path <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> num<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// 将这个选择置为已访问</span>        visited<span class="token punctuation">[</span>num<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span>        <span class="token comment" spellcheck="true">// 进入下一层决策树</span>        <span class="token function">backTrack</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> path<span class="token punctuation">,</span> visited<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// 退出决策树，回退，把这个选择从路径中移除</span>        path <span class="token operator">=</span> path<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token function">len</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>        <span class="token comment" spellcheck="true">// 将这个选择重新置为未访问</span>        visited<span class="token punctuation">[</span>num<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h1><h3 id="时间复杂度：O-n-n"><a href="#时间复杂度：O-n-n" class="headerlink" title="时间复杂度：O((n * n!))"></a>时间复杂度：O((n * n!))</h3><p>其中 n 为序列的长度。<br>算法的复杂度首先受 backtrack 的调用次数制约, 这说明 backtrack 的调用次数是 O((n!)) 的。</p><p>而对于 backtrack 调用的每个叶结点（共 n! 个），我们需要将当前答案使用 O((n)) 的时间复制到答案数组中，相乘得时间复杂度为 O((n * n!))。</p><h3 id="空间复杂度：O-n"><a href="#空间复杂度：O-n" class="headerlink" title="空间复杂度：O((n))"></a>空间复杂度：O((n))</h3><p>其中 n 为序列的长度。除答案数组以外，递归函数在递归过程中需要为每一层递归函数分配栈空间，所以这里需要额外的空间且该空间取决于递归的深度，这里可知递归调用深度为 O((n))</p><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><p>这道题有两个需要着重注意的点，特别容易错，我自己做的时候在这里卡了很久：</p><ol><li>如果定义了全局变量，需要注意要重置一下全局变量，否则多个测试用例的结果会被放到一起，因为leetcode多次执行全局变量不会消失</li><li>当获得一个排列时时，不能直接append，因为切片底层共用数据，这意味着下面如果切片path一旦改变了，我们的res也会随之改变，而这不是我们希望看到的，所以只能重新开辟一个新的切片将内容拷贝过去，这样就保证了path变的时候res不会跟着变</li><li>注意判断是否合法时，行和列很容易弄错，不要颠倒了</li></ol>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 回溯剪枝 </tag>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【leetcode-322】零钱兑换</title>
      <link href="/2020/12/13/leetcode-322/"/>
      <url>/2020/12/13/leetcode-322/</url>
      
        <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/coin-change/" target="_blank" rel="noopener">322. 零钱兑换</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p><p>你可以认为每种硬币的数量是无限的。</p><p>示例 1：</p><pre><code>输入：coins = [1, 2, 5], amount = 11输出：3 解释：11 = 5 + 5 + 1</code></pre><p>示例 2：</p><pre><code>输入：coins = [2], amount = 3输出：-1</code></pre><p>示例 3：</p><pre><code>输入：coins = [1], amount = 0输出：0</code></pre><p>示例 4：</p><pre><code>输入：coins = [1], amount = 1输出：1</code></pre><p>示例 5：</p><pre><code>输入：coins = [1], amount = 2输出：2</code></pre><p>提示：</p><ul><li>1 &lt;= coins.length &lt;= 12</li><li>1 &lt;= coins[i] &lt;= 231 - 1</li><li>0 &lt;= amount &lt;= 104</li></ul><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>这题可以考虑用动态规划求解，将大问题逐渐分解为小问题，对于动态规划需要考虑以下几步：</p><ol><li>定义 DP table</li><li>确定 base case（最简单情况）</li><li>列出状态转移方程</li></ol><p>对于这个问题，dp 数组可以这样定义：</p><ul><li>当目标金额为 i 时，至少需要 dp [ i ] 个硬币可以凑出</li></ul><p>base case 也就是：</p><ul><li>当目标金额为 0 时，需要 0 个硬币可以凑出</li></ul><p>状态转移方程：</p><pre><code>          0,                     amount = 0dp[n] =            dp[amount-coin] + 1,   amount &gt; 0</code></pre><p>明确了以上几点，就可以套动态规划的框架了</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">coinChange</span><span class="token punctuation">(</span>coins <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> amount <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 定义dp数组, 下标为目标金额，值为对应最少硬币数</span>    dp <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> amount<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 初始状态设置为最大值 amount+1，因为 n 个硬币最多需要 n 个一元硬币，</span>    <span class="token comment" spellcheck="true">// 但这里没有直接设置为下标是为了排除找不到（-1）这种情况</span>    <span class="token keyword">for</span> k <span class="token operator">:=</span> <span class="token keyword">range</span> dp <span class="token punctuation">{</span>        dp<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> amount <span class="token operator">+</span> <span class="token number">1</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 确定 base case</span>    dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>    <span class="token comment" spellcheck="true">// 外层循环遍历dp数组（所有状态）</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token keyword">range</span> dp <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 内层循环遍历硬币种类（求每个状态对应最少硬币数）</span>        <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> coin <span class="token operator">:=</span> <span class="token keyword">range</span> coins <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 排除单个硬币面值大于总额的情况（保证状态转移方程不会发生数组越界）</span>            <span class="token keyword">if</span> coin <span class="token operator">&lt;=</span> i <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 状态转移方程</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> coin<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 计算完整个dp数组（1 ～ amount的最小值），最后返回需要的最小值</span>    <span class="token comment" spellcheck="true">// 说明没找到，返回-1</span>    <span class="token keyword">if</span> dp<span class="token punctuation">[</span>amount<span class="token punctuation">]</span> <span class="token operator">==</span> amount <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> dp<span class="token punctuation">[</span>amount<span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 求较小值函数</span><span class="token keyword">func</span> <span class="token function">min</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> a <span class="token operator">&lt;</span> b <span class="token punctuation">{</span>        <span class="token keyword">return</span> a    <span class="token punctuation">}</span>    <span class="token keyword">return</span> b<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h1><h3 id="时间复杂度：O-Sn"><a href="#时间复杂度：O-Sn" class="headerlink" title="时间复杂度：O((Sn))"></a>时间复杂度：O((Sn))</h3><p>其中 S 是金额，n 是面额数。我们一共需要计算 O((S)) 个状态，S 为题目所给的总金额。对于每个状态，每次需要枚举 n 个面额来转移状态，所以一共需要 O((Sn)) 的时间复杂度。</p><h3 id="空间复杂度：O-S"><a href="#空间复杂度：O-S" class="headerlink" title="空间复杂度：O((S))"></a>空间复杂度：O((S))</h3><p>DP 数组需要开长度为总金额 S 的空间。</p><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><p>对于动态规划问题最重要的是列出状态转移方程，需要弄清楚</p><ol><li>这个问题的 base case（最简单情况）是什么？</li><li>有哪些状态？</li><li>对于每个状态可以作出什么选择使得状态发生改变？</li><li>如果定义 dp 数组来表示这种状态？</li></ol>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【leetcode-752】打开转盘锁</title>
      <link href="/2020/12/10/leetcode-752/"/>
      <url>/2020/12/10/leetcode-752/</url>
      
        <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/open-the-lock/" target="_blank" rel="noopener">752. 打开转盘锁</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有10个数字： ‘0’, ‘1’, ‘2’, ‘3’, ‘4’, ‘5’, ‘6’, ‘7’, ‘8’, ‘9’ 。每个拨轮可以自由旋转：例如把 ‘9’ 变为  ‘0’，’0’ 变为 ‘9’ 。每次旋转都只能旋转一个拨轮的一位数字。</p><p>锁的初始数字为 ‘0000’ ，一个代表四个拨轮的数字的字符串。</p><p>列表 deadends 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。</p><p>字符串 target 代表可以解锁的数字，你需要给出最小的旋转次数，如果无论如何不能解锁，返回 -1。</p><p>示例 1:</p><pre class="line-numbers language-go"><code class="language-go">输入：deadends <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"0201"</span><span class="token punctuation">,</span><span class="token string">"0101"</span><span class="token punctuation">,</span><span class="token string">"0102"</span><span class="token punctuation">,</span><span class="token string">"1212"</span><span class="token punctuation">,</span><span class="token string">"2002"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> target <span class="token operator">=</span> <span class="token string">"0202"</span>输出：<span class="token number">6</span>解释：可能的移动序列为 <span class="token string">"0000"</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">"1000"</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">"1100"</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">"1200"</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">"1201"</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">"1202"</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">"0202"</span>。注意 <span class="token string">"0000"</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">"0001"</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">"0002"</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">"0102"</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">"0202"</span> 这样的序列是不能解锁的，因为当拨动到 <span class="token string">"0102"</span> 时这个锁就会被锁定。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>示例 2:</p><pre class="line-numbers language-go"><code class="language-go">输入<span class="token punctuation">:</span> deadends <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"8888"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> target <span class="token operator">=</span> <span class="token string">"0009"</span>输出：<span class="token number">1</span>解释：把最后一位反向旋转一次即可 <span class="token string">"0000"</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">"0009"</span>。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>示例 3:</p><pre class="line-numbers language-go"><code class="language-go">输入<span class="token punctuation">:</span> deadends <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"8887"</span><span class="token punctuation">,</span><span class="token string">"8889"</span><span class="token punctuation">,</span><span class="token string">"8878"</span><span class="token punctuation">,</span><span class="token string">"8898"</span><span class="token punctuation">,</span><span class="token string">"8788"</span><span class="token punctuation">,</span><span class="token string">"8988"</span><span class="token punctuation">,</span><span class="token string">"7888"</span><span class="token punctuation">,</span><span class="token string">"9888"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> target <span class="token operator">=</span> <span class="token string">"8888"</span>输出：<span class="token operator">-</span><span class="token number">1</span>解释：无法旋转到目标数字且不被锁定。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>示例 4:</p><pre class="line-numbers language-go"><code class="language-go">输入<span class="token punctuation">:</span> deadends <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"0000"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> target <span class="token operator">=</span> <span class="token string">"8888"</span>输出：<span class="token operator">-</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>提示：</p><ol><li>死亡列表 deadends 的长度范围为 [1, 500]。</li><li>目标数字 target 不会在 deadends 之中。</li><li>每个 deadends 和 target 中的字符串的数字会在 10,000 个可能的情况 ‘0000’ 到 ‘9999’ 中产生。</li></ol><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>这道题乍一看感觉有些复杂，但是我们先别急，仔细思考一下这道题到底是要做什么。</p><p>首先，我们有一把锁，这把锁的其实状态是”0000”，然后我们通过不断拨动这把锁（每拨动一次，步数+1），最终得到我们的目标数字target。由于每次拨动的时候都只能改变一个数字，而且下一次拨动的结果是依赖于上一次的状态（相邻），每次拨动只能向上或向下，一共四个数字，那么就是8种可能，相当于每个节点有8个相邻的节点，其实就是BFS。</p><p>既然是BFS，我们就需要明确这几个问题：</p><ul><li><p>起点和终点</p><p>起点就是”0000”，终点是target</p></li><li><p>当前节点和相邻节点的关系（如何访问相邻节点）</p><p>向上向下拨动一次，相当于每个数字（一共四个）+1或者-1</p></li><li><p>会不会走回头路</p><p>需要一个数组visited记录每次访问过的数字</p></li></ul><p>此外，这道题还多了一个附加条件，就是不能访问死亡数字，这个很好解决，就是再定义一个数组，每访问一个数字就检查一下是否包含在死亡数字中。</p><h5 id="值得注意的是，字符串常量不能直接赋值，需要转成-byte，再赋值"><a href="#值得注意的是，字符串常量不能直接赋值，需要转成-byte，再赋值" class="headerlink" title="值得注意的是，字符串常量不能直接赋值，需要转成[]byte，再赋值"></a>值得注意的是，字符串常量不能直接赋值，需要转成[]byte，再赋值</h5><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">openLock</span><span class="token punctuation">(</span>deadends <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">,</span> target <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 记录需要跳过的死亡密码</span>    deads <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> k<span class="token punctuation">,</span> dead <span class="token operator">:=</span> <span class="token keyword">range</span> deadends <span class="token punctuation">{</span>        deads<span class="token punctuation">[</span>dead<span class="token punctuation">]</span> <span class="token operator">=</span> k    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 记录已经访问过的密码，主要是为了避免走回头路，陷入死循环</span>    visited <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span>    q <span class="token operator">:=</span> list<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    step <span class="token operator">:=</span> <span class="token number">0</span>    <span class="token comment" spellcheck="true">// 从起点 0000 开始 遍历</span>    q<span class="token punctuation">.</span><span class="token function">PushBack</span><span class="token punctuation">(</span><span class="token string">"0000"</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> <span class="token punctuation">;</span> q<span class="token punctuation">.</span><span class="token function">Len</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">;</span>  <span class="token punctuation">{</span>        size <span class="token operator">:=</span> q<span class="token punctuation">.</span><span class="token function">Len</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size <span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>            element <span class="token operator">:=</span> q<span class="token punctuation">.</span><span class="token function">Front</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            q<span class="token punctuation">.</span><span class="token function">Remove</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span>            cur<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> element<span class="token punctuation">.</span>Value<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token builtin">string</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">// 如果可能遇到死亡密码，直接跳过，不作处理</span>            <span class="token keyword">if</span> <span class="token boolean">_</span><span class="token punctuation">,</span> ok <span class="token operator">:=</span> deads<span class="token punctuation">[</span>cur<span class="token punctuation">]</span><span class="token punctuation">;</span> ok <span class="token punctuation">{</span>                <span class="token keyword">continue</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 到达终点，直接返回步数</span>            <span class="token keyword">if</span> cur <span class="token operator">==</span> target <span class="token punctuation">{</span>                <span class="token keyword">return</span> step            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 将相邻未遍历节点加入队列</span>            <span class="token keyword">for</span> j <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">4</span> <span class="token punctuation">;</span> j<span class="token operator">++</span>  <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 向上拨动，如果没有拨到过，就入队</span>                up <span class="token operator">:=</span> <span class="token function">addOne</span><span class="token punctuation">(</span>cur<span class="token punctuation">,</span> j<span class="token punctuation">)</span>                <span class="token keyword">if</span>  <span class="token boolean">_</span><span class="token punctuation">,</span> ok <span class="token operator">:=</span> visited<span class="token punctuation">[</span>up<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">!</span>ok <span class="token punctuation">{</span>                    q<span class="token punctuation">.</span><span class="token function">PushBack</span><span class="token punctuation">(</span>up<span class="token punctuation">)</span>                    visited<span class="token punctuation">[</span>up<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">// 向下拨动，如果没有拨到过，就入队</span>                down <span class="token operator">:=</span> <span class="token function">subOne</span><span class="token punctuation">(</span>cur<span class="token punctuation">,</span> j<span class="token punctuation">)</span>                <span class="token keyword">if</span>  <span class="token boolean">_</span><span class="token punctuation">,</span> ok <span class="token operator">:=</span> visited<span class="token punctuation">[</span>down<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">!</span>ok <span class="token punctuation">{</span>                    q<span class="token punctuation">.</span><span class="token function">PushBack</span><span class="token punctuation">(</span>down<span class="token punctuation">)</span>                    visited<span class="token punctuation">[</span>down<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 拨动了一次，步数+1</span>        step<span class="token operator">++</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 走到这里说明尝试了所有可能的次数，也没有拨到</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 向上拨动一次</span><span class="token keyword">func</span> <span class="token function">addOne</span><span class="token punctuation">(</span>s <span class="token builtin">string</span><span class="token punctuation">,</span> j <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">{</span>    b <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 9 再拨动一次是 0（特殊情况）</span>    <span class="token keyword">if</span> b<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'9'</span> <span class="token punctuation">{</span>        b<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'0'</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 其他直接+1就行</span>        b<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">++</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token function">string</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 向下拨动一次</span><span class="token keyword">func</span> <span class="token function">subOne</span><span class="token punctuation">(</span>s <span class="token builtin">string</span><span class="token punctuation">,</span> j <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">{</span>    b <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 0 再拨动一次是 9（特殊情况）</span>    <span class="token keyword">if</span> b<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'0'</span> <span class="token punctuation">{</span>        b<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'9'</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 其他直接-1</span>        b<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">--</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token function">string</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h1><h3 id="时间复杂度：O-N-2-A-N-D"><a href="#时间复杂度：O-N-2-A-N-D" class="headerlink" title="时间复杂度：O((N^2 * A^N + D))"></a>时间复杂度：O((N^2 * A^N + D))</h3><p>我们用 A 表示数字的个数，N 表示状态的位数，D 表示数组 deadends 的大小。在最坏情况下，我们需要搜索完所有状态，状态的总数为 O((A^N))。对于每个状态，我们要枚举修改的位置，需要 O((N)) 的时间，枚举后得到新的状态同样需要 O((N)) 的时间。</p><h3 id="空间复杂度：O-A-N-D"><a href="#空间复杂度：O-A-N-D" class="headerlink" title="空间复杂度：O((A^N + D))"></a>空间复杂度：O((A^N + D))</h3><p>用来存储队列以及 deadends 的集合。</p><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><ol><li><p>分析出问题的模型后，可以先写出代码框架（套模版），然后再根据实际情况进行进一步处理细节问题，不要一开始就陷入细节。</p></li><li><p>此外，这道题还可以用双向BFS进行优化，提升效率。</p></li></ol><ul><li>传统的BFS是从起点开始向四周进行扩散，遇到终点时停止；而双向BFS则是从起点和终点同时开始扩散，当两边有交集的时候停止。</li><li>双向BFS存在局限，就是要知道终点在哪里</li><li>双向BFS不再使用队列，而是使用 HashSet 方便快速地判断两个集合是否有交集</li></ul>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> tree </tag>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【leetcode-111】二叉树的最小深度</title>
      <link href="/2020/12/09/leetcode-111/"/>
      <url>/2020/12/09/leetcode-111/</url>
      
        <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/" target="_blank" rel="noopener">111. 二叉树的最小深度</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个二叉树，找出其最小深度。</p><p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p><p>说明：叶子节点是指没有子节点的节点。</p><p>示例 1：</p><p><img src="https://assets.leetcode.com/uploads/2020/10/12/ex_depth.jpg" alt></p><pre class="line-numbers language-go"><code class="language-go">输入：root <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span>null<span class="token punctuation">,</span>null<span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span>输出：<span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>示例 2：</p><pre class="line-numbers language-go"><code class="language-go">输入：root <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span>null<span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span>null<span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span>null<span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span>null<span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span>输出：<span class="token number">5</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>提示：</p><p>树中节点数的范围在 [0, 105] 内<br>-1000 &lt;= Node.val &lt;= 1000</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>这道题有两种常见解法，即DFS和BFS，各有优劣，但是都是套用模版就行。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><p>对于DFS的话，对于每一个非叶子节点，我们只需要分别递归地计算其左右子树的最小深度，然后当前子树的最小深度就是其中较小者+1</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">minDepth</span><span class="token punctuation">(</span>root <span class="token operator">*</span>TreeNode<span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 遍历到空节点，直接返回高度0</span>    <span class="token keyword">if</span> root <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 遍历到叶子节点，返回高度1</span>    <span class="token keyword">if</span> root<span class="token punctuation">.</span>Left <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>Right <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">1</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 定义一个无穷大的数</span>    minD <span class="token operator">:=</span> math<span class="token punctuation">.</span>MaxInt32    <span class="token comment" spellcheck="true">// 递归求左子树的最小高度</span>    <span class="token keyword">if</span> root<span class="token punctuation">.</span>Left <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        minD <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span><span class="token function">minDepth</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>Left<span class="token punctuation">)</span><span class="token punctuation">,</span> minD<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 递归求右子树的最小高度</span>    <span class="token keyword">if</span> root<span class="token punctuation">.</span>Right <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        minD <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span><span class="token function">minDepth</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>Right<span class="token punctuation">)</span><span class="token punctuation">,</span> minD<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 当前二叉树的最小高度等于左右子树的较小高度+1</span>    <span class="token keyword">return</span> minD <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//  写个求较小值的方法</span><span class="token keyword">func</span> <span class="token function">min</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> x <span class="token operator">&lt;</span> y <span class="token punctuation">{</span>        <span class="token keyword">return</span> x    <span class="token punctuation">}</span>    <span class="token keyword">return</span> y<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><p>对于BFS就是首先明确起点和终点，而在这道题中，起点就是根节点，终点就是叶子节点（左右子节点都是nil），然后就可以套模版了。</p><p>模版如下：</p><ol><li>定义队列</li><li>将第一个节点加入队列（起点）</li><li>只要队列不空，循环</li><li>依次从队首拿出元素，判断是否到达终点</li><li>将其相邻节点加入队列</li><li>更新步数</li></ol><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">minDepth</span><span class="token punctuation">(</span>root <span class="token operator">*</span>TreeNode<span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> root <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 这里用了go的一个list库</span>    q <span class="token operator">:=</span> list<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true">// 根节点入队（从根节点开始）</span>    q<span class="token punctuation">.</span><span class="token function">PushBack</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// root本身就是一层，将depth初始化为1</span>    depth <span class="token operator">:=</span> <span class="token number">1</span>    <span class="token comment" spellcheck="true">// 只要队列不空，就遍历队列中的元素</span>    <span class="token keyword">for</span> <span class="token punctuation">;</span> q<span class="token punctuation">.</span><span class="token function">Len</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">{</span>        size <span class="token operator">:=</span> q<span class="token punctuation">.</span><span class="token function">Len</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size <span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 取出队首元素，并删除</span>            front <span class="token operator">:=</span> q<span class="token punctuation">.</span><span class="token function">Front</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            q<span class="token punctuation">.</span><span class="token function">Remove</span><span class="token punctuation">(</span>front<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">// 进行类型断言</span>            node<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> front<span class="token punctuation">.</span>Value<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token operator">*</span>TreeNode<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">// 判断是否到达终点</span>            <span class="token keyword">if</span> node<span class="token punctuation">.</span>Left <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token operator">&amp;&amp;</span> node<span class="token punctuation">.</span>Right <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> depth            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 将左右子节点加入队列</span>            <span class="token keyword">if</span> node<span class="token punctuation">.</span>Left <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>                q<span class="token punctuation">.</span><span class="token function">PushBack</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>Left<span class="token punctuation">)</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> node<span class="token punctuation">.</span>Right <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>                q<span class="token punctuation">.</span><span class="token function">PushBack</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>Right<span class="token punctuation">)</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 往前推进了一层，步数+1</span>        depth <span class="token operator">++</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> depth<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h1><h3 id="DFS-1"><a href="#DFS-1" class="headerlink" title="DFS"></a>DFS</h3><p>时间复杂度：O((N))，其中 N 是树的节点数。对每个节点访问一次。</p><p>空间复杂度：O((H))，其中 H 是树的高度。空间复杂度主要取决于递归时栈空间的开销，最坏情况下，树呈现链状，空间复杂度为 O((N))。平均情况下树的高度与节点数的对数正相关，空间复杂度为 O((logN))。</p><h3 id="BFS-1"><a href="#BFS-1" class="headerlink" title="BFS"></a>BFS</h3><p>时间复杂度：O((N))，其中 N 是树的节点数。对每个节点访问一次。</p><p>空间复杂度：O((N))，其中 N 是树的节点数。空间复杂度主要取决于队列的开销，队列中的元素个数不会超过树的节点数。</p><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><p>这里用到了go的一个库来模拟队列，可以参考</p><p><a href="https://blog.wolfogre.com/posts/slice-queue-vs-list-queue/" target="_blank" rel="noopener">https://blog.wolfogre.com/posts/slice-queue-vs-list-queue/</a></p><blockquote><p>深度优先和广度优先遍历都可以找到最短距离，但是广度优先遍历的时间复杂度更低，深度优先遍历的空间复杂度更低。这是因为在实际情况下，BFS一旦推进到叶子节点就结束了，还没遍历完整棵树。而DFS一定是要遍历完所有节点，然后进行比较才能得出最短路径。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> tree </tag>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【leetcode-654】最大二叉树</title>
      <link href="/2020/12/07/leetcode-654/"/>
      <url>/2020/12/07/leetcode-654/</url>
      
        <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/maximum-binary-tree/" target="_blank" rel="noopener">654. 最大二叉树</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下:</p><ol><li>二叉树的根是数组中的最大元素。</li><li>左子树是通过数组中最大值左边部分构造出的最大二叉树。</li><li>右子树是通过数组中最大值右边部分构造出的最大二叉树。</li></ol><p>通过给定的数组构建最大二叉树，并且输出这个树的根节点。</p><p>示例 ：</p><pre class="line-numbers language-go"><code class="language-go">输入：<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span>输出：返回下面这棵树的根节点：      <span class="token number">6</span>    <span class="token operator">/</span>   \   <span class="token number">3</span>     <span class="token number">5</span>    \    <span class="token operator">/</span>      <span class="token number">2</span>  <span class="token number">0</span>          \        <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>这道题的解题思路比较常规，没有什么特别的技巧，就是遍历数组找到最大值，作为根节点 root，然后对最大值左边的数组和右边的数组进行递归调用，作为 root 的左右子树。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">/** * Definition for a binary tree node. * type TreeNode struct { *     Val int *     Left *TreeNode *     Right *TreeNode * } */</span><span class="token keyword">func</span> <span class="token function">constructMaximumBinaryTree</span><span class="token punctuation">(</span>nums <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">*</span>TreeNode <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">constuct</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">constuct</span><span class="token punctuation">(</span>nums <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> low<span class="token punctuation">,</span> high <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">*</span>TreeNode <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 说明当前要找的数组已经没有元素了</span>    <span class="token keyword">if</span> low <span class="token operator">></span> high <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">nil</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 找到最大值的下标</span>    index <span class="token operator">:=</span> <span class="token function">findMaxNodeIndex</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 根据最大值构造根节点</span>    root <span class="token operator">:=</span> <span class="token function">new</span><span class="token punctuation">(</span>TreeNode<span class="token punctuation">)</span>    root<span class="token punctuation">.</span>Val <span class="token operator">=</span> nums<span class="token punctuation">[</span>index<span class="token punctuation">]</span>    <span class="token comment" spellcheck="true">// 左右递归遍历构造左右子树，注意数组边界（+1和-1）</span>    root<span class="token punctuation">.</span>Left <span class="token operator">=</span> <span class="token function">constuct</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> low<span class="token punctuation">,</span> index<span class="token number">-1</span><span class="token punctuation">)</span>    root<span class="token punctuation">.</span>Right <span class="token operator">=</span> <span class="token function">constuct</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> high<span class="token punctuation">)</span>    <span class="token keyword">return</span> root<span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 返回指定数组中最大值的那个下标</span><span class="token keyword">func</span> <span class="token function">findMaxNodeIndex</span><span class="token punctuation">(</span>nums <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> low<span class="token punctuation">,</span> high <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span>    index <span class="token operator">:=</span> low    <span class="token keyword">for</span> i <span class="token operator">:=</span> low<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> high <span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token punctuation">{</span>            index <span class="token operator">=</span> i        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> index<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>反思：在搭建好框架后还要处理一些细节问题，比如 “=” 取不取得到，要不要 “+1” 或者 “-1” 等，这些细节问题可能还需要debug的时候一点点去抠</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【leetcode-114】二叉树展开为链表</title>
      <link href="/2020/12/04/leetcode-114/"/>
      <url>/2020/12/04/leetcode-114/</url>
      
        <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/" target="_blank" rel="noopener">114. 二叉树展开为链表</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个二叉树，原地将它展开为一个单链表。</p><p>例如，给定二叉树：</p><pre class="line-numbers language-go"><code class="language-go">    <span class="token number">1</span>   <span class="token operator">/</span> \  <span class="token number">2</span>   <span class="token number">5</span> <span class="token operator">/</span> \   \<span class="token number">3</span>   <span class="token number">4</span>   <span class="token number">6</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将其展开为：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token number">1</span> \  <span class="token number">2</span>   \    <span class="token number">3</span>     \      <span class="token number">4</span>       \        <span class="token number">5</span>         \          <span class="token number">6</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>这道题只要稍微观察一下就可以发现链表中元素的顺序刚好是二叉树进行前序遍历的顺序，但是还需要注意的一点是，由于将二叉树展开成一个链表会破坏二叉树的结构，所以这里我们还需要一个额外的切片来存储这些节点。</p><p>至此，这道题的解题思路就出来了</p><ol><li>开辟一个切片用于保存节点。</li><li>对二叉树进行前序遍历。</li><li>遍历到根节点的时候将节点放到切片中。</li><li>最后按照切片的顺序将相邻节点依次首尾相连成一个链表。</li></ol><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">/** * Definition for a binary tree node. * type TreeNode struct { *     Val int *     Left *TreeNode *     Right *TreeNode * } */</span><span class="token keyword">func</span> <span class="token function">flatten</span><span class="token punctuation">(</span>root <span class="token operator">*</span>TreeNode<span class="token punctuation">)</span>  <span class="token punctuation">{</span>   list <span class="token operator">:=</span> <span class="token function">preOrderTraverse</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 按照切片的顺序重新组装这些节点</span>   <span class="token keyword">for</span> i<span class="token operator">:=</span><span class="token number">1</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span> <span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>       <span class="token comment" spellcheck="true">// 相邻元素首尾相连，</span>       pre<span class="token punctuation">,</span> post <span class="token operator">:=</span> list<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> list<span class="token punctuation">[</span>i<span class="token punctuation">]</span>       <span class="token comment" spellcheck="true">// 注意原节点的left要置为空，否则就不是链表了</span>       pre<span class="token punctuation">.</span>Left<span class="token punctuation">,</span> pre<span class="token punctuation">.</span>Right <span class="token operator">=</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> post   <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">preOrderTraverse</span><span class="token punctuation">(</span>root <span class="token operator">*</span>TreeNode<span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>TreeNode <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 开辟一个新的切片用于保存节点</span>    list <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>TreeNode<span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 按照前序遍历的顺序递归访问这些节点</span>    <span class="token keyword">if</span> root <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 访问根节点时将这个节点append到数组中</span>        list <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> root<span class="token punctuation">)</span>        list <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> <span class="token function">preOrderTraverse</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>Left<span class="token punctuation">)</span><span class="token operator">...</span><span class="token punctuation">)</span>        list <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> <span class="token function">preOrderTraverse</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>Right<span class="token punctuation">)</span><span class="token operator">...</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> list<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> tree </tag>
            
            <tag> 前序遍历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【leetcode-116】填充每个节点的下一个右侧节点指针</title>
      <link href="/2020/12/04/leetcode-116/"/>
      <url>/2020/12/04/leetcode-116/</url>
      
        <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/" target="_blank" rel="noopener">116. 填充每个节点的下一个右侧节点指针</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">struct</span> Node <span class="token punctuation">{</span>  <span class="token builtin">int</span> val<span class="token punctuation">;</span>  Node <span class="token operator">*</span>left<span class="token punctuation">;</span>  Node <span class="token operator">*</span>right<span class="token punctuation">;</span>  Node <span class="token operator">*</span>next<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p><p>初始状态下，所有 next 指针都被设置为 NULL。</p><p>进阶：</p><ul><li>你只能使用常量级额外空间。</li><li>使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</li></ul><p>示例：</p><p><img src="https://assets.leetcode.com/uploads/2019/02/14/116_sample.png" alt></p><pre><code>输入：root = [1,2,3,4,5,6,7]输出：[1,#,2,3,#,4,5,6,7,#]解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化的输出按层序遍历排列，同一层节点由 next 指针连接，&#39;#&#39; 标志着每一层的结束。</code></pre><p>提示：</p><ul><li>树中节点的数量少于 4096</li><li>-1000 &lt;= node.val &lt;= 1000</li></ul><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>二叉树的解题分三步走：</p><ol><li>一般节点应该做什么</li><li>叶子节点应该做什么</li><li>前序、中序还是后序</li></ol><p>对于这道题一般节点需要将它的左子树根节点的 next 域指向右子树的根节点</p><p>然后对于叶子节点依旧是直接返回自身即可</p><p>至于遍历次序的话可以先都试试看～</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>于是我们很快就能写出如下答案:</p><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">/** * Definition for a Node. * type Node struct { *     Val int *     Left *Node *     Right *Node *     Next *Node * } */</span><span class="token keyword">func</span> <span class="token function">connect</span><span class="token punctuation">(</span>root <span class="token operator">*</span>Node<span class="token punctuation">)</span> <span class="token operator">*</span>Node <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 为了防止下面的操作出现空指针报错</span>    <span class="token keyword">if</span> root <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token operator">||</span> root<span class="token punctuation">.</span>Left <span class="token operator">==</span> <span class="token boolean">nil</span>  <span class="token punctuation">{</span>        <span class="token keyword">return</span> root    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//左子树根节点的 next 域指向右子树的根节点</span>    root<span class="token punctuation">.</span>Left<span class="token punctuation">.</span>Next <span class="token operator">=</span> root<span class="token punctuation">.</span>Right    <span class="token function">connect</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>Left<span class="token punctuation">)</span>    <span class="token function">connect</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>Right<span class="token punctuation">)</span>    <span class="token keyword">return</span> root<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>需要注意的是，对于叶子节点的判断，由于存在 root.Left.Next 这个逻辑，意味着root.Left不能为空，在一开始需要加上这个判断，否则会报空指针错误</p></blockquote><p>当我们写出如上代码进行提交时，会得到如下结果：</p><pre class="line-numbers language-go"><code class="language-go">输入<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span>输出<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span>#<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span>#<span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span>#<span class="token punctuation">]</span>预期结果<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span>#<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span>#<span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span>#<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们会发现5号节点的后面直接是空，而不是7号节点，原来是因为5号和6号并不在同一棵子树中（他们的父节点不是同一个），因此需要考虑这种特殊情况。</p><p>完善后的代码如下：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">/** * Definition for a Node. * type Node struct { *     Val int *     Left *Node *     Right *Node *     Next *Node * } */</span><span class="token keyword">func</span> <span class="token function">connect</span><span class="token punctuation">(</span>root <span class="token operator">*</span>Node<span class="token punctuation">)</span> <span class="token operator">*</span>Node <span class="token punctuation">{</span>    <span class="token keyword">if</span> root <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token operator">||</span> root<span class="token punctuation">.</span>Left <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> root    <span class="token punctuation">}</span>    root<span class="token punctuation">.</span>Left<span class="token punctuation">.</span>Next <span class="token operator">=</span> root<span class="token punctuation">.</span>Right    <span class="token comment" spellcheck="true">// 增加了不在同一棵子树的情况，注意防止出现空指针报错</span>    <span class="token keyword">if</span> root<span class="token punctuation">.</span>Next <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>Right <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        root<span class="token punctuation">.</span>Right<span class="token punctuation">.</span>Next <span class="token operator">=</span> root<span class="token punctuation">.</span>Next<span class="token punctuation">.</span>Left    <span class="token punctuation">}</span>    <span class="token function">connect</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>Left<span class="token punctuation">)</span>    <span class="token function">connect</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>Right<span class="token punctuation">)</span>    <span class="token keyword">return</span> root<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>反思：二叉树的题目重在观察，有时候我们可以快速写出题解，但是答案却不对，这个时候或许需要注意考虑一些特殊情况</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【leetcode-226】翻转二叉树</title>
      <link href="/2020/12/02/leetcode-226/"/>
      <url>/2020/12/02/leetcode-226/</url>
      
        <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h1><p><a href="https://leetcode-cn.com/problems/invert-binary-tree/" target="_blank" rel="noopener">226. 翻转二叉树</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>翻转一棵二叉树。</p><p>示例：</p><p>输入：</p><pre class="line-numbers language-go"><code class="language-go">     <span class="token number">4</span>   <span class="token operator">/</span>   \  <span class="token number">2</span>     <span class="token number">7</span> <span class="token operator">/</span> \   <span class="token operator">/</span> \<span class="token number">1</span>   <span class="token number">3</span> <span class="token number">6</span>   <span class="token number">9</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出：</p><pre class="line-numbers language-go"><code class="language-go">     <span class="token number">4</span>   <span class="token operator">/</span>   \  <span class="token number">7</span>     <span class="token number">2</span> <span class="token operator">/</span> \   <span class="token operator">/</span> \<span class="token number">9</span>   <span class="token number">6</span> <span class="token number">3</span>   <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>观察两棵二叉树，我们会发现对于第一棵树，只要把每个节点的左右子节点进行交换就能得到第二棵树，接下来就是套用二叉树的模版了，当然在写代码前我们还需要考虑：</p><ol><li>如何实现两个节点的交换？</li><li>选择前序遍历、中序便利还是后序遍历？</li><li>对于叶子节点应该怎么操作？</li></ol><p>想明白了以上几个问题，就可以写题解了。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">/** * Definition for a binary tree node. * type TreeNode struct { *     Val int *     Left *TreeNode *     Right *TreeNode * } */</span><span class="token keyword">func</span> <span class="token function">invertTree</span><span class="token punctuation">(</span>root <span class="token operator">*</span>TreeNode<span class="token punctuation">)</span> <span class="token operator">*</span>TreeNode <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 如果根节点是空，不用翻转了，直接返回</span>    <span class="token keyword">if</span> root <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">nil</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 交换左右子树节点</span>    temp <span class="token operator">:=</span> root<span class="token punctuation">.</span>Left    root<span class="token punctuation">.</span>Left <span class="token operator">=</span> root<span class="token punctuation">.</span>Right    root<span class="token punctuation">.</span>Right <span class="token operator">=</span> temp    <span class="token comment" spellcheck="true">// 再递归交换左右子树</span>    <span class="token function">invertTree</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>Left<span class="token punctuation">)</span>    <span class="token function">invertTree</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>Right<span class="token punctuation">)</span>    <span class="token keyword">return</span> root<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>值得一提的是，这道题用前序和后序遍历是可以的，而中序遍历则不行（为什么）</p></blockquote><p>二叉树题目的一个难点就是，如何把题目的要求细化成每个节点需要做的事情，像这道题就是相当于交换每个节点的左右子节点。</p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fabric 链上数据防篡改</title>
      <link href="/2020/08/15/tamper-with-data/"/>
      <url>/2020/08/15/tamper-with-data/</url>
      
        <content type="html"><![CDATA[<blockquote><p>近日，因为工作需要，对 fabric 数据防篡改机制进行了研究，这里提供了一种验证链上数据防篡改的场景以供参考</p></blockquote><h1 id="基本思路："><a href="#基本思路：" class="headerlink" title="基本思路："></a>基本思路：</h1><p>进入某个peer节点修改本地的 Couch DB 数据，修改完后再调用链码发送一笔交易，发现执行结果是该 peer 节点的数据重新变为修改前的数据，说明篡改数据失败，系统具有放篡改能力。</p><p>具体操作如下，为了简化操作，直接借助官方使用 couchdb 样例，链码为 mymarble</p><p>先进入 firstnetwork 目录，执行以下命令起一个使用 couchdb 的byfn网络</p><pre><code>./byfn.sh up -c mychannel -s couchdb</code></pre><p>然后进入客户端</p><pre><code>docker exec -it cli bashexport CHANNEL_NAME=mychannel</code></pre><p>执行以下命令</p><pre><code># peer0.org1 安装链码CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/mspCORE_PEER_ADDRESS=peer0.org1.example.com:7051CORE_PEER_LOCALMSPID=&quot;Org1MSP&quot;CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crtpeer chaincode install -n  mymarble  -v 1.0.0  -p github.com/chaincode/marbles02/go# peer1.org1 安装链码CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/mspCORE_PEER_ADDRESS=peer1.org1.example.com:8051CORE_PEER_LOCALMSPID=&quot;Org1MSP&quot;CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer1.org1.example.com/tls/ca.crtpeer chaincode install -n  mymarble  -v 1.0.0  -p github.com/chaincode/marbles02/go# peer0.org2 安装链码CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/mspCORE_PEER_ADDRESS=peer0.org2.example.com:9051CORE_PEER_LOCALMSPID=&quot;Org2MSP&quot;CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crtpeer chaincode install -n  mymarble  -v 1.0.0  -p github.com/chaincode/marbles02/go# peer1.org2 安装链码CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/mspCORE_PEER_ADDRESS=peer1.org2.example.com:10051CORE_PEER_LOCALMSPID=&quot;Org2MSP&quot;CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer1.org2.example.com/tls/ca.crtpeer chaincode install -n  mymarble  -v 1.0.0  -p github.com/chaincode/marbles02/go# 实例化链链码peer chaincode instantiate -o orderer.example.com:7050 --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C mychannel -n mymarble -v 1.0.0 -c &#39;{&quot;Args&quot;:[&quot;init&quot;]}&#39; -P &quot;AND (&#39;Org1MSP.peer&#39;,&#39;Org2MSP.peer&#39;)&quot;peer chaincode invoke -o orderer.example.com:7050 --tls true --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C $CHANNEL_NAME -n mymarble --peerAddresses peer0.org1.example.com:7051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt --peerAddresses peer0.org2.example.com:9051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt -c &#39;{&quot;Args&quot;:[&quot;initMarble&quot;,&quot;marble1&quot;,&quot;blue&quot;,&quot;35&quot;,&quot;tom&quot;]}&#39;</code></pre><p>此时打开浏览器 <a href="http://localhost:5984/_utils/" target="_blank" rel="noopener">http://localhost:5984/_utils/</a></p><p>进入 peer0.org1 （对外暴露端口为5984）的 couchdb，查看 marble1 变量：</p><pre><code>{  &quot;_id&quot;: &quot;marble1&quot;,  &quot;_rev&quot;: &quot;1-1d12a3e8f79f5c0e40cc73c43701a6ba&quot;,  &quot;color&quot;: &quot;blue&quot;,  &quot;docType&quot;: &quot;marble&quot;,  &quot;name&quot;: &quot;marble1&quot;,  &quot;owner&quot;: &quot;tom&quot;,  &quot;size&quot;: 35,  &quot;~version&quot;: &quot;\u0000CgMBBgA=&quot;}</code></pre><p>我们可以看到在 couchdb 中保存了 marble1 的各个字段的属性。</p><p>然后手动将其中的 35 改为25，并保存（试图通过修改peer本地的couchdb中的数据实现篡改数据的操作）。</p><p>此时在终端调用以下链码，即将 marble1 给 jerry</p><pre><code>peer chaincode invoke -o orderer.example.com:7050 --tls true --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C $CHANNEL_NAME -n mymarble --peerAddresses peer0.org1.example.com:7051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt --peerAddresses peer0.org2.example.com:9051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt -c &#39;{&quot;Args&quot;:[&quot;transferMarble&quot;,&quot;marble1&quot;,&quot;jerry&quot;]}&#39;</code></pre><h5 id="注意此时指定的背书节点为-peer0-org1-和-peer0-org2"><a href="#注意此时指定的背书节点为-peer0-org1-和-peer0-org2" class="headerlink" title="注意此时指定的背书节点为 peer0.org1 和 peer0.org2"></a>注意此时指定的背书节点为 peer0.org1 和 peer0.org2</h5><p><img src="https://note.youdao.com/yws/public/resource/bc554143fcca768f52bf1354ffef92eb/xmlnote/619D267654E5418CA1199D1E0060BEA7/3390" alt></p><p>发现调用失败，返回背书不满足<br>这主要是因为 peer0.org1 的 couchdb 的数据已经改变，和 peer0.org1 的数据不同，导致模拟执行失败</p><p>此时，将其中一个背书节点背书节点 peer0.org1 替换成 peer1.org1，此时再次调用链码</p><pre><code>peer chaincode invoke -o orderer.example.com:7050 --tls true --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C $CHANNEL_NAME -n mymarble --peerAddresses peer1.org1.example.com:8051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer1.org1.example.com/tls/ca.crt --peerAddresses peer0.org2.example.com:9051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt -c &#39;{&quot;Args&quot;:[&quot;transferMarble&quot;,&quot;marble1&quot;,&quot;jerry&quot;]}&#39;</code></pre><p>链码调用成功</p><p>再次进入peer0.org1的couchdb，对外暴露端口为5984</p><p><a href="http://localhost:5984/_utils/" target="_blank" rel="noopener">http://localhost:5984/_utils/</a></p><p>发现此时 marble1  的owner 已经变为jerry，并且仍然是35</p><pre><code>{  &quot;_id&quot;: &quot;marble1&quot;,  &quot;_rev&quot;: &quot;3-c2280ec7b75f7f5536b490acf10515a0&quot;,  &quot;color&quot;: &quot;blue&quot;,  &quot;docType&quot;: &quot;marble&quot;,  &quot;name&quot;: &quot;marble1&quot;,  &quot;owner&quot;: &quot;jerry&quot;,  &quot;size&quot;: 35,  &quot;~version&quot;: &quot;\u0000CgMBBwA=&quot;}</code></pre><p>说明试图篡改数据的操作失败，系统具有防篡改能力</p>]]></content>
      
      
      
        <tags>
            
            <tag> fabric </tag>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fabric 2.2 生命周期链码实战</title>
      <link href="/2020/08/08/fabric-chaincode-2-2/"/>
      <url>/2020/08/08/fabric-chaincode-2-2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>fabric 2.2和1.4的一个重要不同就是进一步完善了对链码的生命周期管理</p></blockquote><h1 id="打包（package）"><a href="#打包（package）" class="headerlink" title="打包（package）"></a>打包（package）</h1><p>必须先打包链码，然后才能将其安装在peer节点上。可以使用 peer lifecycle chaincode package 命令打包Go链码。</p><ul><li><p>使用 –path 标志指示链码的位置。该路径必须是标准路径或相对于您当前工作目录的路径。</p></li><li><p>使用 –label 标志指定 stupid 作为组织用于标识的被打包的链码的标签。</p></li></ul><pre><code>peer lifecycle chaincode package stupid.tar.gz --path github.com/chaincode/stupid --lang golang --label stupid</code></pre><h1 id="安装（install）"><a href="#安装（install）" class="headerlink" title="安装（install）"></a>安装（install）</h1><p>打包链码后，可以使用 peer chaincode install 命令在 peer 节点上安装链码。</p><ul><li>将stupid.tar.gz软件包安装在 peer0.org1.example.com 上。</li></ul><pre><code>peer lifecycle chaincode install stupid.tar.gz2020-08-07 03:29:49.473 UTC [cli.lifecycle.chaincode] submitInstallProposal -&gt; INFO 001 Installed remotely: response:&lt;status:200 payload:&quot;\nGstupid:27a22f86b653f2fd487a41af58404de8cdac47b4c09dddecc16fef2f7f60e2c2\022\006stupid&quot; &gt;2020-08-07 03:29:49.477 UTC [cli.lifecycle.chaincode] submitInstallProposal -&gt; INFO 002 Chaincode code package identifier: stupid:27a22f86b653f2fd487a41af58404de8cdac47b4c09dddecc16fef2f7f60e2c2</code></pre><ul><li>切换为 peer1.org1，并安装链码</li></ul><pre><code>export CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/mspexport CORE_PEER_ADDRESS=peer1.org1.example.com:8051export CORE_PEER_LOCALMSPID=&quot;Org1MSP&quot;export CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer1.org1.example.com/tls/ca.crtpeer lifecycle chaincode install stupid.tar.gz</code></pre><ul><li>切换为 peer0.org2，并安装链码</li></ul><pre><code>export CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/mspexport CORE_PEER_ADDRESS=peer0.org2.example.com:9051export CORE_PEER_LOCALMSPID=&quot;Org2MSP&quot;export CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crtpeer lifecycle chaincode install stupid.tar.gz</code></pre><ul><li>切换为 peer1.org2，并安装链码</li></ul><pre><code>export CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/mspexport CORE_PEER_ADDRESS=peer1.org2.example.com:10051export CORE_PEER_LOCALMSPID=&quot;Org2MSP&quot;export CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer1.org2.example.com/tls/ca.crtpeer lifecycle chaincode install stupid.tar.gz</code></pre><ul><li>检查是否安装成功</li></ul><pre><code>export CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/mspexport CORE_PEER_ADDRESS=peer1.org1.example.com:8051export CORE_PEER_LOCALMSPID=&quot;Org1MSP&quot;export CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer1.org1.example.com/tls/ca.crtpeer lifecycle chaincode queryinstalled --peerAddresses peer0.org1.example.com:7051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crtInstalled chaincodes on peer:Package ID: stupid:27a22f86b653f2fd487a41af58404de8cdac47b4c09dddecc16fef2f7f60e2c2, Label: stupid</code></pre><p>安装链码成功后会返回一个标识符，这个标识符与在下一步会用到。<br>链码标签和哈希值构成了标识符。</p><h1 id="批准（approve）"><a href="#批准（approve）" class="headerlink" title="批准（approve）"></a>批准（approve）</h1><p>在peer节点上安装了chaincode程序包后，可以批准组织的链码定义。链码定义包括链码管理的重要参数，包括链码名称，版本和认可策略等。</p><p>这是命令的示例，该命令批准在channel 版本上命名的链码的定义。</p><ul><li>使用 –package-id 标志传递链码包标识符。</li><li>使用 –signature-policy标志定义链码的背书策略。</li><li>使用 –init-required标志请求执行 Init 函数初始化链码。</li></ul><p>需要注意的是，每个组织都需要进行一次approveformyorg操作，具体需要由组织内的任意一个具有管理员权限的节点来进行即可：</p><p>切换 peer0.org1.example.com，进行approveformyorg 操作，批准链码定义：</p><pre><code>export CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/mspexport CORE_PEER_ADDRESS=peer0.org1.example.com:7051export CORE_PEER_LOCALMSPID=&quot;Org1MSP&quot;export CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crtpeer lifecycle chaincode approveformyorg  -o orderer.example.com:7050 --tls true --cafile $ORDERER_CA --channelID mychannel --name stupid --version 1.0 --init-required --package-id stupid:27a22f86b653f2fd487a41af58404de8cdac47b4c09dddecc16fef2f7f60e2c2 --sequence 1 --signature-policy &quot;AND (&#39;Org1MSP.peer&#39;,&#39;Org2MSP.peer&#39;)&quot; --waitForEvent</code></pre><p>结果输出以下内容：</p><pre><code>2020-08-07 03:47:33.708 UTC [chaincodeCmd] ClientWait -&gt; INFO 001 txid [5f92b2c3b14ddc80829c9c89bc602069a3fd868ec358c4d5d329ccb8dee0b530] committed with status (VALID) at</code></pre><p>然后我们再切换到 peer0.org2.example.com 进行一次 approveformyorg 操作</p><p>切换 peer0.org2.example.com，并批准链码定义</p><pre><code>export CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/mspexport CORE_PEER_ADDRESS=peer0.org2.example.com:9051export CORE_PEER_LOCALMSPID=&quot;Org2MSP&quot;export CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crtexport ORDERER_CA=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pempeer lifecycle chaincode approveformyorg  -o orderer.example.com:7050 --tls --cafile $ORDERER_CA --channelID mychannel --name stupid --version 1.0 --init-required --package-id stupid:27a22f86b653f2fd487a41af58404de8cdac47b4c09dddecc16fef2f7f60e2c2 --sequence 1 --signature-policy &quot;AND (&#39;Org1MSP.peer&#39;,&#39;Org2MSP.peer&#39;)&quot; --waitForEvent</code></pre><ul><li><p>检查是否批准成功</p><pre><code>peer lifecycle chaincode checkcommitreadiness -o orderer.example.com:7050 --channelID mychannel --tls --cafile $ORDERER_CA --name stupid --version 1.0 --init-required --sequence 1 --output json</code></pre></li><li><p>输出结果如下：</p><pre><code>{  &quot;approvals&quot;: {      &quot;Org1MSP&quot;: false,      &quot;Org2MSP&quot;: false  }}</code></pre></li></ul><p>这里显示都是 false，说明批准并未成功，此时可以再尝试进行一次approformyorg 操作，结果如下：</p><pre><code>Error: proposal failed with status: 500 - failed to invoke backing implementation of &#39;ApproveChaincodeDefinitionForMyOrg&#39;: attempted to redefine uncommitted sequence (1) for namespace stupid with unchanged content</code></pre><p>出现这种情况说明存在当前最新的合约没有commit，无法进行新的approve，换句话说就是对同一个链码在同一家组织进行了两次approve操作，而这是不被允许的，说明之前的 approve 操作是成功的，这就与“批准并未成功”的结论矛盾了，到底有没有成功呢？</p><p>请注意，这里是一个比较坑的地方，因为这可能是一个bug，实际上已经approve成功了，但是checkcommitreadiness却显示为false，此时，我们可以先往下走，直接进入commit阶段，如果没问题的话，就接着往下走。</p><p>目前尚不清楚这个是我操作的原因还是fabric 2.x 的一个bug，因为网上有其他人也跟我遇到了同样的问题。</p><h1 id="提交（commit）"><a href="#提交（commit）" class="headerlink" title="提交（commit）"></a>提交（commit）</h1><p>一旦足够多的组织批准了其组织的链代码定义（默认情况下为大多数），则一个组织可以使用 peer lifecycle chaincode commit 命令将该定义提交给渠道。</p><p>该命令需要针对通道上其他组织的peer节点，以收集其组织对定义的认可。</p><pre><code>export ORDERER_CA=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pempeer lifecycle chaincode commit -o orderer.example.com:7050 --channelID mychannel --name stupid --version 1.0 --sequence 1 --init-required --tls true --cafile $ORDERER_CA --peerAddresses peer0.org1.example.com:7051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt --peerAddresses peer0.org2.example.com:9051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt --signature-policy &quot;AND (&#39;Org1MSP.peer&#39;,&#39;Org2MSP.peer&#39;)&quot;</code></pre><p>此处是不是可以不指定 peerAddresses，还有待验证…</p><p>输出结果如下：</p><pre><code>2020-08-08 08:56:13.430 UTC [chaincodeCmd] ClientWait -&gt; INFO 001 txid [837c1b5e18ca5e8e2f2a0ec9f98bbdfcf74585e8c2c2e77047e3d11b44ad9344] committed with status (VALID) at peer0.org1.example.com:70512020-08-08 08:56:13.782 UTC [chaincodeCmd] ClientWait -&gt; INFO 002 txid [837c1b5e18ca5e8e2f2a0ec9f98bbdfcf74585e8c2c2e77047e3d11b44ad9344] committed with status (VALID) at peer0.org2.example.com:9051</code></pre><p>查询是否提交成功：</p><pre><code>peer lifecycle chaincode querycommitted -o orderer.example.com:7050 --channelID mychannel --name stupid --tls --cafile $ORDERER_CA</code></pre><p>结果如下，说明提交成功。</p><pre><code>Committed chaincode definition for chaincode &#39;stupid&#39; on channel &#39;mychannel&#39;:Version: 1.0, Sequence: 1, Endorsement Plugin: escc, Validation Plugin: vscc, Approvals: [Org1MSP: true, Org2MSP: true]</code></pre><p>也可以只指定通道名称，不指定链码名称，那样查询的就是该通道上所有链码的定义。</p><p> 注意commit需要指定签名背书策略，并且需要和链码 approveformyorg 阶段的背书策略一致。</p><pre><code> --signature-policy &quot;AND (&#39;Org1MSP.peer&#39;,&#39;Org2MSP.peer&#39;)&quot;</code></pre><p> 如果少了这个会报如下错误：</p><pre><code> Error: proposal failed with status: 500 - failed to invoke backing implementation of &#39;CommitChaincodeDefinition&#39;: chaincode definition not agreed to by this org (Org1MSP)</code></pre><p>查询链码和调用链码与 1.4 版本相同。</p><h1 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h1><pre><code>peer chaincode invoke -o orderer.example.com:7050 --tls true --cafile $ORDERER_CA -C mychannel -n stupid  -c &#39;{&quot;Args&quot;:[&quot;put&quot;,&quot;a&quot;,&quot;10&quot;]}&#39;</code></pre><p>结果如下：</p><pre><code>Error: endorsement failure during invoke. response: status:500 message:&quot;error in simulation: failed to execute transaction a1465e679dcd1559a7077ec13c45c4db72f8bd73b6aaa4af9fc1127797e96bb1: invalid invocation: chaincode &#39;stupid&#39; has not been initialized for this version, must call as init first&quot;</code></pre><p>说明这里需要执行的第一个函数是init，然后才能执行其他调用链码的操作，这里我们试图执行以下操作进行init：</p><pre><code>peer chaincode instantiate -o orderer.example.com:7050 --tls true --cafile $ORDERER_CA -C mychannel -n stupid -v 1.0 -c &#39;{&quot;Args&quot;:[&quot;init&quot;]}&#39;</code></pre><p>结果如下：</p><pre><code>2020-08-08 09:42:42.029 UTC [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 001 Using default escc2020-08-08 09:42:42.031 UTC [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 002 Using default vsccError: could not assemble transaction, err proposal response was not successful, error code 500, msg Channel &#39;mychannel&#39; has been migrated to the new lifecycle, LSCC is now read-only</code></pre><p>失败了，当前通道已经迁移到 lifecycle 了， 不能执行实例化操作。</p><p>此处需要增加 –isInit 参数，表面此处是初始化链码：</p><pre><code>peer chaincode invoke --isInit -o orderer.example.com:7050 --tls true --cafile $ORDERER_CA -C mychannel -n stupid  -c &#39;{&quot;Args&quot;:[&quot;put&quot;,&quot;a&quot;,&quot;10&quot;]}&#39;</code></pre><p>调用成功：</p><pre><code>2020-08-08 09:58:20.911 UTC [chaincodeCmd] chaincodeInvokeOrQuery -&gt; INFO 001 Chaincode invoke successful. result: status:200</code></pre><h1 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h1><pre><code>peer chaincode invoke -o orderer.example.com:7050 --tls ture --cafile $ORDERER_CA -C mychannel -n stupid  -c &#39;{&quot;Args&quot;:[&quot;get&quot;,&quot;a&quot;]}&#39;</code></pre><p>结果如下：</p><pre><code>2020-08-08 10:00:22.583 UTC [chaincodeCmd] chaincodeInvokeOrQuery -&gt; INFO 001 Chaincode invoke successful. result: status:200</code></pre><h1 id="踩坑指南"><a href="#踩坑指南" class="headerlink" title="踩坑指南"></a>踩坑指南</h1><p>在打包链码的时候遇到问题</p><pre><code>Error: error getting chaincode deployment spec for stupid: error getting chaincode package bytes: failed to calculate dependencies: incomplete package: github.com/hyperledger/fabric/core/chaincode/shim</code></pre><p>解决办法参考<br><a href="https://www.bcskill.com/index.php/archives/925.html" target="_blank" rel="noopener">https://www.bcskill.com/index.php/archives/925.html</a></p><ol><li><p>先下载依赖</p><pre><code> git clone github.com/hyperledger/fabric-chaincode-go/shim git clone github.com/hyperledger/fabric-protos-go/peer</code></pre></li><li><p>修改import包，将</p><pre><code> &quot;github.com/hyperledger/fabric/core/chaincode/shim&quot; pb &quot;github.com/hyperledger/fabric/protos/peer&quot;</code></pre><p> 改成</p><pre><code> &quot;github.com/hyperledger/fabric-chaincode-go/shim&quot; pb &quot;github.com/hyperledger/fabric-protos-go/peer&quot;</code></pre></li><li><p>并在链码文件的同级目录新建go.mod</p></li><li><p>更新依赖</p><pre><code> go mod vendor</code></pre></li><li><p>重启节点，执行打包链码的命令</p></li></ol><p>参考资料</p><p><a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/commands/peerlifecycle.html#example-usage" target="_blank" rel="noopener">Example Usage</a></p><p><a href="https://juejin.im/post/6844904070390480910" target="_blank" rel="noopener">Fabric2.0智能合约实践-设置背书策略</a></p><p><a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/chaincode_lifecycle.html#fabric-chaincode-lifecycle" target="_blank" rel="noopener">Fabric chaincode lifecycle</a></p>]]></content>
      
      
      <categories>
          
          <category> fabric </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fabric </tag>
            
            <tag> chaincode </tag>
            
            <tag> 2.2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fabric 2.2 的新特性</title>
      <link href="/2020/08/08/fabric-newfeature-2-2/"/>
      <url>/2020/08/08/fabric-newfeature-2-2/</url>
      
        <content type="html"><![CDATA[<h1 id="2-2-的新特性"><a href="#2-2-的新特性" class="headerlink" title="2.2 的新特性"></a>2.2 的新特性</h1><h2 id="1-分权的chaincode⽣命周期的管理"><a href="#1-分权的chaincode⽣命周期的管理" class="headerlink" title="1. 分权的chaincode⽣命周期的管理"></a>1. 分权的chaincode⽣命周期的管理</h2><p>详⻅ 2.0 beta版的chaincode⽣命周期管理</p><ul><li>多数组织需要同意chaincode的相关参数，⽐⽅说policy等。 </li><li>更慎重的chaincode升级过程（需要组织重新同意chaincode的相关参数）。 </li><li>更简便地升级policy或者私密数据配置（不⽤重新安装合约，可以直接从让多家组织同意新的参数开始，也就是升级参数的 话，chaincode的version可以不变） </li><li>可检查的chaincode包（需要先打包chaincode，再安装） </li><li>不同成员的同⼀个chaincode的源码可以不同（可以使⽤不同的语⾔编写，或者同⼀语⾔逻辑不同） </li></ul><h2 id="2-新的chaincode部署形式"><a href="#2-新的chaincode部署形式" class="headerlink" title="2. 新的chaincode部署形式"></a>2. 新的chaincode部署形式</h2><ul><li>删除对docker daemon的依赖。</li><li>增加了除了docker容器外的其他运⾏chaincode的选择。</li><li>提供了外部创建chaincode的接⼝，可以⾃⼰实现其他的chaincode的创建和部署过程。 </li><li>chaincode可以作为⼀个外部服务</li></ul><h2 id="3-私密数据的增强"><a href="#3-私密数据的增强" class="headerlink" title="3. 私密数据的增强"></a>3. 私密数据的增强</h2><p>详⻅2.0beta版私密数据新特性</p><ul><li>分享和验证私密数据。拥有私密数据的⼀⽅可以将私密数据分享给没有权限的⼀⽅，接收⽅可以通过调⽤GetPrivateDataHash<br>来验证私密数据的正确性。</li><li>新增collection级别的背书策略。</li><li>隐形的组织级别的collection。如果是单组织使⽤的私密数据，collection可以不⽤显性地去定义就可以直接使⽤。</li></ul><h2 id="4-CouchDB增加缓存来提升性能"><a href="#4-CouchDB增加缓存来提升性能" class="headerlink" title="4. CouchDB增加缓存来提升性能"></a>4. CouchDB增加缓存来提升性能</h2><h2 id="5-更轻量级的docker镜像"><a href="#5-更轻量级的docker镜像" class="headerlink" title="5. 更轻量级的docker镜像"></a>5. 更轻量级的docker镜像</h2><p>改⽤Apline Linux作为底层的操作系统。镜像⼤⼩变⼩了。</p><h2 id="其他变化"><a href="#其他变化" class="headerlink" title="其他变化"></a>其他变化</h2><ul><li>ccenv镜像不再包含shim</li><li>logger从chaincode shim中移除，chaincode的log⼯作交给chaincode开发者⾃⼰处理 </li><li>不再⽀持⽤户的chaincode调⽤系统chaincode </li><li>GetHistoryForKey排序⽅式更改为从新到旧 </li><li>对于orderer来说，之前⽀持的provisional启动⽅式被移除 </li><li>orderer配置的genesismethod和genesisfile改为bootstrapmethod和bootstrapfile</li><li>系统chaincode插件被移除，不可以通过go插件来添加系统chaincode了</li><li>新镜像⾥不⽀持bash</li><li>go版本升级到了1.13.4<font color="green"></font></li><li>添加了背书失败的背书节点的 metrics</li><li>可以在 core.yaml 中通过配置项对背书节点的并发请求数作出限制</li><li>可以在 core.yaml 中通过配置项覆盖私有数据集合分发策略</li><li>服务发现支持在链码私有数据集合级别指定背书策略</li><li>Discover CLI现在支持SEC 1格式的私钥</li><li>依赖更新<ul><li>docker镜像更新到 3.11</li><li>go 版本更新到 1.14.1</li><li>go grpc 更新到 1.28.0</li></ul></li><li>添加对 TLS 1.3 的支持</li><li>添加查询已批准的链码定义的详细信息的功能</li></ul><p><strong>注：标记为绿色的部分为 2.1.0 和 2.2.0 新增的特性，2.0.1 和 2.1.1 版本都是一些 bugfix，没有新的特性。</strong></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/whatsnew.html" target="_blank" rel="noopener">What’s new in Hyperledger Fabric v2.x</a></p>]]></content>
      
      
      <categories>
          
          <category> fabric </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fabric </tag>
            
            <tag> 2.2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fabric 1.4 升级到 2.2 的⽅案</title>
      <link href="/2020/08/08/fabric-upgrade-2-2/"/>
      <url>/2020/08/08/fabric-upgrade-2-2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>v2.2是Fabric v2.x的第一个长期支持（LTS）版本，Fabric的2.1和2.2版本是稳定版本，具有错误修复和其他形式的代码强化功能。从2.0升级到2.2不需要特别的考虑，也不需要特定的镜像版本或通道配置更新。</p></blockquote><h1 id="1-4-升级到-2-2-的主要过程包括（与升级到-2-0-基本一致）"><a href="#1-4-升级到-2-2-的主要过程包括（与升级到-2-0-基本一致）" class="headerlink" title="1.4 升级到 2.2 的主要过程包括（与升级到 2.0 基本一致）"></a>1.4 升级到 2.2 的主要过程包括（与升级到 2.0 基本一致）</h1><ol><li>升级镜像</li><li>升级兼容性配置</li><li>激活 chaincode 的新的⽣命周期管理 </li></ol><h1 id="1-升级镜像"><a href="#1-升级镜像" class="headerlink" title="1. 升级镜像"></a>1. 升级镜像</h1><p>升级镜像主要包括两个步骤： </p><ul><li>备份账本和 MSP 的相关⽂件</li><li>升级镜像⽂件到最新版本 </li></ul><h2 id="1-1-升级-orderer-节点"><a href="#1-1-升级-orderer-节点" class="headerlink" title="1.1 升级 orderer 节点"></a>1.1 升级 orderer 节点</h2><p>对每个 orderer 节点执行以下操作：</p><ol><li>停掉 orderer 节点 </li><li>备份 orderer 节点的账本和 MSP </li><li>移除掉 orderer 节点容器 </li><li>使⽤新镜像创建⼀个 orderer 容器</li></ol><h2 id="1-2-升级-peer-节点"><a href="#1-2-升级-peer-节点" class="headerlink" title="1.2 升级 peer 节点"></a>1.2 升级 peer 节点</h2><ol><li><p>停掉 peer 节点 </p></li><li><p>备份 peer 节点的账本和 MSP </p></li><li><p>移除掉 chaincode 容器（由于 2.0 版本中将 shim 从 fabric ⼯程中移出为单独的⼯程，所以是否删除镜像需要进⾏讨论） </p><ul><li>如果该 chaincode 已经做好了升级准备，那么原来的镜像可以直接删除掉。 </li><li>如果 chaincode 不打算升级，当环境从 1.4 升级到 2.0 后还需要继续使⽤。  <ul><li>不删除chaincode 镜像，那么当升级到2.0后会继续使⽤该镜像创建容器，原 chaincode 可以正常运⾏。</li><li>删除掉了 chaincode 镜像，那么需要对 peer 节点进⾏配置，让其使⽤ ccenv 1.4 版本的镜像来创建chaincode镜像。如 果没有专⻔配置，使⽤了 2.0 版本的 ccenv 的话，会出现错误。（ 因为 2.0 版本 ccenv ⾥没有 shim ），在 base/peer-base.yaml 增加如下内容：<pre><code> - CORE_CHAINCODE_BUILDER=hyperledger/fabric-ccenv:1.4.6</code></pre></li></ul></li></ul></li><li><p>移除掉 peer 节点容器</p></li><li><p>升级 peer 节点的数据库 </p><ul><li>由于 2.0 版本的状态数据库和历史数据库的数据格式与 1.4 有所不同，升级到2.0版本需要对数据库进⾏升级。<pre><code>docker run --rm -v /var/lib/docker/volumes/net_peer0.org1.example.com/_data/:/var/hyperledger/production/ -v /home/centos/gopath/src/github.com/hyperledger/fabric-samples/first-network/crypto-config/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/msp/:/etc/hyperledger/fabric/msp/ --name peer0.org1.example.com hyperledger/fabric-peer:2.0 peer node upgrade-dbs </code></pre></li></ul></li><li><p>使⽤新的镜像创建⼀个 peer 容器</p></li></ol><h3 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h3><ul><li>可以先 ./byfn.sh 起一个 byfn，然后停掉所有 orderer 节点和 peer 节点</li></ul><pre><code>docker-compose -f docker-compose-cli.yaml down</code></pre><ul><li>修改配置文件 base/peer-base.yaml 和 docker-compose-cli.yaml 中的镜像tag</li></ul><pre><code>image: hyperledger/fabric-peer:2.2image: hyperledger/fabric-orderer:2.2image: hyperledger/fabric-tools:2.2</code></pre><ul><li>升级所有 peer 节点的数据库（不升级会报错）</li></ul><pre><code>docker run --rm -v /var/lib/docker/volumes/net_peer0.org1.example.com/_data/:/var/hyperledger/production/ -v /Users/xiongweigang/go/src/github.com/hyperledger/fabric-samples/first-network/crypto-config/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/msp/:/etc/hyperledger/fabric/msp/ --name peer0.org1.example.com hyperledger/fabric-peer:2.2 peer node upgrade-dbsdocker run --rm -v /var/lib/docker/volumes/net_peer1.org1.example.com/_data/:/var/hyperledger/production/ -v /Users/xiongweigang/go/src/github.com/hyperledger/fabric-samples/first-network/crypto-config/peerOrganizations/org1.example.com/peers/peer1.org1.example.com/msp/:/etc/hyperledger/fabric/msp/ --name peer1.org1.example.com hyperledger/fabric-peer:2.2 peer node upgrade-dbsdocker run --rm -v /var/lib/docker/volumes/net_peer0.org2.example.com/_data/:/var/hyperledger/production/ -v /Users/xiongweigang/go/src/github.com/hyperledger/fabric-samples/first-network/crypto-config/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/msp/:/etc/hyperledger/fabric/msp/ --name peer0.org2.example.com hyperledger/fabric-peer:2.2 peer node upgrade-dbsdocker run --rm -v /var/lib/docker/volumes/net_peer1.org2.example.com/_data/:/var/hyperledger/production/ -v /Users/xiongweigang/go/src/github.com/hyperledger/fabric-samples/first-network/crypto-config/peerOrganizations/org2.example.com/peers/peer1.org2.example.com/msp/:/etc/hyperledger/fabric/msp/ --name peer1.org2.example.com hyperledger/fabric-peer:2.2 peer node upgrade-dbs</code></pre><p>最后再重启节点</p><pre><code>docker-compose -f docker-compose-cli.yaml up -d</code></pre><h1 id="2-升级兼容性配置"><a href="#2-升级兼容性配置" class="headerlink" title="2. 升级兼容性配置"></a>2. 升级兼容性配置</h1><p>升级兼容性配置主要包括，升级系统链配置以及升级应⽤链配置两个⽅⾯。 </p><p>在升级过程中可以使⽤ jq 命令来对配置进⾏修改，也可以使⽤其他编辑器对⽂件直接进⾏⼿动的修改。为了⽅便 jq 命令的使 ⽤，⾸先创建⼀个名为capabilities.json的⽂件。⽂件包括以下内容:</p><pre><code>{     &quot;channel&quot;: {         &quot;mod_policy&quot;: &quot;Admins&quot;,             &quot;value&quot;: {                 &quot;capabilities&quot;: {                    &quot;V2_0&quot;: {}                  }            },         &quot;version&quot;: &quot;0&quot;     },    &quot;orderer&quot;: {         &quot;mod_policy&quot;: &quot;Admins&quot;,             &quot;value&quot;: {                 &quot;capabilities&quot;: {                     &quot;V2_0&quot;: {}                 }             },         &quot;version&quot;: &quot;0&quot;     },    &quot;application&quot;: {         &quot;mod_policy&quot;: &quot;Admins&quot;,             &quot;value&quot;: {                 &quot;capabilities&quot;: {                    &quot;V2_0&quot;: {}                 }             },         &quot;version&quot;: &quot;0&quot;     } } </code></pre><h3 id="具体操作-1"><a href="#具体操作-1" class="headerlink" title="具体操作"></a>具体操作</h3><p>进入 cli 容器</p><pre><code>docker exec -it cli bash </code></pre><p>进入 script 文件夹</p><pre><code>cd scripts</code></pre><p>将 capabilities.json 复制到 此文件夹中即 fabric-samples/firstnetwork/scripts 文件夹</p><h2 id="2-1-升级系统链的兼容性配置"><a href="#2-1-升级系统链的兼容性配置" class="headerlink" title="2.1 升级系统链的兼容性配置"></a>2.1 升级系统链的兼容性配置</h2><p>参考脚本updating_capabilities_sys.sh</p><ul><li>⾸先需要对⼀些环境变量进⾏设置<ul><li>CH_NAME :系统链的名称，例如⽬前的 fabric-samples/first-network中的 CH_NAME=byfn-sys-channel </li><li>CORE_PEER_LOCALMSPID :Orderer组织的MSPID，例如⽬前的 fabric-samples/first-network 中的 CORE_PEER_LOCALMSPID=OrdererMSP</li><li>TLS_ROOT_CA : Orderer组织的TLS的CA证书，例如⽬前的 fabric-samples/first-network 中的 TLS_ROOT_CA=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/ orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem </li><li>CORE_PEER_MSPCONFIGPATH :Orderer组织的MSP的配置地址，例如⽬前的fabric-samples/first-network 中的 CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/users/Admin@example.com/msp </li><li>ORDERER_CONTAINER :Orderer组织的容器节点，例如⽬前的fabric-samples/first-network中的 ORDERER_CONTAINER=orderer.example.com:7050</li></ul></li><li>获取系统链原有的配置 <ul><li>获取原有配置<pre><code>peer channel fetch config config_block.pb -o $ORDERER_CONTAINER -c $CH_NAME --tls --cafile $TLS_ROOT_CA</code></pre></li><li>将配置转化为json格式 <pre><code>configtxlator proto_decode --input config_block.pb --type common.Block --output config_block.json</code></pre></li><li>从json中只提取出来配置的部分<pre><code>jq .data.data[0].payload.data.config config_block.json &gt; config.json</code></pre></li></ul></li><li>修改兼容性配置<ul><li>可以使⽤ jq 命令对配置进⾏修改<pre><code>jq -s &#39;.[0] * {&quot;channel_group&quot;:{&quot;groups&quot;:{&quot;Orderer&quot;: {&quot;values&quot;: {&quot;Capabilities&quot;: .[1].orderer}}}}}&#39; config.json ./capabilities.json &gt; modified_config1.jsonjq -s &#39;.[0] * {&quot;channel_group&quot;:{&quot;values&quot;: {&quot;Capabilities&quot;: .[1].channel}}}&#39; modified_config1.json ./capabilities.json &gt; modified_config.json</code></pre></li><li>也可以打开编辑器，将Capabilities相关的配置改为”V2_0”</li></ul></li><li>计算配置的deltaSet，⽣成pb⽂件<ul><li>计算deltaSet<pre><code>configtxlator proto_encode --input config.json --type common.Config --output config.pbconfigtxlator proto_encode --input modified_config.json --type common.Config --output modified_config.pb configtxlator compute_update --channel_id $CH_NAME --original config.pb --updated modified_config.pb --output config_update.pb</code></pre></li><li>⽣成通道更新的pb⽂件<pre><code>configtxlator proto_decode --input config_update.pb --type common.ConfigUpdate --output config_update.jsonecho &#39;{&quot;payload&quot;:{&quot;header&quot;:{&quot;channel_header&quot;:{&quot;channel_id&quot;:&quot;&#39;$CH_NAME&#39;&quot;, &quot;type&quot;:2}},&quot;data&quot;:{&quot;config_update&quot;:&#39;$(cat config_update.json)&#39;}}}&#39; | jq . &gt; config_update_in_envelope.jsonconfigtxlator proto_encode --input config_update_in_envelope.json --type common.Envelope --output config_update_in_envelope.pb</code></pre></li></ul></li><li>提交更新到通道<ul><li>这⾥假设orderer只有⼀家组织，如果有多家则需要每⼀家先对 config_update_in_envelope.pb 进⾏ signconfigtx 操作 <pre><code>peer channel update -f config_update_in_envelope.pb -c $CH_NAME -o $ORDERER_CONTAINER --tls true --cafile $TLS_ROOT_CA</code></pre><h3 id="具体操作-2"><a href="#具体操作-2" class="headerlink" title="具体操作"></a>具体操作</h3></li></ul></li></ul><p>进入 cli 容器</p><pre><code>docker exec -it cli bash </code></pre><p>进入 script 文件夹</p><pre><code>cd scripts</code></pre><p>将脚本 capabilities.json 复制到 此文件夹中即 fabric-sanples/firstnetwork/scripts 文件夹</p><p>然后给该脚本添加可执行权限并执行</p><pre><code>chmod +x updating_capabilities_sys.sh./updating_capabilities_sys.sh</code></pre><h2 id="2-2-升级已有应⽤链的系统配置"><a href="#2-2-升级已有应⽤链的系统配置" class="headerlink" title="2.2 升级已有应⽤链的系统配置"></a>2.2 升级已有应⽤链的系统配置</h2><p>参考脚本 updating_capabilities_mychannel.sh</p><ul><li><p>对环境变量进⾏配置，这⾥以 fabric-samples/first-network中的mychannel为例，mychannel 中包含了 Org1 和 Org2 两个组织</p><pre><code>CH_NAME=mychannelCORE_PEER_LOCALMSPID=Org1MSP TLS_ROOT_CA=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pemCORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp ORDERER_CONTAINER=orderer.example.com:7050 </code></pre></li><li><p>获取mychannel的原有配置</p><ul><li>获取原有配置<pre><code>peer channel fetch config config_block.pb -o $ORDERER_CONTAINER -c $CH_NAME --tls --cafile $TLS_ROOT_CA</code></pre></li><li>将配置转化为json格式<pre><code>configtxlator proto_decode --input config_block.pb --type common.Block --output config_block.json</code></pre></li><li>从json中只提取出来配置的部分 jq<pre><code>.data.data[0].payload.data.config config_block.json &gt; config.json</code></pre></li></ul></li><li><p>修改兼容性配置注意应⽤通道⽐系统通道多了⼀个Application的兼容性需要修改</p><pre><code>  jq -s &#39;.[0] * {&quot;channel_group&quot;:{&quot;groups&quot;:{&quot;Orderer&quot;: {&quot;values&quot;: {&quot;Capabilities&quot;: .[1].orderer}}}}}&#39; config.json ./capabilities.json &gt; modified_config1.json  jq -s &#39;.[0] * {&quot;channel_group&quot;:{&quot;values&quot;: {&quot;Capabilities&quot;: .[1].channel}}}&#39; modified_config1.json ./capabilities.json &gt; modified_config2.json  jq -s &#39;.[0] * {&quot;channel_group&quot;:{&quot;groups&quot;:{&quot;Application&quot;: {&quot;values&quot;: {&quot;Capabilities&quot;: .[1].application}}}}}&#39; modified_config2.json ./capabilities.json &gt; modified_config.json</code></pre></li><li><p>计算配置的deltaSet，⽣成pb⽂件</p><ul><li>计算deltaSet<pre><code>configtxlator proto_encode --input config.json --type common.Config --output config.pbconfigtxlator proto_encode --input modified_config.json --type common.Config --output modified_config.pbconfigtxlator compute_update --channel_id $CH_NAME --original config.pb --updated modified_config.pb --output config_update.pb</code></pre></li></ul></li><li><p>⽣成通道更新的pb⽂件</p><pre><code>  configtxlator proto_decode --input config_update.pb --type common.ConfigUpdate --output config_update.json   echo &#39;{&quot;payload&quot;:{&quot;header&quot;:{&quot;channel_header&quot;:{&quot;channel_id&quot;:&quot;&#39;$CH_NAME&#39;&quot;, &quot;type&quot;:2}},&quot;data&quot;:{&quot;config_update&quot;:&#39;$(cat config_update.json)&#39;}}}&#39; | jq . &gt; config_update_in_envelope.json   configtxlator proto_encode --input config_update_in_envelope.json --type common.Envelope --output config_update_in_envelope.pb</code></pre></li><li><p>提交更新到通道<br>  因为mychannel中有Org1和Org2两个组织（实际上还有Orderer的配置），对通道配置进⾏修改需要通道多数<br>  组织的签名，以及对Orderer配置修改需要Orderer组织的签名。 所以这⾥假设，先让Org1和Org2进⾏签名，再由Orderer进更新的提交。</p><ul><li>Org1签名<pre><code>peer channel signconfigtx -f config_update_in_envelope.pb</code></pre></li><li>切换为Org2<pre><code>CORE_PEER_LOCALMSPID=Org2MSPCORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp</code></pre></li><li>Org2签名<pre><code>peer channel signconfigtx -f config_update_in_envelope.pb</code></pre></li><li>切换为Orderer的组织<pre><code>CORE_PEER_LOCALMSPID=OrdererMSPCORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/users/Admin@example.com/msp</code></pre></li><li>Orderer组织提交变更<pre><code>peer channel update -f config_update_in_envelope.pb -c $CH_NAME -o $ORDERER_CONTAINER --tls true --cafile $TLS_ROOT_CA </code></pre></li></ul></li></ul><h3 id="具体操作-3"><a href="#具体操作-3" class="headerlink" title="具体操作"></a>具体操作</h3><p>进入 cli 容器</p><pre><code>docker exec -it cli bash </code></pre><p>进入 script 文件夹</p><pre><code>cd scripts</code></pre><p>将脚本 updating_capabilities_sys.sh 复制到 此文件夹中，即 fabric-sanples/firstnetwork/scripts 文件夹</p><p>然后给该脚本添加可执行权限并执行</p><pre><code>chmod +x updating_capabilities_sys.sh./updating_capabilities_sys.sh</code></pre><h1 id="3-激活chaincode的新的⽣命周期管理"><a href="#3-激活chaincode的新的⽣命周期管理" class="headerlink" title="3. 激活chaincode的新的⽣命周期管理"></a>3. 激活chaincode的新的⽣命周期管理</h1><p>只更改兼容性，通道若要使⽤chaincode的新的⽣命周期管理⽅案会出现错误，这是因为原有1.4的通道配置中，缺少通道<br>Endorsement和LifecycleEndorsement的配置。 为了⽅便使⽤ jq 命令来添加这两部分内容，⾸先准备包含以下内容的 enable_lifecycle.json⽂件，注意这⾥假设了通道内有两家组织，分别为Org1和Org2，他们的MSPID分别为Org1MSP,Org2MSP。 请根据需要进⾏修改。</p><pre><code>{     &quot;Org1MSPPolicies&quot;: {         &quot;Endorsement&quot;: {             &quot;mod_policy&quot;: &quot;Admins&quot;,             &quot;policy&quot;: {                 &quot;type&quot;: 1,                 &quot;value&quot;: {                 &quot;identities&quot;: [                     {                         &quot;principal&quot;: {                             &quot;msp_identifier&quot;: &quot;Org1MSP&quot;,                             &quot;role&quot;: &quot;PEER&quot;                         },                        &quot;principal_classification&quot;: &quot;ROLE&quot;                     }                 ],                &quot;rule&quot;: {                     &quot;n_out_of&quot;: {                         &quot;n&quot;: 1,                         &quot;rules&quot;: [                             {                              &quot;signed_by&quot;: 0                             }                        ]                     }                 },                &quot;version&quot;: 0             }         },        &quot;version&quot;: &quot;0&quot;         }     },     &quot;Org2MSPPolicies&quot;: {         &quot;Endorsement&quot;: {             &quot;mod_policy&quot;: &quot;Admins&quot;,             &quot;policy&quot;: {                 &quot;type&quot;: 1,                 &quot;value&quot;: {                 &quot;identities&quot;: [                 {                     &quot;principal&quot;: {                         &quot;msp_identifier&quot;: &quot;Org2MSP&quot;,                         &quot;role&quot;: &quot;PEER&quot;                 },                &quot;principal_classification&quot;: &quot;ROLE&quot;                }             ],            &quot;rule&quot;: {                 &quot;n_out_of&quot;: {                     &quot;n&quot;: 1,                     &quot;rules&quot;: [                     {                         &quot;signed_by&quot;: 0                     }                    ]                 }             },            &quot;version&quot;: 0             }         },        &quot;version&quot;: &quot;0&quot;      }     },    &quot;appPolicies&quot;: {         &quot;Endorsement&quot;: {             &quot;mod_policy&quot;: &quot;Admins&quot;,             &quot;policy&quot;: {                 &quot;type&quot;: 3,                 &quot;value&quot;: {                     &quot;rule&quot;: &quot;MAJORITY&quot;,                     &quot;sub_policy&quot;: &quot;Endorsement&quot;                 }             },            &quot;version&quot;: &quot;0&quot;         },        &quot;LifecycleEndorsement&quot;: {             &quot;mod_policy&quot;: &quot;Admins&quot;,             &quot;policy&quot;: {                 &quot;type&quot;: 3,                 &quot;value&quot;: {                     &quot;rule&quot;: &quot;MAJORITY&quot;,                     &quot;sub_policy&quot;: &quot;Endorsement&quot;                 }             },            &quot;version&quot;: &quot;0&quot;         }     } } </code></pre><h2 id="3-1-更改系统链配置"><a href="#3-1-更改系统链配置" class="headerlink" title="3.1 更改系统链配置"></a>3.1 更改系统链配置</h2><p>参考脚本enable_cc_lifecycle_sys.sh</p><ul><li><p>对环境变量进⾏配置</p><pre><code>CH_NAME=byfn-sys-channelCORE_PEER_LOCALMSPID=OrdererMSPTLS_ROOT_CA=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pemCORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/users/Admin@example.com/mspORDERER_CONTAINER=orderer.example.com:7050ORGNAME=Org1MSPCONSORTIUM_NAME=SampleConsortium</code></pre></li><li><p>获取原有的配置</p><pre><code>peer channel fetch config config_block.pb -o $ORDERER_CONTAINER -c $CH_NAME --tls --cafile $TLS_ROOT_CAconfigtxlator proto_decode --input config_block.pb --type common.Block --output config_block.jsonjq .data.data[0].payload.data.config config_block.json &gt; config.json</code></pre></li><li><p>修改相应配置</p><ul><li>修改Org1的配置，增加Org1的Endorsement的配置 <pre><code>jq -s &quot;.[0] * {\&quot;channel_group\&quot;:{\&quot;groups\&quot;:{\&quot;Consortiums\&quot;:{\&quot;groups\&quot;: {\&quot;$CONSORTIUM_NAME\&quot;: {\&quot;groups\&quot;: {\&quot;$ORGNAME\&quot;: {\&quot;policies\&quot;: .[1].${ORGNAME}Policies}}}}}}}}&quot; config.json ./enable_lifecycle.json &gt; modified_config1.json</code></pre></li><li>修改Org2的配置，增加Org2的Endorsement的配置<pre><code>ORGNAME=Org2MSPjq -s &quot;.[0] * jq -s &quot;.[0] * {\&quot;channel_group\&quot;:{\&quot;groups\&quot;:{\&quot;Consortiums\&quot;:{\&quot;groups\&quot;: {\&quot;$CONSORTIUM_NAME\&quot;: {\&quot;groups\&quot;: {\&quot;$ORGNAME\&quot;: {\&quot;policies\&quot;: .[1].${ORGNAME}Policies}}}}}}}}&quot; modified_config1.json ./enable_lifecycle.json &gt; modified_config.json</code></pre></li></ul></li><li><p>计算配置的deltaSet，⽣成pb⽂件</p><ul><li>计算deltaSet<pre><code>configtxlator proto_encode --input config.json --type common.Config --output config.pbconfigtxlator proto_encode --input modified_config.json --type common.Config --output modified_config.pbconfigtxlator compute_update --channel_id $CH_NAME --original config.pb --updated modified_config.pb --output config_update.pb</code></pre></li><li>⽣成通道更新的pb⽂件<pre><code>configtxlator proto_decode --input config_update.pb --type common.ConfigUpdate --output config_update.jsonecho &#39;{&quot;payload&quot;:{&quot;header&quot;:{&quot;channel_header&quot;:{&quot;channel_id&quot;:&quot;&#39;$CH_NAME&#39;&quot;, &quot;type&quot;:2}},&quot;data&quot;:{&quot;config_update&quot;:&#39;$(cat config_update.json)&#39;}}}&#39; | jq . &gt; config_update_in_envelope.jsonconfigtxlator proto_encode --input config_update_in_envelope.json --type common.Envelope --output config_update_in_envelope.pb</code></pre></li></ul></li><li><p>提交更新到通道<br>  因为Consortium中有Org1和Org2两个组织，对每个组织的内容修改都需要该组织的Admin的签名，然后对系 统通道配置进⾏修改需要Orderer组织的Admin签名。 </p><ul><li>Orderer签名<pre><code>peer channel signconfigtx -f config_update_in_envelope.pb </code></pre></li><li>切换为Org1，org1 签名<pre><code>CORE_PEER_LOCALMSPID=Org1MSPCORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msppeer channel signconfigtx -f config_update_in_envelope.pb</code></pre></li><li>切换为Org2 ，org2 签名<pre><code>CORE_PEER_LOCALMSPID=Org2MSPCORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msppeer channel signconfigtx -f config_update_in_envelope.pb</code></pre></li><li>切换回Orderer<pre><code>CORE_PEER_LOCALMSPID=OrdererMSPCORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/users/Admin@example.com/msp</code></pre></li><li>提交更新<pre><code>peer channel update -f config_update_in_envelope.pb -c $CH_NAME -o $ORDERER_CONTAINER --tls true --cafile $TLS_ROOT_CA</code></pre><h2 id="3-2-更改已有的应⽤通道配置"><a href="#3-2-更改已有的应⽤通道配置" class="headerlink" title="3.2 更改已有的应⽤通道配置"></a>3.2 更改已有的应⽤通道配置</h2></li></ul></li></ul><p>以fabric-samples/first-network中的mychannel为例。 参考脚本enable_cc_lifecycle_mychannel.sh</p><ul><li>对环境变量进⾏配置<pre><code>CH_NAME=mychannelCORE_PEER_LOCALMSPID=Org1MSPTLS_ROOT_CA=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pemCORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/mspORDERER_CONTAINER=orderer.example.com:7050ORGNAME=Org1MSPCONSORTIUM_NAME=SampleConsortium</code></pre></li><li>获取原有的配置<pre><code>peer channel fetch config config_block.pb -o $ORDERER_CONTAINER -c $CH_NAME --tls --cafile $TLS_ROOT_CAconfigtxlator proto_decode --input config_block.pb --type common.Block --output config_block.jsonjq .data.data[0].payload.data.config config_block.json &gt; config.json </code></pre></li><li>修改相应配置注意需要⽐系统通道多修改Application的Endorsement和LifeCycleEndorsement<ul><li>修改Org1的配置，增加Org1的Endorsement的配置<pre><code>jq -s &quot;.[0] * {\&quot;channel_group\&quot;:{\&quot;groups\&quot;:{\&quot;Application\&quot;:{\&quot;groups\&quot;: {\&quot;$ORGNAME\&quot;: {\&quot;policies\&quot;: .[1].${ORGNAME}Policies}}}}}}&quot; config.json ./enable_lifecycle.json &gt; modified_config1.json</code></pre></li><li>切换为Org2<pre><code>ORGNAME=Org2MSP</code></pre></li><li>修改Org2的配置，增加Org2的Endorsement的配置<pre><code>jq -s &quot;.[0] * {\&quot;channel_group\&quot;:{\&quot;groups\&quot;:{\&quot;Application\&quot;:{\&quot;groups\&quot;: {\&quot;$ORGNAME\&quot;: {\&quot;policies\&quot;: .[1].${ORGNAME}Policies}}}}}}&quot; modified_config1.json ./enable_lifecycle.json &gt; modified_config2.json</code></pre></li><li>修改通道配置，增加Endorsement和LifeCycleEndorsement配置<pre><code>jq -s &#39;.[0] * {&quot;channel_group&quot;:{&quot;groups&quot;:{&quot;Application&quot;: {&quot;policies&quot;: .[1].appPolicies}}}}&#39; modified_config2.json ./enable_lifecycle.json &gt; modified_config.json</code></pre></li></ul></li><li>计算配置的deltaSet，⽣成pb⽂件<ul><li>计算deltaSet<pre><code>configtxlator proto_encode --input config.json --type common.Config --output config.pbconfigtxlator proto_encode --input modified_config.json --type common.Config --output modified_config.pbconfigtxlator compute_update --channel_id $CH_NAME --original config.pb --updated modified_config.pb --output config_update.pb</code></pre></li><li>⽣成通道更新的pb⽂件<pre><code>configtxlator proto_decode --input config_update.pb --type common.ConfigUpdate --output config_update.jsonecho &#39;{&quot;payload&quot;:{&quot;header&quot;:{&quot;channel_header&quot;:{&quot;channel_id&quot;:&quot;&#39;$CH_NAME&#39;&quot;, &quot;type&quot;:2}},&quot;data&quot;:{&quot;config_update&quot;:&#39;$(cat config_update.json)&#39;}}}&#39; | jq . &gt; config_update_in_envelope.jsonconfigtxlator proto_encode --input config_update_in_envelope.json --type common.Envelope --output config_update_in_envelope.pb</code></pre></li></ul></li><li>提交更新到通道 因为Consortium中有Org1和Org2两个组织，对每个组织的内容修改都需要该组织的Admin的签名。<ul><li>Org1签名<pre><code>peer channel signconfigtx -f config_update_in_envelope.pb</code></pre></li><li>切换为Org2 <pre><code>CORE_PEER_LOCALMSPID=Org2MSPCORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp</code></pre></li><li>Org2来提交通道变更<pre><code>peer channel update -f config_update_in_envelope.pb -c $CH_NAME -o $ORDERER_CONTAINER --tls true --cafile $TLS_ROOT_CA</code></pre></li></ul></li></ul><h1 id="4-⼀些验证过的特殊场景"><a href="#4-⼀些验证过的特殊场景" class="headerlink" title="4. ⼀些验证过的特殊场景"></a>4. ⼀些验证过的特殊场景</h1><h3 id="4-1-是否可以升级镜像但不升级兼容性"><a href="#4-1-是否可以升级镜像但不升级兼容性" class="headerlink" title="4.1 是否可以升级镜像但不升级兼容性"></a>4.1 是否可以升级镜像但不升级兼容性</h3><p>可以的，只升级镜像不升级兼容性的话，还是按照1.4的功能来运⾏</p><h3 id="4-2-是否可以只升级某些通道的兼容性"><a href="#4-2-是否可以只升级某些通道的兼容性" class="headerlink" title="4.2 是否可以只升级某些通道的兼容性"></a>4.2 是否可以只升级某些通道的兼容性</h3><p>可以的，不过建议先升级系统通道，这样之后新⽣成的通道就可以是最新的兼容性配置了。</p><h3 id="4-3-通道中原有的链码是否还可以正常使⽤"><a href="#4-3-通道中原有的链码是否还可以正常使⽤" class="headerlink" title="4.3 通道中原有的链码是否还可以正常使⽤"></a>4.3 通道中原有的链码是否还可以正常使⽤</h3><p>升级镜像后，原有的链码可以正常使⽤，但是需要注意链码镜像的问题，如果保留了原链码的镜像则⽆需关⼼该问题，没有保留的 话，需要将ccenv配置为1.4的镜像版本。通道兼容性的升级也不会影响已有链码的使⽤。</p><h3 id="4-4-升级之后原有链码也有升级需求应该怎么操作"><a href="#4-4-升级之后原有链码也有升级需求应该怎么操作" class="headerlink" title="4.4 升级之后原有链码也有升级需求应该怎么操作"></a>4.4 升级之后原有链码也有升级需求应该怎么操作</h3><p>升级了镜像以及兼容性后，如果原有链码也需要升级，则需要⾛2.0的lifecycle的升级流程，即需要package-install- approveformyorg-commit那⼀套流程。</p><blockquote><p>Fabric的2.1和2.2版本是稳定版本，具有错误修复和其他形式的代码强化功能。升级的时候不需要特别的考虑，也不需要特定的镜像版本或通道配置更新。</p></blockquote><p>#下面是升级到 2.2 新增的一些内容</p><h2 id="从2-0-升级到-2-1"><a href="#从2-0-升级到-2-1" class="headerlink" title="从2.0 升级到 2.1"></a>从2.0 升级到 2.1</h2><p>之前 1.4 升级到 2.0 时，升级peer数据库需要先删除 peer 的数据库，也就是执行 peer node upgrade-dbs 命令</p><pre><code>docker run --rm -v /opt/backup/$PEER_CONTAINER/:/var/hyperledger/production/ \            -v /opt/msp/:/etc/hyperledger/fabric/msp/ \            --env-file ./env&lt;name of node&gt;.list \            --name $PEER_CONTAINER \            hyperledger/fabric-peer:2.0 peer node upgrade-dbs</code></pre><p>然后执行 peer node start 命令重建 peer 数据库</p><pre><code>docker run -d -v /opt/backup/$PEER_CONTAINER/:/var/hyperledger/production/ \            -v /opt/msp/:/etc/hyperledger/fabric/msp/ \            --env-file ./env&lt;name of node&gt;.list \            --name $PEER_CONTAINER \            hyperledger/fabric-peer:2.0 peer node start</code></pre><p>如果在升级过程中未删除 peer 数据库，则启动 peer 时将返回一条错误信息，提示需要先删除数据库。</p><p>如果升级到 2.1 的话，在上面的命令中将 2.0 换成 2.1 就行</p><h2 id="从-2-1-升级到-2-2"><a href="#从-2-1-升级到-2-2" class="headerlink" title="从 2.1 升级到 2.2"></a>从 2.1 升级到 2.2</h2><p>如果升级到 2.2 的话，删除数据库的命令都省了，如果是使用CouchDB作为状态数据库，则从v2.2 开始， peer 支持自动删除该数据库。为了利用这种支持，在运行 upgrade-dbs 命令之前，需要将 peer 的状态数据库配置为 CouchDB，并启动 CouchDB。在v2.0和v2.1中，peer 不会自动删除CouchDB状态数据库。需要手动好删除。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/upgrade_to_newest_version.html" target="_blank" rel="noopener">Considerations for getting to v2.x</a></p>]]></content>
      
      
      <categories>
          
          <category> fabric </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fabric </tag>
            
            <tag> 2.2 </tag>
            
            <tag> upgrade </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fabric 1.4源码分析2：Orderer 核心数据结构</title>
      <link href="/2020/08/02/orderer-data-structure/"/>
      <url>/2020/08/02/orderer-data-structure/</url>
      
        <content type="html"><![CDATA[<blockquote><p>回顾上一节中我们讲述了一笔交易在 orderer 中的处理流程，进入引出了 orderer 源码分析的知识图谱。这次我们就从知识图谱的第一块内容说起，也就是 orderer 核心数据结构。</p></blockquote><p><strong>友情提示：在Fabric中，通道和链在概念上都是一条区块链，所以本文中也可能会混用链和通道的说法，请读者不要过于纠结于这两个概念。</strong></p><h1 id="Registrar"><a href="#Registrar" class="headerlink" title="Registrar"></a>Registrar</h1><p>Registrar 对象是一个多通道注册管理器，负责管理系统通道与所有应用通道，封装了所有通道的 ChainSupport 的 map、共识组件 map、ledgerFactory 对象等组件，维护所有通道上的通道配置、区块账本对象、共识组件等核心资源，创建通道上的共识组件链对象提供Orderer共识排序服务，负责对交易消息排序，切割打包构造新区块并提交账本，同时负责创建新的应用通道与更新通道配置。</p><p>一言蔽之，<br>Registrar 就相当于 Orderer节点上的 “资源管理器”，包含了所有通道 资源的访问和控制点，也就是说，我们如果需要对 orderer 节点的任何一个通道进行操作，都得先从这里入手。</p><blockquote><p>Registrar 对象定义在<br>fabric/orderer/common/multichannel/registrar.go 文件中，具体如下：</p></blockquote><pre><code>// Registrar serves as a point of access and control for the individual channel resources.type Registrar struct {    lock               sync.RWMutex    chains             map[string]*ChainSupport    config             localconfig.TopLevel    consenters         map[string]consensus.Consenter    ledgerFactory      blockledger.Factory    signer             crypto.LocalSigner    blockcutterMetrics *blockcutter.Metrics    systemChannelID    string    systemChannel      *ChainSupport    templator          msgprocessor.ChannelConfigTemplator    callbacks          []channelconfig.BundleActor}</code></pre><ul><li>lock 是一把锁，当需要对于通道资源进行读和写操作时，会对通道加锁，操作完再解锁。</li><li>chains 保存了所有的链，每一条链在 Orderer 中都以 一个 Key - Value 键值对表述，其中键就是 channelID，值就是一条链，这里用 ChainSupport表示，具体下文还会介绍。</li><li>config 保存了从 orderer.yaml 中读取的配置</li><li>consenters 保存了所有的共识插件，每个共识插件都是一个 Consenter，Fabric 1.4 中共识插件有 Solo、Kafka、EtcdRaft 三种。</li><li>ledgerFactory 用来读取和创建链的账本。</li><li>signer用来对Orderer中的数据进行签名，以及创建 <a href="https://lessisbetter.site/2019/11/10/how-fabric-verify-signatures/#%E8%A7%A3%E5%AF%86SignatureHeader" target="_blank" rel="noopener">SignatureHeader</a>。</li><li>blockcutterMetrics 是用于对切块进行一些指标的监测</li><li>systemChannelID 和 systemChannel分别是系统通道ID、系通道实例。</li><li>systemChannel </li><li>templator 用于生成一个通道配置模版</li><li>callbacks 用于对通道配置执行一些回调的操作</li></ul><h1 id="ChainSupport"><a href="#ChainSupport" class="headerlink" title="ChainSupport"></a>ChainSupport</h1><p>ChainSupport 封装了关联通道上的账本资源对象、消息处理器、区 块写组件、共识组件链对象等核心组件与模块，用于过滤验证消息、切割打包消息出块、 提交区块写入账本、创建通道与更新通道配置等流程。</p><p>一言蔽之，ChainSupport 汇集了一条通道所需要的所有资源，一个 ChainSupport 就代表了一条链。</p><blockquote><p>ChainSupport 对象定义在<br>fabric/orderer/common/multichannel/chainsupport.go 文件中，具体如下：</p></blockquote><pre><code>// ChainSupport holds the resources for a particular channel.type ChainSupport struct {    *ledgerResources    msgprocessor.Processor    *BlockWriter    consensus.Chain    cutter blockcutter.Receiver    crypto.LocalSigner}</code></pre><p>ChainSupport 是一堆接口的集合，这些接口构成一条链所有的操作，接口可以分为4类：</p><ul><li>账本：ledgerResources、BlockWriter分别是账本读写和把区块写入到账本。</li><li>消息：msgprocessor.Processor、cutter分别是处理交易和把交易切块。</li><li>共识：consensus.Chain是Orderer的共识实例，比如每条链都有自己的Raft共识实例，它们互不干扰。</li><li>签名：crypto.LocalSigner，同Registrar中的介绍。</li></ul><h1 id="Chain"><a href="#Chain" class="headerlink" title="Chain"></a>Chain</h1><p>Chain 接口的实现是一个共识插件的实例，它利用不同的共识算法（Solo、Kafka 和 Etcdraft）对交易排序并 添加到本地的缓存交易消息列表中，按出块规则切割成批量交易集合，再打包出块提交到账本，同时负责创建新通道与更新通道配置。</p><p>一言蔽之，Chain 接口包含了一个共识插件所要实现的基本方法，它主要负责对交易/消息进行排序并调用 HandleChain 方法进行切块和写入账本，体现了共识算法的可插拔性。</p><blockquote><p>Chain 接口定义在<br>fabric/orderer/consensus/consensus.go 文件中，具体如下：</p></blockquote><pre><code>// Chain defines a way to inject messages for ordering.// Note, that in order to allow flexibility in the implementation, it is the responsibility of the implementer// to take the ordered messages, send them through the blockcutter.Receiver supplied via HandleChain to cut blocks,// and ultimately write the ledger also supplied via HandleChain.  This design allows for two primary flows// 1. Messages are ordered into a stream, the stream is cut into blocks, the blocks are committed (solo, kafka)// 2. Messages are cut into blocks, the blocks are ordered, then the blocks are committed (sbft)Chain定义了一种注入消息的方式来进行排序。// 注意，为了在实现中实现灵活性，实现者负责获取有序消息，并通过 blockcutter 发送它们。接收器通过 HandleChain 来切割块，并写入账本也通过 HandleChain方法。// 这种设计允许两个主要流程：// 1. 消息被排序到一个流中，流被切成块，块被提交(solo, kafka)// 2. 消息被切成块，对块进行排序，然后提交块(sbft)type Chain interface {    // 普通消息/交易排序    // Order accepts a message which has been processed at a given configSeq.    // If the configSeq advances, it is the responsibility of the consenter    // to revalidate and potentially discard the message    // The consenter may return an error, indicating the message was not accepted    Order(env *cb.Envelope, configSeq uint64) error    // 配置消息/交易排序    // Configure accepts a message which reconfigures the channel and will    // trigger an update to the configSeq if committed.  The configuration must have    // been triggered by a ConfigUpdate message. If the config sequence advances,    // it is the responsibility of the consenter to recompute the resulting config,    // discarding the message if the reconfiguration is no longer valid.    // The consenter may return an error, indicating the message was not accepted    Configure(config *cb.Envelope, configSeq uint64) error    // 等待排序集群可用    // WaitReady blocks waiting for consenter to be ready for accepting new messages.    // This is useful when consenter needs to temporarily block ingress messages so    // that in-flight messages can be consumed. It could return error if consenter is    // in erroneous states. If this blocking behavior is not desired, consenter could    // simply return nil.    WaitReady() error    // 当排序集群发送错误时，会关闭返回的通道    // Errored returns a channel which will close when an error has occurred.    // This is especially useful for the Deliver client, who must terminate waiting    // clients when the consenter is not up to date.    Errored() &lt;-chan struct{}    // 启动当前链    // Start should allocate whatever resources are needed for staying up to date with the chain.    // Typically, this involves creating a thread which reads from the ordering source, passes those    // messages to a block cutter, and writes the resulting blocks to the ledger.    Start()    // 停止当前链，并释放资源    // Halt frees the resources which were allocated for this Chain.    Halt()}</code></pre><h1 id="Consenter"><a href="#Consenter" class="headerlink" title="Consenter"></a>Consenter</h1><p>Consenter 也是接口，它只有1个功能用来创建 Chain。每种共识插件，都有自己单独的consenter实现，分别用来创建solo实例、kafka实例或etcdraft实例。</p><pre><code>// Consenter defines the backing ordering mechanism.type Consenter interface {    // HandleChain should create and return a reference to a Chain for the given set of resources.    // It will only be invoked for a given chain once per process.  In general, errors will be treated    // as irrecoverable and cause system shutdown.  See the description of Chain for more details    // The second argument to HandleChain is a pointer to the metadata stored on the `ORDERER` slot of    // the last block committed to the ledger of this Chain. For a new chain, or one which is migrated,    // this metadata will be nil (or contain a zero-length Value), as there is no prior metadata to report.    HandleChain(support ConsenterSupport, metadata *cb.Metadata) (Chain, error)}</code></pre><h1 id="ConsenterSupport"><a href="#ConsenterSupport" class="headerlink" title="ConsenterSupport"></a>ConsenterSupport</h1><p>ConsenterSupport 为 consenter 实现提供所需的资源，其实就是共识用来访问外部数据的接口。</p><pre><code>// ConsenterSupport provides the resources available to a Consenter implementation.type ConsenterSupport interface {    crypto.LocalSigner    msgprocessor.Processor    // 验证区块签名是否合法    // VerifyBlockSignature verifies a signature of a block with a given optional    // configuration (can be nil).    VerifyBlockSignature([]*cb.SignedData, *cb.ConfigEnvelope) error    // 提供把消息切成块的接口    // BlockCutter returns the block cutting helper for this channel.    BlockCutter() blockcutter.Receiver    // 当前链的orderer配置    // SharedConfig provides the shared config from the channel&#39;s current config block.    SharedConfig() channelconfig.Orderer    // 当前链的通道配置    // ChannelConfig provides the channel config from the channel&#39;s current config block.    ChannelConfig() channelconfig.Channel    // 生成区块    // CreateNextBlock takes a list of messages and creates the next block based on the block with highest block number committed to the ledger    // Note that either WriteBlock or WriteConfigBlock must be called before invoking this method a second time.    CreateNextBlock(messages []*cb.Envelope) *cb.Block    // 读区块    // Block returns a block with the given number,    // or nil if such a block doesn&#39;t exist.    Block(number uint64) *cb.Block    // 写区块    // WriteBlock commits a block to the ledger.    WriteBlock(block *cb.Block, encodedMetadataValue []byte)    // 写配置区块并更新配置    // WriteConfigBlock commits a block to the ledger, and applies the config update inside.    WriteConfigBlock(block *cb.Block, encodedMetadataValue []byte)    // 返回当前配置序列号    // Sequence returns the current config squence.    Sequence() uint64    // 返回 channel ID    // ChainID returns the channel ID this support is associated with.    ChainID() string    // 返回区块高度    // Height returns the number of blocks in the chain this channel is associated with.    Height() uint64    //以原始数据的格式追加区块，不像WriteBlock那样会修改元数据    // Append appends a new block to the ledger in its raw form,    // unlike WriteBlock that also mutates its metadata.    Append(block *cb.Block) error}</code></pre><h1 id="一图看懂-Orderer-核心数据结构"><a href="#一图看懂-Orderer-核心数据结构" class="headerlink" title="一图看懂 Orderer 核心数据结构"></a>一图看懂 Orderer 核心数据结构</h1><blockquote><p>建议点击图片查看大图</p></blockquote><p><img src="http://note.youdao.com/yws/res/296/WEBRESOURCE4045838a95b90333c47c17cc7a9bc01b" alt="orderer 核心数据结构"></p>]]></content>
      
      
      <categories>
          
          <category> fabric </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fabric </tag>
            
            <tag> 源码解析 </tag>
            
            <tag> orderer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fabric 1.4源码分析1：Orderer功能概述</title>
      <link href="/2020/07/25/orderer-functions-overview/"/>
      <url>/2020/07/25/orderer-functions-overview/</url>
      
        <content type="html"><![CDATA[<blockquote><p>从今天开始，正式启动Fabric 1.4 源码分析系列专题，本文是源码分析系列的第一篇，决定先从 Orderer 入手。由于Fabric源码涉及的模块、知识点的深度和广度非同一般，为了避免从一开始就落入细节，因此决定先采用模块分解 + 架构梳理 + 知识点细化的三步走战略进行。希望通过这样自顶向下，逐步细化的方式从整体上把握fabric的实现原理，涉及到具体开发工作时又能快速上手。</p></blockquote><h1 id="代码目录"><a href="#代码目录" class="headerlink" title="代码目录"></a>代码目录</h1><p>源码分析的宗旨是一切始于源码，终于源码。所以我们首先来看看orderer这块的代码目录。orderer相关的代码主要在 fabric/orderer文件夹中：</p><pre><code>➜  fabric git:(readCode) ✗ tree -L 2 ordererorderer├── README.md├── common│   ├── blockcutter 缓存待打包的交易，切块│   ├── bootstrap 启动时替换通道创世块│   ├── broadcast orderer的Broadcast接口│   ├── cluster （Raft）集群服务│   ├── localconfig 解析orderer配置文件orderer.yaml│   ├── metadata 区块元数据填写│   ├── msgprocessor 交易检查│   ├── multichannel 多通道支持：Registrar、chainSupport、写区块│   └── server Orderer节点的服务端程序├── consensus 共识插件│   ├── consensus.go 共识插件需要实现的接口等定义│   ├── etcdraft raft共识插件│   ├── inactive 未激活时的raft│   ├── kafka kafka共识插件│   ├── mocks 测试用的共识插件│   └── solo solo共识插件├── main.go orderer程序入口├── mocks│   ├── common│   └── util└── sample_clients orderer的客户端程序样例    ├── broadcast_config    ├── broadcast_msg    └── deliver_stdout23 directories, 3 files</code></pre><p>相信大家这样过了一遍心里有个大致印象，但还是一脸懵逼，不过没关系，我们接着往下看：</p><h1 id="功能概述"><a href="#功能概述" class="headerlink" title="功能概述"></a>功能概述</h1><p>Orderer排序节点管理着系统通道与所有应用通道，负责通道创建、通道配置更新等操作，并处理客户端提交的交易消息请求，对交易进行排序并按规则打包成新区块，提交账本并维护通道账本数据，为全网节点提供Broadcast交易广播服务、Orderer共识排序服务、Deliver区块分发服务等。</p><p><img src="http://note.youdao.com/yws/res/63/WEBRESOURCE0d039e7a4924db2b6d979c334fd14e9d" alt="orderer功能概述"></p><blockquote><p>图片源自《Hyperledger Fabric技术内幕 架构设计与实现原理》</p></blockquote><h2 id="一笔交易在Orderer中经历的过程"><a href="#一笔交易在Orderer中经历的过程" class="headerlink" title="一笔交易在Orderer中经历的过程"></a>一笔交易在Orderer中经历的过程</h2><p>还记得在上一篇中我们介绍了一笔交易在fabric中所经历的过程，那么这一节我们依旧以交易为切入点，聚焦于交易在orderer这部分到底经历了什么。</p><p><img src="http://note.youdao.com/yws/res/84/WEBRESOURCEb122473b5b7acef549a64630e6570d63" alt="一笔交易在 orderer 中的处理流程"></p><p>如图所示，orderer节点首先通过<strong>Broadcast广播交易服务</strong>从客户端获取经过背书的交易消息，然后将交易进行排序并打包成区块，最后通过<strong>Deliver区块分发服务</strong>向peer节点分发打包好的区块。</p><p>其中将交易进行排序和打包成区块的步骤又可以进一步分解为:</p><ol><li>对交易进行多项检查（<strong>MsgProcessor</strong>）</li><li>通过solo、kafka、raft等共识算法对交易进行排序（<strong>consensus共识插件</strong>）</li><li>根据切块策略进行切块（<strong>BlockCutter</strong>）</li><li>保存区块文件（<strong>BlockWriter</strong>）</li></ol><p>通过以上对一笔交易在orderer中所经历的过程进行分析，我们会发现其实orderer这块的源码可以拆分成以下几个主要模块：</p><ol><li>广播交易服务：Brodcast </li><li>交易检查：Msgprocessor</li><li>交易排序：Solo、Kafka、Etcdraft</li><li>切块：Blockcutter</li><li>写区块：BlockWriter</li><li>区块分发服务：Deliver 区块分发服务</li></ol><p>除此之外，在分析源码之前我们还需要了解 Ordrer 的核心数据结构以及 Orderer节点的启动流程。</p><p>综上所述，orderer源码解析的知识图谱就呼之欲出了。</p><p><img src="http://note.youdao.com/yws/res/70/WEBRESOURCE94ead357ff1974f130ca9b572e879016" alt="Orderer 知识图谱"></p><p>这张图描绘了 orderer 这块源码我们需要掌握的主要知识点，现在肯定还有很多地方看不懂，不过没关系，有个大致印象就好，等我们把所有的知识点都理一遍再回过头来看这张图，相信会有一种“一览众山小”的感觉。</p><p>接下来，我们就将以这种图为线索，正式开始我们的orderer源码分析之旅。</p>]]></content>
      
      
      <categories>
          
          <category> fabric </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fabric </tag>
            
            <tag> 源码解析 </tag>
            
            <tag> orderer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fabric交易处理流程</title>
      <link href="/2020/07/25/tx-flow/"/>
      <url>/2020/07/25/tx-flow/</url>
      
        <content type="html"><![CDATA[<blockquote><p>fabric 作为目前世界上最为知名的联盟链开源项目，所涉及的模块和概念很多，本文以交易作为一个切入点，通过分析一笔交易从发送到最终上链所经历的各个环节，将fabric的核心模块串联起来，为接下来更为深入的各个模块的源码分析奠定基础。</p></blockquote><p><img src="http://note.youdao.com/yws/res/57/WEBRESOURCE9b612bf71f717be93422441ce1cd1afb" alt="交易流程"></p><blockquote><p>此图来自《Hyperledger Fabric技术内幕 架构设计与实现原理》</p></blockquote><h3 id="1-发送签名提案消息到Endorser背书节点请求处理"><a href="#1-发送签名提案消息到Endorser背书节点请求处理" class="headerlink" title="1. 发送签名提案消息到Endorser背书节点请求处理"></a>1. 发送签名提案消息到Endorser背书节点请求处理</h3><p>Client节点构造签名提案消息<font color="blue">(SignedProposal类型)</font>，通过调用Endorser背书服务客户端的<font color="blue">ProcessProposal()接口</font>，提交该消息到Endorser背书节点，请求模拟执行交易提案并签名背书。</p><h3 id="2-Endorser背书节点模拟执行交易提案并签名背书Endorser背书"><a href="#2-Endorser背书节点模拟执行交易提案并签名背书Endorser背书" class="headerlink" title="2. Endorser背书节点模拟执行交易提案并签名背书Endorser背书"></a>2. Endorser背书节点模拟执行交易提案并签名背书Endorser背书</h3><p>节点收到签名提案消息之后，进行如下处理。</p><ol><li>检查签名提案消息的格式合法性与签名有效性，包括通道头部、签名头部、签名 域、交易ID、消息扩展域的Chaincodeld属性与PayloadVisibility可见性模式等；</li><li>检查提案消息的创建者是否满足指定通道上的通道访问权限，即/Channel/ Application/Writers 写权限；</li><li>检查并启动链码容器以模拟执行交易提案，并将模拟执行结果暂时保存在交易模拟器中，等待排序共识与交易验证，而不是直接更新到账本中。其中，<font color="blue">交易模拟执行结果釆用状态数据读写集（读数据的键和版本、写数据的键值）记录交易造成的状态变更结果；</font></li><li><font color="blue">调用ESCC系统链码对该提案消息的模拟结果读写集等进行签名背书</font>。</li></ol><h3 id="3-Endorser背书节点向客户端返回提案响应消息，并分发隐私数据明文"><a href="#3-Endorser背书节点向客户端返回提案响应消息，并分发隐私数据明文" class="headerlink" title="3. Endorser背书节点向客户端返回提案响应消息，并分发隐私数据明文"></a>3. Endorser背书节点向客户端返回提案响应消息，并分发隐私数据明文</h3><p>Endorser背书节点基于背书信息、模拟执行结果等构造提案响应消息（ProposalResponse 类型），并回复给请求客户端。</p><p>目前，模拟执行结果读写集包含公有数据（包括公共数据与隐私数据哈希值）与私有数据（或隐私数据）。</p><p>其中，公有数据交由0rderer节点进行排序出块，再提交到账本区块 数据文件，并广播到该通道上的所有节点。</p><p>如果模拟执行结果中还存在有效的隐私数据明文，则<font color="blue">Endorser背书节点通过Gossip消息协议将隐私数据发送给通道内授权的其他节点（由隐私数据集合配置的签名策略决定），交由transient隐私数据存储对象暂时保存到本地的transient隐私数据库（LevelDB）,并在提交账本时存储到隐私数据库（LevelDB）,同时清理transient隐私数据库中的过期数据</font>。</p><h3 id="4-处理提案响应消息"><a href="#4-处理提案响应消息" class="headerlink" title="4. 处理提案响应消息"></a>4. 处理提案响应消息</h3><p>Client节点解析Endorser背书节点回复的提案响应消息，获取背书结果并检查提案响应消息状态的合法性，以判断是否收集到了<font color="blue">足够多的符合要求的背书签名信息</font>。</p><h3 id="5-发送交易数据给Orderer服务节点请求排序"><a href="#5-发送交易数据给Orderer服务节点请求排序" class="headerlink" title="5. 发送交易数据给Orderer服务节点请求排序"></a>5. 发送交易数据给Orderer服务节点请求排序</h3><p>当收集到足够多数量的符合要求的Endorser背书签名之后（由背书策略决定），<font color="blue">Client节点基于模拟执行结果、背书签名等构造合法的签名交易消息（Envelope类型），通过Broadcast（）服务接口将该消息提交给Orderer节点</font>，请求交易排序处理。其中，配置交易消 息不需要经过Endorser节点处理。</p><h3 id="6-Orderer服务节点对交易进行排序并构造新区块"><a href="#6-Orderer服务节点对交易进行排序并构造新区块" class="headerlink" title="6. Orderer服务节点对交易进行排序并构造新区块"></a>6. Orderer服务节点对交易进行排序并构造新区块</h3><p>Orderer排序节点<font color="blue">提供Solo类型（用于单节点测试）、Kafka类型（支持CFT容错）等共识组件</font>，对符合通道处理要求的合法交易消息（普通交易消息、配置交易消息等）进行排序并达成一致观点，并对一段时间内接收的一批交易消息按照打包交易的岀块规则（出块周期 时间、区块字节数限制、配置交易单独出块等）构造新区块，创建应用通道或更新通道配置同时提交账本。</p><h3 id="7-Leader主节点请求Orderer服务节点发送通道账本区块"><a href="#7-Leader主节点请求Orderer服务节点发送通道账本区块" class="headerlink" title="7. Leader主节点请求Orderer服务节点发送通道账本区块"></a>7. Leader主节点请求Orderer服务节点发送通道账本区块</h3><p><font color="blue">Leader主节点通过Deliver()服务接口代表组织从Orderer节点请求通道账本上所有的区块数据，并通过Gossip消息协议分发到组织内的其他Peer节点</font>。如果请求的区块数据不 存在，则Orderer节点默认阻塞等待，直到指定区块创建完成并提交账本，再将该区块发送 给Leader主节点。</p><h3 id="8-Committer记账节点验证交易并提交账本"><a href="#8-Committer记账节点验证交易并提交账本" class="headerlink" title="8. Committer记账节点验证交易并提交账本"></a>8. Committer记账节点验证交易并提交账本</h3><p>Committer记账节点对区块与隐私数据（明文）执行如下检查，并提交至本地账本。如果不存在隐私数据明文，则跳过隐私数据的相关检查与提交账本的步骤。</p><ol><li>检查交易消息格式的正确性、签名合法性、交易内容是否篡改、消息头部的合法性等。</li><li><font color="blue">调用VSCC系统链码</font>，验证收集的签名背书结果是否符合指定的背书策略。</li><li>对模拟结果中公有数据（即区块数据，含有公共数据与隐私数据哈希值）的<font color="blue">读写集执行MVCC检查</font>，针对单个键查询、键范围查询、隐私数据哈希值三种情况，检查读数据版本与交易时的账本是否一致，即是否存在读写冲突，并将存在冲突的交易标记为无效交易。</li><li>验证模拟结果中隐私数据的正确性，遍历区块中有效交易的隐私数据读写集哈希值，取岀对应交易的原始隐私数据读写集明文，重新计算其哈希值并对两者进行比较。如果两者完全相同，则说明该交易的隐私数据是真实有效的。</li><li>保存所有的区块数据（即公有数据）到<font color="blue">区块数据文件</font>中，保存所有的私有数据（即隐私数据）读写集到<font color="blue">隐私数据库（LevelDB）</font>中，建立区块索引信息到<font color="blue">区块索引数据库</font>，将最新的有效交易数据（包含公共数据读写集、隐私数据读写集、隐私数据读写集哈希值）更新到<font color="blue">状态数据库</font>，最后将区块数据中经过Endorser背书的有效交易数据同步到<font color="blue">历史数据库</font>。同时，清理<font color="blue">transient隐私数据库中</font>的过期数据。</li></ol><h3 id="9-Leader主节点分发数据与状态同步"><a href="#9-Leader主节点分发数据与状态同步" class="headerlink" title="9. Leader主节点分发数据与状态同步"></a>9. Leader主节点分发数据与状态同步</h3><p>Leader主节点基于<font color="blue">Gossip消息协议</font>将区块数据分发到组织内的其他节点上。同时，<font color="blue">节点之间通过反嫡算法等机制主动拉取缺失的数据</font>（区块数据与隐私数据）、节点身份信息等,以确保组织内所有节点上的账本数据等信息保持同步。</p><h3 id="10-Committer记账节点验证交易并提交账本（同步骤8）"><a href="#10-Committer记账节点验证交易并提交账本（同步骤8）" class="headerlink" title="10. Committer记账节点验证交易并提交账本（同步骤8）"></a>10. Committer记账节点验证交易并提交账本（同步骤8）</h3><p>至此，Hyperledger Fabric系统上的一次完整交易处理流程即告结束。</p><h2 id="预告"><a href="#预告" class="headerlink" title="预告"></a>预告</h2><blockquote><p>从下一篇开始，我们就要正式开启fabric源码分析的专题了，本篇文章其实是一个知识准备。这里多说一句，就是我为什么要开启这个fabric源码分析的专题，其实这件事一直在我心中酝酿，但是由于前一段时间较忙，而且内心总是有一些否定的声音让我陷入自我怀疑，到底要不要做，因为现在网上已经有很多关于fabric源码分析的资料，而且质量也很高，为什么不直接抄“学霸”的作业呢，一定要自己搞一遍，不累吗？其实我是这样想的，“一千个读者就有一千个哈姆雷特”。那么我可不可以这么理解，“一千个开发者就有一千个fabric”。别人关于源码解读的文章都是基于其本人的知识架构下的，而如果我们一定要去灌输到自己的大脑中，可能会有些消化不良。而且我们也不能一味的迷信“权威”，学霸的作业也可能有疏漏的地方，别人的分析都是经过二次加工的产物，带有强烈的主观主义色彩，我们还是应该忠于源码，探索“属于我自己的fabric”。好了，废话有点多，接下来就进入正题吧。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> fabric </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fabric </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>govendor使用</title>
      <link href="/2020/07/18/govendor/"/>
      <url>/2020/07/18/govendor/</url>
      
        <content type="html"><![CDATA[<blockquote><p>由于最近遇到个项目需要使用go vendor进行依赖管理，所以就简单学习了一下</p></blockquote><p>三步走</p><h4 id="第一步："><a href="#第一步：" class="headerlink" title="第一步："></a>第一步：</h4><p>进入项目</p><pre><code>cd [project name]</code></pre><p>执行 </p><pre><code>govendor init</code></pre><p>项目根目录下即会自动生成 vendor 目录和 vendor.json 文件</p><h4 id="第二步："><a href="#第二步：" class="headerlink" title="第二步："></a>第二步：</h4><p>将已被引用且在 $GOPATH 下的所有包复制到 vendor 目录</p><pre><code>govendor add +external</code></pre><h4 id="第三步："><a href="#第三步：" class="headerlink" title="第三步："></a>第三步：</h4><p>拉取所有依赖的包到 vendor 目录(包括 $GOPATH 存在或不存在的包)</p><pre><code>govendor fetch +out</code></pre><h4 id="其他常用命令"><a href="#其他常用命令" class="headerlink" title="其他常用命令"></a>其他常用命令</h4><p>从远程仓库添加或更新某个包(不会在 $GOPATH 也存一份)</p><pre><code>govendor fetch golang.org/x/net/context</code></pre><p>安装指定版本的包</p><pre><code>govendor fetch golang.org/x/net/context@a4bbce9fcae005b22ae5443f6af064d80a6f5a55</code></pre><p>包已在 vendor 目录，但想从 $GOPATH 更新</p><pre><code>govendor update +vendor</code></pre><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://lessisbetter.site/2018/11/17/An-introduction-to-Govendor/" target="_blank" rel="noopener">https://lessisbetter.site/2018/11/17/An-introduction-to-Govendor/</a></p><p><a href="https://shockerli.net/post/go-package-manage-tool-govendor/" target="_blank" rel="noopener">https://shockerli.net/post/go-package-manage-tool-govendor/</a></p>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>向 fabric 贡献代码</title>
      <link href="/2020/07/14/fabric-contribute/"/>
      <url>/2020/07/14/fabric-contribute/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文主要记录了向fabric开源社区贡献代码的过程</p></blockquote><h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><p>进入 fabric目录</p><p>cd fabric</p><h2 id="1-先获取对应分支"><a href="#1-先获取对应分支" class="headerlink" title="1. 先获取对应分支"></a>1. 先获取对应分支</h2><p>git fetch origin [目标分支]</p><h2 id="2-切到对应分支"><a href="#2-切到对应分支" class="headerlink" title="2. 切到对应分支"></a>2. 切到对应分支</h2><p>git checkout -b [目标分支]</p><h2 id="3-更新最新代码（此步骤可省略）"><a href="#3-更新最新代码（此步骤可省略）" class="headerlink" title="3. 更新最新代码（此步骤可省略）"></a>3. 更新最新代码（此步骤可省略）</h2><p>goland -&gt; vcs -&gt; git -&gt; Rebase my Github fork -&gt; 选择原代码仓库</p><p>参考：<a href="https://www.zhihu.com/question/28676261" target="_blank" rel="noopener">https://www.zhihu.com/question/28676261</a></p><p>或者：</p><pre><code>git remote add upstream https://github.com/hyperledger/fabricgit fetch upstreamgit checkout [目标分支]git rebase upstream/[目标分支]git push -f origin [目标分支]</code></pre><h2 id="4-新建一个用于开发的分支"><a href="#4-新建一个用于开发的分支" class="headerlink" title="4. 新建一个用于开发的分支"></a>4. 新建一个用于开发的分支</h2><p>名字格式为 FAB-XXXX （issue序号）</p><p>git checkout -b FAB-XXX</p><h2 id="5-正式干活"><a href="#5-正式干活" class="headerlink" title="5. 正式干活"></a>5. 正式干活</h2><p>愉快滴开发（此处省略一万字）</p><h2 id="6-提交-：-git-commit-a-s"><a href="#6-提交-：-git-commit-a-s" class="headerlink" title="6. 提交 ：$ git commit -a -s"></a>6. 提交 ：$ git commit -a -s</h2><p>-s 选项是用于在commit message中自动生成sign off签名的</p><h2 id="7-编辑commit信息"><a href="#7-编辑commit信息" class="headerlink" title="7. 编辑commit信息"></a>7. 编辑commit信息</h2><pre><code>[FAB-XXXX] &lt;标题,官方文档说本行不能超过72个字符，实测不能超过55个字符&gt;&lt;空行&gt;This fixes #FAB-XXXX&lt;内容：每行不超过80字符，其中应该包括- 你的提交做了什么？- 为何选用这种方式去进行改动- 为何这种改动能够成功，比如提交你成功的代码测试结果&gt;</code></pre><h2 id="8-推送代码"><a href="#8-推送代码" class="headerlink" title="8. 推送代码"></a>8. 推送代码</h2><p>vcs -&gt; git -&gt; push</p><h2 id="9-pull-request"><a href="#9-pull-request" class="headerlink" title="9. pull request"></a>9. pull request</h2><p>登录 github,找到刚刚push的分支，点击 compare and pull request</p><p>注意要推送的目标分支，一般默认是master，这里需要修改为要推送的分支</p><p>确认commit信息没问题后点击右下角 create pull request</p><h2 id="9-等待合并"><a href="#9-等待合并" class="headerlink" title="9.等待合并"></a>9.等待合并</h2><p>会跑一堆测试，所有测试都过了以后经过两个以上的人approve则会被merge</p><h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><h3 id="git-push-ERROR-You-must-verify-your-email-address"><a href="#git-push-ERROR-You-must-verify-your-email-address" class="headerlink" title="git push ERROR: You must verify your email address"></a>git push ERROR: You must verify your email address</h3><p>解决方法：<a href="https://www.jianshu.com/p/30ee5daf1327" target="_blank" rel="noopener">https://www.jianshu.com/p/30ee5daf1327</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://davidkhala.github.io/2017/08/30/fabric-contribute/" target="_blank" rel="noopener">https://davidkhala.github.io/2017/08/30/fabric-contribute/</a></p>]]></content>
      
      
      <categories>
          
          <category> fabric </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fabric </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitLab CICD 自动化部署</title>
      <link href="/2020/07/14/cicd/"/>
      <url>/2020/07/14/cicd/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文简单记录了自学使用GitLab CI进行自动化部署的过程</p></blockquote><h1 id="什么是-CI-CD-流水线？"><a href="#什么是-CI-CD-流水线？" class="headerlink" title="什么是 CI/CD 流水线？"></a>什么是 CI/CD 流水线？</h1><p>CI 代表持续集成（Continuous Integration），CD 代表持续交付（Continuous Delivery）和持续部署（Continuous Deployment）。也可以将它们看作是类似于软件开发生命周期的过程。</p><h4 id="持续集成"><a href="#持续集成" class="headerlink" title="持续集成"></a>持续集成</h4><p>持续集成指在和向远程仓库 push 代码后，在这次提交合并入主分支前进行一系列测试，构建等流程。假设现在有个应用的代码存储在 gitlab 上，每天开发者都 push 很多次提交，针对每次 push，你可以创建一系列脚本进行自动测试，降低往应用里引入错误的概率。这就是持续集成，它可应用在包括开发分支在内的多个分支上。</p><h4 id="持续部署"><a href="#持续部署" class="headerlink" title="持续部署"></a>持续部署</h4><p>持续部署在持续集成的基础上更进一步，指将推送指仓库默认分支的部署至产品环境。如果这部分需要手动触发，这就是一个持续交付（Continuous Delivery）环节</p><p><img src="https://static.geekbang.org/infoq/5cac03c74862e.png?imageView2/0/w/800" alt></p><p>如上图所示，该流水线展示了一个软件在其最终交付给客户或者投入上线之前，它在其生命周期内各个阶段中的移动过程。</p><p>我们可以看到软件从代码完成到最终交付先后会经历构建(build)、单元测试(unit test)、部署(deploy)、自动测试(auto test)、部署到生产环境(deploy to production)以及度量和验证(measure &amp; validate)等多个阶段。</p><p>具体阶段说明请参考 <a href="https://www.infoq.cn/article/WHt0wFMDRrBU-dtkh1Xp" target="_blank" rel="noopener">如何从零开始搭建 CI/CD 流水线</a></p><h1 id="部署方案"><a href="#部署方案" class="headerlink" title="部署方案"></a>部署方案</h1><p>目前与gitlab持续集成的比较流行的自动化部署解决方案主要有jenkins和GitLab CI/CD两种。</p><h2 id="Jenkins"><a href="#Jenkins" class="headerlink" title="Jenkins"></a>Jenkins</h2><p>Jenkins 是一款比较流行的持续化集成自动化工具，为我们提供了各种接口和工具，用以实现软件开发整个过程的自动化。</p><p>如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/20190110163723744.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NkYmRxbjAwMQ==,size_16,color_FFFFFF,t_70" alt></p><p>由客户端将代码push推送到git仓库，gitlab上配置了一个webHook的东西可以触发Jenkins的构建。</p><p>进入到Jenkins虚线范围内，它所做的事情非常多，从mvn构建代码，对代码进行静态分析，做单元测试，测试通过之后就可以build镜像，镜像构建成功后就把镜像push推送到Harbor镜像仓库中。</p><p>镜像push推送到镜像仓库后，我们就可以调用kubernetes集群的restAPI更新服务，而后kubernetes接收到了更新的指令，从Harbor镜像仓库pull拉取镜像，从而完成服务的更新与重启，最后我们从客户端来访问kubernetes集群的服务</p><p><big><strong>优点:</strong> </big> 编译服务和代码仓库分离，而且编译配置文件不需要在工程中配置，如果团队有开发、测试、配置管理员、运维、实施等完整的人员配置，那就采用jenkins，这样职责分明。jenkins依靠它丰富的插件，可以配置很多gitlab-ci不存在的功能，比如说看编译状况统计等。</p><p><big><strong>缺点:</strong> </big> 配置相对复杂，维护成本较高等</p><h2 id="GitLab-CI-CD"><a href="#GitLab-CI-CD" class="headerlink" title="GitLab CI/CD"></a>GitLab CI/CD</h2><p>GitLab CI/CD 是GitLab Continuous Integration（Gitlab持续集成）的简称。GitLab 自GitLab 8.0开始提供了持续集成的功能，且对所有项目默认开启。只要在项目仓库的根目录添加.gitlab-ci.yml文件，并且配置了Runner（运行器），那么每一次push或者合并请求（Merge Request）都会触发CI Pipeline。</p><p>如图所示，可以理解为GitLab CI/CD是Gitlab给开发者提供的一项功能，它在代码提交后自动触发一段开发者自定义的脚本，以此来完成诸如但不限于构建部署的工作。</p><p><img src="https://pic1.zhimg.com/80/v2-a91bb21049a0a797d4092789aa16b808_720w.jpg" alt></p><h3 id="关键概念"><a href="#关键概念" class="headerlink" title="关键概念"></a>关键概念</h3><h4 id="Pipelines"><a href="#Pipelines" class="headerlink" title="Pipelines"></a>Pipelines</h4><p>Pipelines 中文称为流水线，是分阶段执行的构建任务。如：安装依赖、运行测试、打包、部署开发服务器、部署生产服务器等流程。每一次push或者Merge Request都会触发生成一条新的Pipeline</p><h4 id="Stages"><a href="#Stages" class="headerlink" title="Stages"></a>Stages</h4><p>Stages 表示构建阶段，可以理解为上面所说“安装依赖”、“运行测试”等环节的流程。我们可以在一次 Pipeline 中定义多个 Stages，这些 Stages 会有以下特点：</p><ol><li>所有 Stages 会按照顺序运行，即当一个 Stage 完成后，下一个 Stage 才会开始（当然可以在.gitlab-ci.yml文件中配置上一阶段失败时下一阶段也执行）</li><li>只有当所有 Stages 完成后，该构建任务 (Pipeline) 才会成功</li><li>如果任何一个 Stage 失败，那么后面的 Stages 不会执行，该构建任务 (Pipeline) 失败</li></ol><h4 id="Jobs"><a href="#Jobs" class="headerlink" title="Jobs"></a>Jobs</h4><p>Jobs 表示构建的作业（或称之为任务），表示某个 Stage 里面执行的具体任务。我们可以在 Stages 里面定义多个 Jobs，这些 Jobs 会有以下特点：</p><ol><li>相同 Stage 中的 Jobs 无执行顺序要求，会并行执行</li><li>相同 Stage 中的 Jobs 都执行成功时，该 Stage 才会成功</li><li>如果任何一个 Job 失败，那么该 Stage 失败，即该构建任务 (Pipeline) 也失败（可以在.gitlab-ci.yml文件中配置允许某 Job 可以失败，也算该 Stage 成功）</li></ol><p><big> <strong>优点:</strong> </big>完美和gitlab进行集成，gitlab-ci已经集成进gitlab服务器中，在使用的时候只需要安装配置gitlab-runner即可。 gitlab-runner基本上提供了一个可以进行编译的环境，负责从gitlab中拉取代码，根据工程中配置的gitlab-ci.yml，执行相应的命令进行编译。</p><p><big> <strong>缺点:</strong> </big>功能相对少一些，没有web页面查看等</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>由于采用Jenkins进行自动化集成部署较为复杂，GitLab完美和GitLab集成，更为简单和方便，且对于我来说，GitLab CI/CD所提供等功能已足够使用，所以我更偏向于“小而精”的GitLab CI/CD而不是“大而全”的Jenkins。</p><h1 id="GitLab-CI-CD实战"><a href="#GitLab-CI-CD实战" class="headerlink" title="GitLab CI/CD实战"></a>GitLab CI/CD实战</h1><p>说了这么多，相信大家已经迫不及待地跃跃欲试了，下面就介绍一下GitLab CI/CD的使用步骤。</p><p>参考： <a href="http://192.168.9.251/help/ci/quick_start/README" target="_blank" rel="noopener">GitLab CI / CD入门</a></p><p>其实大体来说就两步：</p><ol><li>在项目的根目录下添加一个配置文件 .gitlab-ci.yaml</li><li>配置一个 GitLab Runner</li></ol><h2 id="配置-gitlab-ci-yml"><a href="#配置-gitlab-ci-yml" class="headerlink" title="配置 .gitlab-ci.yml"></a>配置 .gitlab-ci.yml</h2><p>GitLab 中默认开启了 Gitlab CI/CD 的支持，且使用YAML文件.gitlab-ci.yml来管理项目构建配置。该文件需要存放于项目仓库的根目录（默认路径，可在 GitLab 中修改），它定义该项目的 CI/CD 如何配置。所以，我们只需要在.gitlab-ci.yml配置文件中定义流水线的各个阶段，以及各个阶段中的若干作业（任务）即可。</p><p>下面是.gitlab-ci.yml文件的一个简单的Hello World示例：</p><pre><code># 定义 build 和 test 两个 Stages    stages:  - build  - test# 定义 build 阶段的一个 jobbuild_job:  stage: build  script:    - echo &quot;the project is being built&quot;# 定义 test 阶段的一个 jobtest_job:  stage: test  script:    - echo &quot;the project is being built&quot;</code></pre><p>以上配置中，用 stages 关键字来定义 Pipeline 中的各个构建阶段，然后用一些非关键字来定义 jobs。每个 job 中可以可以再用 stage 关键字来指定该 job 对应哪个 stage。job 里面的script关键字是每个 job 中必须要包含的，它表示每个 job 要执行的命令。</p><p>关于.gitlab-ci.yml的详细配置规则可参考官方文档 <a href="https://docs.gitlab.com/ce/ci/yaml/README.html" target="_blank" rel="noopener">GitLab CI/CD pipeline configuration reference</a></p><p>配置完就可以直接 commit &amp; push 这个配置文件了<br>一旦提交了这个 .gitlab-ci.yaml文件，那么下次在任何一次push到gitlab的操作，GitLab都会查找该.gitlab-ci.yml<br>文件并根据该文件的内容在 gitlab Runners上执行jobs。</p><p>此时再查看 CI/CD -&gt; popeline 可以发现会有一条pipeline 处于挂起阶段，这是因为我们没有注册gitlab runner的原因</p><p>导致无法运行 .gitlab-ci.yaml中的jobs，那么下面我们就来安装一下 gitlab runner</p><h2 id="安装GitLab-Runner"><a href="#安装GitLab-Runner" class="headerlink" title="安装GitLab Runner"></a>安装GitLab Runner</h2><p>gitlab runner 用于与git服务器进行通信，当有新的任务发布到当前runner时，runner会执行.gitlab-ci.yml所定义的CI指令。</p><p>如果你的操作系统和我一样是macOS，那么可以采用以下方式进行安装：</p><p>方式一：用homebrew进行安装，在命令行中直接执行</p><pre><code>brew install gitlab-runner</code></pre><p>方式二（官方）：Gitlab runner 10以上安装方式，若安装旧版本前往官网查看<br>（1）下载</p><pre><code>sudo curl --output /usr/local/bin/gitlab-runner https://gitlab-runner-downloads.s3.amazonaws.com/latest/binaries/gitlab-runner-darwin-amd64</code></pre><p>(2)设置权限</p><pre><code>sudo chmod +x /usr/local/bin/gitlab-runner</code></pre><p>其他安装方式可参考 <a href="https://docs.gitlab.com/runner/install/" target="_blank" rel="noopener">Install GitLab Runner</a></p><h2 id="注册-gitlab-runner"><a href="#注册-gitlab-runner" class="headerlink" title="注册 gitlab runner"></a>注册 gitlab runner</h2><p>命令的交互式的过程如下：</p><pre><code>➜  ~ git:(master) ✗ sudo gitlab-runner registerRuntime platform                                    arch=amd64 os=linux pid=17 revision=6fbc7474 version=13.1.1Running in system-mode.# 输入公司的 GitLab 网站地址，可以在 Settings -&gt; CI/CD -&gt; Runner 中找到Please enter the gitlab-ci coordinator URL (e.g. https://gitlab.com/):http://192.168.9.251/# 你项目仓库的token，token可以在 Settings -&gt; CI/CD -&gt; Runner 中找到Please enter the gitlab-ci token for this runner:ienceCevg-sdxqQhBaGZ# 输入描述这个 runner 的名称，这个字段没有特殊的作用，只是为了区分不同的runner，这里可设置为runner-serverPlease enter the gitlab-ci description for this runner:[1b6095f8f875]: runner-server# tags这个属性，job和runner都有，用来匹配任务和执行任务的runner。runner的tag可以有多个，注册时用逗号（comma）分隔即可。当某个job的tag是当前runner tags的一个子集时，这个job就可以被分配到当前runner上执行Please enter the gitlab-ci tags for this runner (comma separated):testRegistering runner... succeeded                     runner=ienceCev# executor就是执行job的环境，通常我们都会选择Shell，如果有其他需要的也可以自行查阅文档。需要注意的是，runner执行的环境是非常干净的，像类似ANDROID_HOME的变量都需要通过shell指令export xxx=xxx在执行时输入，而不是使用设备上的环境。Please enter the executor: docker, shell, ssh, docker+machine, docker-ssh+machine, custom, docker-ssh, parallels, virtualbox, kubernetes:shellRunner registered successfully. Feel free to start it, but if it&#39;s running already the config should be automatically reloaded!</code></pre><p>以上流程注册成功之后，就可以在你的项目仓库中 Settings -&gt; CI/CD -&gt; Runner看到这个 Runner 了。</p><p><img src="https://note.youdao.com/yws/public/resource/bc554143fcca768f52bf1354ffef92eb/xmlnote/EE6BA5A809BA4D5E8DE7A943D7A8EB14/2579?ynotemdtimestamp=1595666133983" alt></p><h2 id="安装共享runner"><a href="#安装共享runner" class="headerlink" title="安装共享runner"></a>安装共享runner</h2><p>安装共享runner与安装专有runner类似，主要区别在于共享runner需要gitlab的管理员权限，进入管理员界面，overview-&gt;runner，将runner的token和URL复制下来，在注册的时候添加进去就可以，此处不再赘述，详细步骤请参考<a href="https://cloud.tencent.com/developer/article/1411267" target="_blank" rel="noopener">此处</a></p><h1 id="GitLab-runner-常用命令"><a href="#GitLab-runner-常用命令" class="headerlink" title="GitLab runner 常用命令"></a>GitLab runner 常用命令</h1><p>下面表格列出了 Gitlab runner 的常用命令：</p><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>gitlab-runner run</td><td>运行一个runner服务</td></tr><tr><td>gitlab-runner register</td><td>注册一个新的runner</td></tr><tr><td>gitlab-runner start</td><td>启动服务</td></tr><tr><td>gitlab-runner stop</td><td>关闭服务</td></tr><tr><td>gitlab-runner restart</td><td>重启服务</td></tr><tr><td>gitlab-runner status</td><td>查看各个runner的状态</td></tr><tr><td>gitlab-runner unregister</td><td>注销掉某个runner</td></tr><tr><td>gitlab-runner list</td><td>显示所有运行着的runner</td></tr><tr><td>gitlab-runner verify</td><td>检查已注册的运行程序是否可以连接到GitLab，但它不验证GitLab Runner服务是否正在使用运行程序。</td></tr></tbody></table><p>更多命令请参考 <a href="https://docs.gitlab.com/runner/commands/README.html" target="_blank" rel="noopener">GitLab Runner commands</a></p><p>此时，再回 gitlab 仓库查看并重新运行之前刮起的pipeline，等待一会儿会发现运行通过了</p><p><img src="https://note.youdao.com/yws/public/resource/bc554143fcca768f52bf1354ffef92eb/xmlnote/6E07FADE32774BABB8735C787120F04B/2601?ynotemdtimestamp=1595666133983" alt="pipeline"></p><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ol><li><p>每次向 gitlab 推送完代码后，会自动触发一条 pipeline，可点击 gitlab 左侧边栏的 CI/ID 进行查看 pipeline 的运行情况。</p><p><img src="https://note.youdao.com/yws/public/resource/bc554143fcca768f52bf1354ffef92eb/xmlnote/221CC727BF154DC8B47E53D732299ED3/3030" alt></p></li><li><p>某些 job 运行失败可能是由于网络问题，比如 gcc 安装和更新失败，此时可点击重试。</p></li><li><p>目前跑完一条完整的 pipeline 需要时间较长， 为了保证开发效率，建议每次完成开发，推送代码前先在本地进行以下检查。</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">go</span> buildgolangci<span class="token operator">-</span>lint run<span class="token keyword">go</span> test <span class="token punctuation">.</span><span class="token operator">/</span><span class="token operator">...</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果存在问题先解决问题，确保没问题之后再向 gitlab 推送代码。</p></li><li><p>目前静态代码检查采用的 golangci-lint 为1.18.0版本，可从<a href="http://192.168.9.251:9000/software" target="_blank" rel="noopener">此处</a>下载。</p></li><li><p>编译镜像成功后会自动将镜像推送到 harbor 镜像仓库，如果有需要可直接从镜像仓库进行<a href="http://192.168.9.8/harbor/projects/17/repositories/crosschain%2Fcrossnet" target="_blank" rel="noopener">拉取</a>。</p></li><li><p>关于 GitLab CI/CD 的更多详细内容请参考<a href="ttps://docs.gitlab.com/ee/ci/" target="_blank" rel="noopener">官方文档</a>。</p></li></ol><h1 id="踩坑指南"><a href="#踩坑指南" class="headerlink" title="踩坑指南"></a>踩坑指南</h1><h2 id="安装-gitlab-runner-失败"><a href="#安装-gitlab-runner-失败" class="headerlink" title="安装 gitlab runner 失败"></a>安装 gitlab runner 失败</h2><p>在实际安装 gitlab runner 的过程中发现采用上面的方式二会特别慢，而采用方式一则在下一步注册 Gitlab Runner的时候会出现如下问题：</p><pre><code>➜  ~ git:(master) ✗ sudo gitlab-runner registerPassword:[1]    37431 killed     sudo gitlab-runner register</code></pre><p>在网上搜寻解决方案未果，于是决定采用docker进行安装，步骤如下：</p><p>执行以下命令创建容器并启动</p><pre><code>docker run -d --name gitlab-runner --restart always -v ~/gitlab-runner/config:/etc/gitlab-runner -v /var/run/docker.sock:/var/run/docker.sock  gitlab/gitlab-runner:latest</code></pre><p>执行完成后可以 docker ps 一下进行查看</p><pre><code>➜  ~ git:(master) ✗ docker psCONTAINER ID        IMAGE                         COMMAND                  CREATED             STATUS              PORTS               NAMES1b6095f8f875        gitlab/gitlab-runner:latest   &quot;/usr/bin/dumb-init …&quot;   5 seconds ago       Up 3 seconds                            gitlab-runner</code></pre><p>然后注册 gitlab runner，只需执行</p><pre><code>docker exec -it 1b6095f8f875 gitlab-runner register</code></pre><p>其中 1b6095f8f875 是上一步执行的返回的 ID</p><h2 id="安装完-gitlab-runner-显示-pipeline-stuck"><a href="#安装完-gitlab-runner-显示-pipeline-stuck" class="headerlink" title="安装完 gitlab runner 显示 pipeline stuck"></a>安装完 gitlab runner 显示 pipeline stuck</h2><ol><li><p>可能是没有设置为忽略tag的原因, 去设置-&gt; CICD界面下将 tag 那个选项打勾就行</p></li><li><p>可能是 gitlab-runner 容器挂掉了, 可以登录gitlab-runner所在服务器执行</p><pre><code>docker restart gitlab-runner</code></pre></li></ol><h2 id="pipeline-运行时报错【Permission-denied】"><a href="#pipeline-运行时报错【Permission-denied】" class="headerlink" title="pipeline 运行时报错【Permission denied】"></a>pipeline 运行时报错【Permission denied】</h2><p><img src="https://note.youdao.com/yws/public/resource/bc554143fcca768f52bf1354ffef92eb/xmlnote/C512459EDB3A41A7938D5DB227C26E61/2630?ynotemdtimestamp=1595666133983" alt></p><p>在跑 CICD的时候发现以上错误，一开始以为是权限的问题，但是加了dudo依然未能解决，后来通过复盘 gitlab runner安装、注册等全过程，发现在安装gitlab是采用的docker模式，但是注册gitlab时指定的运行环境是shell，于是换成了docker，重新跑了一下，原来的错误消失了</p><p>PS: 指定执行环境是docker后，还需指定 docker image 为 stable, 如下：</p><pre><code>Please enter the executor: virtualbox, docker+machine, docker-ssh, shell, parallels, ssh, docker-ssh+machine, kubernetes, custom, docker:dockerPlease enter the default Docker image (e.g. ruby:2.6):docker:stable</code></pre><h2 id="运行-docker-命令报错"><a href="#运行-docker-命令报错" class="headerlink" title="运行 docker 命令报错"></a>运行 docker 命令报错</h2><p>运行docker info命令时报错</p><p><img src="https://note.youdao.com/yws/public/resource/bc554143fcca768f52bf1354ffef92eb/xmlnote/5308331A5FF94826A5BFB66F128CF7CF/2644?ynotemdtimestamp=1595666133983" alt></p><p>查找资料<br><a href="https://gitlab.com/gitlab-org/gitlab-runner/-/issues/4566" target="_blank" rel="noopener">https://gitlab.com/gitlab-org/gitlab-runner/-/issues/4566</a></p><p>修改配置文件</p><pre><code>vim gitlab-runner/config/config.toml</code></pre><p>volumes 配置项</p><pre><code>volumes = [&quot;/cache&quot;, &quot;/var/run/docker.sock:/var/run/docker.sock&quot;]</code></pre><p>重新启动 gitlab runner </p><pre><code>docker restart 99451b349e7f</code></pre><p>其中 99451b349e7f 为容器ID</p><p>再重新跑pipeline，发现原来的错误消失了</p><h2 id="执行shell脚本报错"><a href="#执行shell脚本报错" class="headerlink" title="执行shell脚本报错"></a>执行shell脚本报错</h2><p><img src="https://note.youdao.com/yws/public/resource/bc554143fcca768f52bf1354ffef92eb/xmlnote/3B9F8F27F2A049CD92C6C92BB1A35B19/2664?ynotemdtimestamp=1595666133983" alt></p><p>通过搜寻资料发现</p><p>请注意，docker镜像是基于alpine的，默认不提供bash。<br>所以脚本应该使用sh，以便更加通用。</p><p>改成如下格式后经过测试通过</p><pre><code>sh scripts/fmt.sh</code></pre><h2 id="curl命令未找到-【curl-not-found】"><a href="#curl命令未找到-【curl-not-found】" class="headerlink" title="curl命令未找到 【curl: not found】"></a>curl命令未找到 【curl: not found】</h2><p><img src="https://note.youdao.com/yws/public/resource/bc554143fcca768f52bf1354ffef92eb/xmlnote/24C3D0434AB147BC80AE067140047D01/2671?ynotemdtimestamp=1595666133983" alt></p><p>搜寻资料<a href="https://stackoverflow.com/questions/46031069/curl-command-not-found-on-gitlab-ci-yml" target="_blank" rel="noopener">curl command not found on .gitlab-ci.yml</a></p><p>使用apk命令下载 curl 命令，而不是 apt-get</p><pre><code>services:  - name: docker:dind  before_script:    - apk add --update curl &amp;&amp; rm -rf /var/cache/apk/*</code></pre><h2 id="编译报错-not-found"><a href="#编译报错-not-found" class="headerlink" title="编译报错 not found"></a>编译报错 not found</h2><p>参考<br><a href="https://www.dyxmq.cn/uncategorized/installed-go-binary-not-found-in-path-on-alpine-linux-docker.html" target="_blank" rel="noopener">https://www.dyxmq.cn/uncategorized/installed-go-binary-not-found-in-path-on-alpine-linux-docker.html</a></p><p>编译时添加参数CGO_ENABLED=0</p><pre><code>CGO_ENABLED=0 go build</code></pre><h2 id="安装-go-环境失败"><a href="#安装-go-环境失败" class="headerlink" title="安装 go 环境失败"></a>安装 go 环境失败</h2><p>下载了 go 的安装包且配置好了 GOROOT 和 GOPATH 等，但执行 go version 依旧报错</p><p><img src="https://note.youdao.com/yws/public/resource/bc554143fcca768f52bf1354ffef92eb/xmlnote/F3FF604F026B45F38A44D48691D10B37/2694?ynotemdtimestamp=1595666133983" alt></p><p>查找资料<br><a href="https://stackoverflow.com/questions/34729748/installed-go-binary-not-found-in-path-on-alpine-linux-docker" target="_blank" rel="noopener">https://stackoverflow.com/questions/34729748/installed-go-binary-not-found-in-path-on-alpine-linux-docker</a></p><p>执行以下命令修复丢失的依赖项，解决</p><pre><code>mkdir /lib64 &amp;&amp; ln -s /lib/libc.musl-x86_64.so.1 /lib64/ld-linux-x86-64.so.2</code></pre><h2 id="执行-golangci-lint-run-报错：DecodeRuneInString-not-declared-by-package-utf8-typecheck"><a href="#执行-golangci-lint-run-报错：DecodeRuneInString-not-declared-by-package-utf8-typecheck" class="headerlink" title="执行 golangci-lint run 报错：DecodeRuneInString not declared by package utf8 (typecheck)"></a>执行 golangci-lint run 报错：DecodeRuneInString not declared by package utf8 (typecheck)</h2><p><a href="https://github.com/golangci/golangci-lint/issues/658" target="_blank" rel="noopener">https://github.com/golangci/golangci-lint/issues/658</a></p><p>替换 golangci-lint 版本由 v1.16.0 为 v1.18.0 解决问题</p><h2 id="跑-golangci-lint-报错【could-not-import-C-no-metadata-for-C-typecheck-】"><a href="#跑-golangci-lint-报错【could-not-import-C-no-metadata-for-C-typecheck-】" class="headerlink" title="跑 golangci-lint 报错【could not import C (no metadata for C) (typecheck)】"></a>跑 golangci-lint 报错【could not import C (no metadata for C) (typecheck)】</h2><p><img src="https://note.youdao.com/yws/public/resource/bc554143fcca768f52bf1354ffef92eb/xmlnote/7617F64AB4A84C01813E6514C27128CB/2882?ynotemdtimestamp=1595666133983" alt></p><p>搜索资料</p><p><a href="https://github.com/golangci/golangci-lint/issues/602" target="_blank" rel="noopener">https://github.com/golangci/golangci-lint/issues/602</a></p><p>需要安装 gcc，但由于 alpine-linux 环境不支持 apt-get 命令，只能用 apk 安装 gcc </p><p><a href="https://www.jianshu.com/p/30fa6448bb63" target="_blank" rel="noopener">https://www.jianshu.com/p/30fa6448bb63</a></p><p>alpine默认的安装源慢得要命</p><p>通过修改源加快安装速度</p><pre><code>echo &quot;https://mirror.tuna.tsinghua.edu.cn/alpine/v3.8/main&quot; &gt; /etc/apk/repositoriesecho &quot;https://mirror.tuna.tsinghua.edu.cn/alpine/v3.8/community&quot; &gt;&gt; /etc/apk/repositories</code></pre><p>然后再安装 gcc</p><pre><code>apk add build-base</code></pre><h2 id="跑-golangci-lint-遇到-【no-go-files-to-analyze】问题"><a href="#跑-golangci-lint-遇到-【no-go-files-to-analyze】问题" class="headerlink" title="跑 golangci-lint 遇到 【no go files to analyze】问题"></a>跑 golangci-lint 遇到 【no go files to analyze】问题</h2><p><img src="https://note.youdao.com/yws/public/resource/bc554143fcca768f52bf1354ffef92eb/xmlnote/B8CDA49BABF54CC093121CC9C0E92F51/2897?ynotemdtimestamp=1595666133983" alt></p><p>说明少了对应的包，需要去导入包</p><h1 id="gitlab-ci-yaml-样例"><a href="#gitlab-ci-yaml-样例" class="headerlink" title=".gitlab-ci.yaml 样例"></a>.gitlab-ci.yaml 样例</h1><pre><code>variables:  REGISTRY_USER: admin  REGISTRY_PASSWORD: yunphant  REGISTRY_ADDR: 192.168.9.8:80  TARGET_IMAGE: $REGISTRY_ADDR/$ORG_DIR/$PROJECT_DIR:latest  GOROOT: /home/centos/go  GOPATH: /home/centos/gopath  ORG_DIR: crosschain  PROJECT_DIR: crossnetbefore_script:#  - echo &quot;更换源&quot;  - echo &quot;https://mirror.tuna.tsinghua.edu.cn/alpine/v3.8/main&quot; &gt; /etc/apk/repositories  - echo &quot;https://mirror.tuna.tsinghua.edu.cn/alpine/v3.8/community&quot; &gt;&gt; /etc/apk/repositories#  - echo &quot;安装go环境&quot;  - mkdir -p $GOROOT  - mkdir -p $GOPATH  - tar -C /home/centos -zxvf ./util/go1.13.4.linux-amd64.tar.gz  - touch .bash_profile  - echo &#39;export GOROOT=/home/centos/go&#39;&gt;&gt;.bash_profile  - echo &#39;export GOPATH=/home/centos/gopath&#39;&gt;&gt;.bash_profile  - echo &#39;export PATH=$PATH:$GOPATH:$GOROOT/bin&#39;&gt;&gt;.bash_profile  - source .bash_profile#  - echo &quot;修复丢失的依赖项&quot;  - mkdir /lib64 &amp;&amp; ln -s /lib/libc.musl-x86_64.so.1 /lib64/ld-linux-x86-64.so.2  - go version#  - echo &quot;go环境安装完成&quot;#  - echo &quot;安装beego环境&quot;  - mkdir -p $GOPATH/src/github.com  - tar -xvf ./util/astaxie.tar.gz -C $GOPATH/src/github.com  - tar -xvf ./util/bee_1.10.0_linux_amd64.tar.gz#  - echo &quot;beego环境安装完成&quot;#  - echo &quot;设置工作目录&quot;  - WORK_DIR=&quot;$GOPATH/src/$ORG_DIR&quot;  - mkdir -p $WORK_DIR#  - echo &quot;将工作目录链接到当前目录&quot;  - ln -sfv &quot;$(pwd -P)&quot; &quot;$WORK_DIR&quot;#  - echo &quot;进入工作目录&quot;  - cd &quot;$WORK_DIR/$PROJECT_DIR&quot;stages:  - build  - lint  - test  - build_image  - push_image  - deploybuild:  stage: build  script:#    - echo &quot;构建项目&quot;    - CGO_ENABLED=0 go build#    - echo &quot;构建完成&quot;  allow_failure: truelint:  stage: lint  script:    #安装gcc    - apk update &amp;&amp; apk add gcc g++#    - echo &quot;安装 goalangci-lint 工具&quot;    - tar zxvf ./util/golangci-lint-1.18.0-linux-amd64.tar.gz -C /tmp/ &amp;&amp; cp  /tmp/golangci-lint-1.18.0-linux-amd64/golangci-lint $GOPATH/golangci-lint    - rm -rf /tmp/golangci-lint-1.18.0-linux-amd64 &amp;&amp; rm -rf /tmo/golangci-lint-1.18.0-linux-amd64.tar.gz#    - echo &quot;执行 golangci-lint 代码检查&quot;    - GL_DEBUG=linters_output GOPACKAGESPRINTGOLISTERRORS=1 golangci-lint run#    - echo &quot;golangci-lint 代码检查完成&quot;  allow_failure: truetest:  stage: test  script:    #安装gcc    - apk update &amp;&amp; apk add gcc g++#    - echo &quot;运行单元测试&quot;    - CGO_LDFLAGS_ALLOW=.* CGO_CFLAGS_ALLOW=.* go test ./... -v#    - echo &quot;单元测试通过&quot;  allow_failure: truebuild_image:  stage: build_image  script:#    - echo &quot;构建镜像&quot;    - docker build -t $TARGET_IMAGE .#    - echo &quot;镜像构建完成&quot;  allow_failure: truepush_image:  stage: push_image  script:#    - echo &quot;推送镜像到镜像仓库&quot;    - docker login -u $REGISTRY_USER -p $REGISTRY_PASSWORD $REGISTRY_ADDR    - docker push $TARGET_IMAGE#    - echo &quot;镜像推送完成&quot;  allow_failure: truedeploy:  stage: deploy  script:#    - echo &quot;开始部署&quot;#    - echo &quot;删除原有容器&quot;    - docker stop $CI_PROJECT_NAME    - docker rm $CI_PROJECT_NAME#    - echo &quot;启动容器&quot;    - docker run --name $CI_PROJECT_NAME -p 8080:8080  -v /home/centos/gopath/src/$ORG_DIR/$CI_PROJECT_NAME:/var/ $TARGET_IMAGE#    - echo &quot;部署成功&quot;  allow_failure: true</code></pre><h1 id="Dockerfile-样例"><a href="#Dockerfile-样例" class="headerlink" title="Dockerfile 样例"></a>Dockerfile 样例</h1><pre><code># 使用Go的官方镜像作为基础镜像FROM golang:1.12-alpineMAINTAINER xiongweigang xiongwg@yunphant.com# 设置环境变量ENV GOROOT=/usr/local/goENV GOPATH $HOME/goENV PATH $PATH:$GOPATH/binENV GOPROXY https://goproxy.cn,direct# 设置工作目录RUN mkdir -p /go/src/crosschain/crossnetRUN mkdir -p /go/src/github.comWORKDIR /go/src/crosschain/crossnet# 拷贝Dockerfile同级目录的所有文件到docker中的指定位置ADD ./ /go/src/crosschain/crossnet# 拷贝bee可执行命令到docker中的指定位置COPY ./bee_1.10.0_linux_amd64/bee /usr/local/go/bin/COPY ./bee_1.10.0_linux_amd64/bee $GOPATH/bin/# 安装beego源码RUN tar -xvf ./util/astaxie.tar.gz -C /go/src/github.com# 通过开放容器的8080端口暴露该应用程序EXPOSE 8080# 使用bee命令开始对应用程序进行实时重载CMD [&quot;bee&quot;, &quot;run&quot;]</code></pre><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://www.infoq.cn/article/WHt0wFMDRrBU-dtkh1Xp" target="_blank" rel="noopener">如何从零开始搭建 CI/CD 流水线</a></li><li><a href="https://docs.gitlab.com/ee/ci/" target="_blank" rel="noopener">GitLab CI/CD官方文档</a></li><li><a href="https://developer.aliyun.com/article/754508" target="_blank" rel="noopener">GitLab+Docker搭建CI/CD自动化部署</a></li><li><a href="https://www.cnblogs.com/jingtyu/p/9604317.html" target="_blank" rel="noopener">自动化部署方案CICD</a></li><li><a href="https://zhuanlan.zhihu.com/p/51163261" target="_blank" rel="noopener">Gitlab CI&amp;CD 实战经验分享</a></li><li><a href="https://blinkfox.github.io/2018/11/22/ruan-jian-gong-ju/devops/gitlab-ci-jie-shao-he-shi-yong/#alipay" target="_blank" rel="noopener">GitLab CI/CD 介绍和使用</a></li><li><a href="https://blog.csdn.net/qq_33591903/article/details/102460774" target="_blank" rel="noopener">浅谈CICD持续集成、持续部署的流程</a></li><li><a href="https://www.jianshu.com/p/30e3f2940078" target="_blank" rel="noopener">gitlab-ci的简易入门——runners</a></li><li><a href="https://juejin.im/post/5e741a5a518825490e4582b7" target="_blank" rel="noopener">GitLab CI/CD 自动部署构建</a></li><li><a href="https://cloud.tencent.com/developer/article/1411267" target="_blank" rel="noopener">Gitlab的第一个shared Runners配置(shared类型)</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> GitLab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GitLab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fabric国密改造全记录</title>
      <link href="/2020/06/29/fabric-gm/"/>
      <url>/2020/06/29/fabric-gm/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><blockquote><p>最近应公司项目需求，需要对fabric中的加密相关模块进行改造，主要目的是使fabric底层加密服务支持国密算法sm2、sm3以及sm4等。借这次机会，顺便熟悉一下fabric加密模块的源码实现，故此处简单记录了国密改造的整个过程。</p></blockquote><p>fabric tag: 1.4.1</p><h1 id="国密改造整体方案"><a href="#国密改造整体方案" class="headerlink" title="国密改造整体方案"></a>国密改造整体方案</h1><p>msp是基于数字证书的成员身份管理，会调用bccsp即证书服务完成签名验签等功能。Fabric提供国密算法服务，需要同时使用基于国密的数字证书服务，以便使用数字证书时，能验证国密的数字签名，辨别用户身份。</p><p>bccsp模块对上层抽象出了区块链密码服务，包含非对称加密、对称加密、数字签名算法、摘要计算，以及各种算法对于的密钥生成和导入。不同的加密算法需要实现bccsp中定义的接口，以向上层提供加密服务。目前，bccsp中支持标准加密的软实现和标准加密的硬实现。提供国密算法服务，就需要国密算法实现，实现bccsp模块中定义的接口。</p><p>设计gm接口实现国密库的可插拔，实现使用不同的国密库的目的，利用gm接口实现bccsp中的国密插件，在底层国密库更换时，国密插件和Fabric上层模块无需修改。</p><p>为每一个国密实现都进行一次封装，形成各自的gm adapter，满足gm接口。国密实现可以是C语言的动态链接库，可以是Go语言模块，甚至可以是基于加密机提供的RPC加密服务接口。</p><p>设计证书接口实现证书库的可插拔，实现使用不同证书库的目的。利用证书接口实现证书操作函数，fabric中所有证书操作，都调用封装的证书函数，在使用不同证书库时，fabric上层模块无需再适配证书库。</p><p>为每一个证书库都进行一次封装，形成各自的x509 cert adapter，为了让Fabric同时支持国密和标准加密，需要封装Go标准库中的证书操作，以及国密证书库，形成2个不同的插件。</p><h2 id="准备工作："><a href="#准备工作：" class="headerlink" title="准备工作："></a>准备工作：</h2><p>确定 base 分支</p><p>熟悉底层加密实现库</p><ol><li>C语言的动态链接库</li><li>Go语言实现</li><li>加密机提供的RPC加密服务接口</li></ol><h2 id="模块拆分"><a href="#模块拆分" class="headerlink" title="模块拆分"></a>模块拆分</h2><p>先来总体看一下fabric进行国密改造会涉及到的主要模块</p><p><img src="http://qlkvpxmsx.hd-bkt.clouddn.com/%E5%9B%BD%E5%AF%86%E6%94%B9%E9%80%A0.png" alt></p><p>如图所示，从上往下，首先是上层调用模块，这一块主要是msp等模块，为fabric提供成员加密服务，它的实现依赖于BCCSP模块和X509模块。</p><p>我们先看右边，BCCSP模块主要是实现四套接口，分别是BCCSP接口、opts接口、key接口以及keystore接口，其中以BCCSP接口为主，它包含了加解密、签名验签等主要方法，其他三套接口为辅，主要包含了用于密钥管理和存储的一些方法。</p><p>接着往下，BCCSP模块有两套实现，一套是标准加密，它直接依赖于Go SDK原生的加密库，另一套是国密实现，需要依赖于第三方的提供的底层加密库，分为硬实现和软实现，其中硬实现就是加密机，软实现现在主要有G语言实现和C语言动态链接库实现两种。</p><p>考虑到fabric定义的BCCSP接口并不直接兼容于第三方提供的加密接口，因此需要做一个国密适配器，主要用于适配上层的BCCSP模块和底层的第三方加密库，这个国密适配器主要包含了SM2、SM3以及SM4三种国密算法的适配。</p><p>然后我们看一下左边，X509模块主要提供的是有关证书的一系列方法。在这里fabric原先默认是使用标准X509的，底层直接调用的是Go SDK 原生的加密库。为了让X509支持国密的同时也兼容标准加密，这里我们就把证书相关的接口抽象出来，定义为X509接口。然后底层采用两套实现，标准加密和非国密实现，标准加密依旧是直接调用原生Go SDK标准加密库，而国密则是调用第三方的国密库。</p><p>需要说明的是，在调用BCCSP模块的加密服务时，如果选择国密算法，需要加载一个国密的插件，而如果是标准加密，则不需要加密国密插件；在调用X509模块的证书服务时，不管是国密X509证书还是标准X509证书均需要加密X509插件。具体选择国密还是标准加密算法可通在orderer、peer和cli的配置文件中的配置项进行指定。</p><h2 id="方法和接口一览"><a href="#方法和接口一览" class="headerlink" title="方法和接口一览"></a>方法和接口一览</h2><p>上面已经把fabirc国密改造整体涉及到的模块简单介绍了一下，下面我通过们一张图来看一下这些模块具体涉及到的接口和方法以及代码的调用逻辑等。</p><p><img src="http://qlkvpxmsx.hd-bkt.clouddn.com/fabric%20%E5%9B%BD%E5%AF%86%E6%94%B9%E9%80%A0.png" alt></p><h5 id="高清大图请戳这里"><a href="#高清大图请戳这里" class="headerlink" title="高清大图请戳这里"></a>高清大图请戳<a href="http://www.xmind.net/m/AimcSi" target="_blank" rel="noopener">这里</a></h5><h1 id="fabric-ca-国密改造"><a href="#fabric-ca-国密改造" class="headerlink" title="fabric ca 国密改造"></a>fabric ca 国密改造</h1><p>Fabric-ca国密支持改造，主要是指Fabric-ca端通过改造使其可以用以生成国密公私钥对、签发、吊销、查询国密类型的证书。证书申请和签发的流程如下图所示，所有改造工作都围绕证书申请和签发的流程展开的：</p><p><img src="https://note.youdao.com/yws/public/resource/bc554143fcca768f52bf1354ffef92eb/xmlnote/E0AD1345011E4AA194EDAB95D1A4DAE3/2719?ynotemdtimestamp=1595668120966" alt></p><p>Fabric-ca主要是调用Fabric的bccsp(blockchain cryptographic service provider,区块链加密服务提供者)模块来完成加解密及签名验签的工作。</p><p>Fabric-ca client端主要负责国密证书的请求签发以及存储国密证书链的工作。对于请求国密证书，client端首先生成国密的公私钥对，并把公钥编码到生成证书的请求中，发送生成国密证书的请求给Fabric-ca的server端。存储国密的证书链则需要使用支持国密适配的x509来解析证书，并写入到client端本地路径中。</p><p>Fabric-ca server端主要负责国密证书的签发、吊销、查询等功能。启动时加载自身的国密证书。在接收到签发请求时，调用国密的签名方法来对证书请求进行签名，并返回国密证书给client端。</p><h2 id="改造要点："><a href="#改造要点：" class="headerlink" title="改造要点："></a>改造要点：</h2><ol><li>Fabric-ca/lib：主要是接口的实现，主要在解析申请证书请求以及签发证书流程要替换为国密算法；</li><li>Fabric-ca/util：该包数据工具类，主要在证书的编解码等操作中扩展国密算法；</li><li>Fabric-ca/vendor：因为CA沿用Fabric中的BCCSP套件，所以需要替换对Fabric的包的引用，提供对国密算法的支持。</li></ol><h2 id="具体接口和方法一览"><a href="#具体接口和方法一览" class="headerlink" title="具体接口和方法一览"></a>具体接口和方法一览</h2><p><img src="http://qlkvpxmsx.hd-bkt.clouddn.com/fabric%20ca%20%E5%9B%BD%E5%AF%86%E6%94%B9%E9%80%A0.png" alt></p><h5 id="高清大图请戳这里-1"><a href="#高清大图请戳这里-1" class="headerlink" title="高清大图请戳这里"></a>高清大图请戳<a href="http://www.xmind.net/m/DpWJni" target="_blank" rel="noopener">这里</a></h5><h1 id="fabric-sdk-国密改造"><a href="#fabric-sdk-国密改造" class="headerlink" title="fabric sdk 国密改造"></a>fabric sdk 国密改造</h1><p>关于README可以参考<a href="https://github.com/hyperledger/fabric-sdk-go/blob/master/README.md" target="_blank" rel="noopener">此处</a></p><p>不过我觉得意义不大，无非是怎么下载下来这个项目，然后跑一下测试</p><p>因此我又自己写了个使用说明文档，可以参考<a href="http://note.youdao.com/s/Fu554jj4" target="_blank" rel="noopener">此处</a></p><p>在改造 SDK 之前，我们先来看一下SDK的目录结构</p><h2 id="2-SDK项目介绍"><a href="#2-SDK项目介绍" class="headerlink" title="2. SDK项目介绍"></a>2. SDK项目介绍</h2><p>首先介绍一下sdk项目的架构。</p><pre><code>├── internal├── pkg├── scripts├── test└── third_party</code></pre><p>其中internal和third_party包含fabric相关核心代码。pkg为sdk核心代码，对外提供接口进行服务。</p><p>internal文件夹</p><pre><code>└── github.com└── github.com    └── hyperledger        ├── fabric        │   ├── bccsp        │   ├── common        │   ├── core        │   ├── discovery        │   ├── gossip        │   ├── msp        │   ├── protoutil        │   ├── sdkinternal        │   └── sdkpatch        └── fabric-ca            ├── api            ├── lib            ├── sdkpatch            └── util</code></pre><p>third_party文件夹：</p><pre><code>└── github.com└── github.com    └── hyperledger        └── fabric            ├── common            ├── core            └── internal</code></pre><p>大概就是这样，废话不多说，直接开始改吧</p><p>添加国密底层实现库 mod</p><p>添加国密插件和X509插件</p><p>添加gmfactory及相关接口</p><p>定义公私钥基础类型并替换原有的公私钥</p><p>将原生的 X509 库替换为自定义的 x509 库</p><p>2.x 不再支持RSA、去掉了插件plugin实现方式</p><p>添加一个orderer字段，用于指定orderer配置</p><p>未完待续……</p>]]></content>
      
      
      <categories>
          
          <category> fabric </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
            <tag> fabric </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GoLand 类图生成工具 plantuml</title>
      <link href="/2020/06/29/plantuml/"/>
      <url>/2020/06/29/plantuml/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文介绍了如何使用 plantuml 工具自动生成Go项目的类图</p></blockquote><h2 id="克隆项目"><a href="#克隆项目" class="headerlink" title="克隆项目"></a>克隆项目</h2><p>在gopath路径下</p><pre><code>git clone git.oschina.net/jscode/go-package-plantuml</code></pre><h2 id="进入项目"><a href="#进入项目" class="headerlink" title="进入项目"></a>进入项目</h2><pre><code>go build</code></pre><p>在 GOPATH/bin 生成一个 二进制文件 plantuml</p><h2 id="用GoLand打开项目，终端输入生成类图命令"><a href="#用GoLand打开项目，终端输入生成类图命令" class="headerlink" title="用GoLand打开项目，终端输入生成类图命令"></a>用GoLand打开项目，终端输入生成类图命令</h2><pre><code>~/go/bin/go-package-plantuml --codedir /Users/xiongweigang/go/src/github.com/wasabi/backEnd --gopath /Users/xiongweigang/go --outputfile /tmp/uml.txt --ignoredir /Users/xiongweigang/go/src/github.com/wasabi/backEnd/vendor</code></pre><h2 id="生成png图片"><a href="#生成png图片" class="headerlink" title="生成png图片"></a>生成png图片</h2><pre><code>java -jar ～/plantuml.jar -verbose -graphvizdot /usr/local/bin/dot /tmp/uml.txt</code></pre><h2 id="生成svg图片-后边加上-tsvg"><a href="#生成svg图片-后边加上-tsvg" class="headerlink" title="生成svg图片 后边加上 -tsvg"></a>生成svg图片 后边加上 -tsvg</h2><pre><code>java -jar ～/plantuml.jar -verbose -graphvizdot /usr/local/bin/dot /tmp/uml.txt -tsvg</code></pre><p>生成后用浏览器打开</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/dwjpeng2/article/details/81667214" target="_blank" rel="noopener">https://blog.csdn.net/dwjpeng2/article/details/81667214</a></p><p><a href="https://yougg.github.io/2017/11/25/goland%E4%B8%AD%E4%BD%BF%E7%94%A8plantuml%E7%94%9F%E6%88%90go-uml%E5%9B%BE/" target="_blank" rel="noopener">https://yougg.github.io/2017/11/25/goland%E4%B8%AD%E4%BD%BF%E7%94%A8plantuml%E7%94%9F%E6%88%90go-uml%E5%9B%BE/</a></p><p><a href="https://juejin.im/post/5da9c00de51d4524cd3b3942" target="_blank" rel="noopener">https://juejin.im/post/5da9c00de51d4524cd3b3942</a></p><p><a href="https://studygolang.com/articles/9719" target="_blank" rel="noopener">https://studygolang.com/articles/9719</a></p>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fabric多机部署（raft共识）</title>
      <link href="/2020/06/21/fabric-deploy-raft/"/>
      <url>/2020/06/21/fabric-deploy-raft/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文介绍了如何搭建一个多机多节点的fabric区块链网络的过程，希望能为小伙伴提供帮助。</p></blockquote><h1 id="fabric多机部署-（raft共识）"><a href="#fabric多机部署-（raft共识）" class="headerlink" title="fabric多机部署 （raft共识）"></a>fabric多机部署 （raft共识）</h1><h2 id="0-准备工作"><a href="#0-准备工作" class="headerlink" title="0. 准备工作"></a>0. 准备工作</h2><h4 id="克隆项目"><a href="#克隆项目" class="headerlink" title="克隆项目"></a>克隆项目</h4><pre><code>git clone git@192.168.9.251:jilg/deployFabric_Raft.git</code></pre><h4 id="节点分配"><a href="#节点分配" class="headerlink" title="节点分配"></a>节点分配</h4><table><thead><tr><th>主机1</th><th>主机 2</th></tr></thead><tbody><tr><td>Org1 peer0 1</td><td>Org2 peer 0 1</td></tr><tr><td>Orderer 0 1 2</td><td>Orderer 0 1</td></tr></tbody></table><br>下面的步骤先在一台主机上操作<h2 id="1-修改证书，创始区块配置文件"><a href="#1-修改证书，创始区块配置文件" class="headerlink" title="1. 修改证书，创始区块配置文件"></a>1. 修改证书，创始区块配置文件</h2><p>先删除原有配置</p><pre><code>rm -rf crypto-configrm -rf channel-artifacts</code></pre><h4 id="crypto-config-yaml"><a href="#crypto-config-yaml" class="headerlink" title="crypto-config.yaml"></a>crypto-config.yaml</h4><pre><code>PeerOrgs:  - Name: Org1    Domain: org1.example.com    EnableNodeOUs: true    Template:      Count: 2    Users:      Count: 1    Specs:      - Hostname: orderer0      - Hostname: orderer1      - Hostname: orderer2  - Name: Org2    Domain: org2.example.com    EnableNodeOUs: true    Template:      Count: 2    Users:      Count: 1    Specs:      - Hostname: orderer0      - Hostname: orderer1</code></pre><h4 id="configtx-yaml"><a href="#configtx-yaml" class="headerlink" title="configtx.yaml"></a>configtx.yaml</h4><pre><code>SampleMultiNodeEtcdRaft:        &lt;&lt;: *ChannelDefaults        Capabilities:            &lt;&lt;: *ChannelCapabilities        Orderer:            &lt;&lt;: *OrdererDefaults            OrdererType: etcdraft            EtcdRaft:                Consenters:                - Host: orderer0.org1.example.com                  Port: 7050                  ClientTLSCert: crypto-config/peerOrganizations/org1.example.com/peers/orderer0.org1.example.com/tls/server.crt                  ServerTLSCert: crypto-config/peerOrganizations/org1.example.com/peers/orderer0.org1.example.com/tls/server.crt                - Host: orderer1.org1.example.com                  Port: 8050                  ClientTLSCert: crypto-config/peerOrganizations/org1.example.com/peers/orderer1.org1.example.com/tls/server.crt                  ServerTLSCert: crypto-config/peerOrganizations/org1.example.com/peers/orderer1.org1.example.com/tls/server.crt                - Host: orderer2.org1.example.com                  Port: 9050                  ClientTLSCert: crypto-config/peerOrganizations/org1.example.com/peers/orderer2.org1.example.com/tls/server.crt                  ServerTLSCert: crypto-config/peerOrganizations/org1.example.com/peers/orderer2.org1.example.com/tls/server.crt                - Host: orderer0.org2.example.com                  Port: 7050                  ClientTLSCert: crypto-config/peerOrganizations/org2.example.com/peers/orderer0.org2.example.com/tls/server.crt                  ServerTLSCert: crypto-config/peerOrganizations/org2.example.com/peers/orderer0.org2.example.com/tls/server.crt                - Host: orderer1.org2.example.com                  Port: 8050                  ClientTLSCert: crypto-config/peerOrganizations/org2.example.com/peers/orderer1.org2.example.com/tls/server.crt                  ServerTLSCert: crypto-config/peerOrganizations/org2.example.com/peers/orderer1.org2.example.com/tls/server.crt            Addresses:                - orderer0.org1.example.com:7050                - orderer1.org1.example.com:8050                - orderer2.org1.example.com:9050                - orderer0.org2.example.com:7050                - orderer1.org2.example.com:8050            Organizations:            - *Org1            - *Org2            Capabilities:                &lt;&lt;: *OrdererCapabilities        Application:            &lt;&lt;: *ApplicationDefaults            Organizations:            - &lt;&lt;: *Org1            - &lt;&lt;: *Org2        Consortiums:            SampleConsortium:                Organizations:                - *Org1                - *Org2</code></pre><p>1、生成公私钥和证书</p><pre><code>../bin/cryptogen generate --config=./crypto-config.yaml </code></pre><p>2、生成创世区块</p><pre><code>../bin/configtxgen -profile SampleMultiNodeEtcdRaft -outputBlock ./channel-artifacts/genesis.block</code></pre><p>3、生成Channel配置区块</p><pre><code>../bin/configtxgen -profile TwoOrgsChannel -outputCreateChannelTx ./channel-artifacts/channel.tx -channelID mychannel </code></pre><p>4、更新锚节点</p><pre><code>../bin/configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org1MSPanchors.tx -channelID mychannel -asOrg Org1MSP../bin/configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/Org2MSPanchors.tx -channelID mychannel -asOrg Org2MSP</code></pre><h2 id="3-修改peer配置"><a href="#3-修改peer配置" class="headerlink" title="3. 修改peer配置"></a>3. 修改peer配置</h2><h4 id="docker-compose-base-yaml"><a href="#docker-compose-base-yaml" class="headerlink" title="docker-compose-base.yaml"></a>docker-compose-base.yaml</h4><pre><code># Copyright IBM Corp. All Rights Reserved.## SPDX-License-Identifier: Apache-2.0#version: &#39;2&#39;services:  orderer.example.com:    container_name: orderer.example.com    extends:      file: peer-base.yaml      service: orderer-base    volumes:        - ../channel-artifacts/genesis.block:/var/hyperledger/orderer/orderer.genesis.block        - ../crypto-config/ordererOrganizations/example.com/orderers/orderer.example.com/msp:/var/hyperledger/orderer/msp        - ../crypto-config/ordererOrganizations/example.com/orderers/orderer.example.com/tls/:/var/hyperledger/orderer/tls    ports:      - 7050:7050  peer0.org1.example.com:    container_name: peer0.org1.example.com    extends:      file: peer-base.yaml      service: peer-base    environment:      - CORE_PEER_ID=peer0.org1.example.com      - CORE_PEER_ADDRESS=peer0.org1.example.com:7051      - CORE_PEER_LISTENADDRESS=0.0.0.0:7051      - CORE_PEER_CHAINCODEADDRESS=peer0.org1.example.com:7052      - CORE_PEER_CHAINCODELISTENADDRESS=0.0.0.0:7052      - CORE_PEER_GOSSIP_BOOTSTRAP=peer1.org1.example.com:8051      - CORE_PEER_GOSSIP_EXTERNALENDPOINT=peer0.org1.example.com:7051      - CORE_PEER_LOCALMSPID=Org1MSP      - CORE_PEER_ENBLKROUTER=true    volumes:        - /var/run/:/host/var/run/        - ../crypto-config/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/msp:/etc/hyperledger/fabric/msp        - ../crypto-config/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls:/etc/hyperledger/fabric/tls        - peer0.org1.example.com:/var/hyperledger/production    ports:      - 7051:7051      - 9099:9099  peer1.org1.example.com:    container_name: peer1.org1.example.com    extends:      file: peer-base.yaml      service: peer-base    environment:      - CORE_PEER_ID=peer1.org1.example.com      - CORE_PEER_ADDRESS=peer1.org1.example.com:8051      - CORE_PEER_LISTENADDRESS=0.0.0.0:8051      - CORE_PEER_CHAINCODEADDRESS=peer1.org1.example.com:8052      - CORE_PEER_CHAINCODELISTENADDRESS=0.0.0.0:8052      - CORE_PEER_GOSSIP_EXTERNALENDPOINT=peer1.org1.example.com:8051      - CORE_PEER_GOSSIP_BOOTSTRAP=peer0.org1.example.com:7051      - CORE_PEER_LOCALMSPID=Org1MSP      - CORE_PEER_ENBLKROUTER=true    volumes:        - /var/run/:/host/var/run/        - ../crypto-config/peerOrganizations/org1.example.com/peers/peer1.org1.example.com/msp:/etc/hyperledger/fabric/msp        - ../crypto-config/peerOrganizations/org1.example.com/peers/peer1.org1.example.com/tls:/etc/hyperledger/fabric/tls        - peer1.org1.example.com:/var/hyperledger/production    ports:      - 8051:8051      - 10099:9099  peer0.org2.example.com:    container_name: peer0.org2.example.com    extends:      file: peer-base.yaml      service: peer-base    environment:      - CORE_PEER_ID=peer0.org2.example.com      - CORE_PEER_ADDRESS=peer0.org2.example.com:9051      - CORE_PEER_LISTENADDRESS=0.0.0.0:9051      - CORE_PEER_CHAINCODEADDRESS=peer0.org2.example.com:9052      - CORE_PEER_CHAINCODELISTENADDRESS=0.0.0.0:9052      - CORE_PEER_GOSSIP_EXTERNALENDPOINT=peer0.org2.example.com:9051      - CORE_PEER_GOSSIP_BOOTSTRAP=peer1.org2.example.com:10051      - CORE_PEER_LOCALMSPID=Org2MSP      - CORE_PEER_ENBLKROUTER=true    volumes:        - /var/run/:/host/var/run/        - ../crypto-config/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/msp:/etc/hyperledger/fabric/msp        - ../crypto-config/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls:/etc/hyperledger/fabric/tls        - peer0.org2.example.com:/var/hyperledger/production    ports:      - 9051:9051      - 9099:9099  peer1.org2.example.com:    container_name: peer1.org2.example.com    extends:      file: peer-base.yaml      service: peer-base    environment:      - CORE_PEER_ID=peer1.org2.example.com      - CORE_PEER_ADDRESS=peer1.org2.example.com:10051      - CORE_PEER_LISTENADDRESS=0.0.0.0:10051      - CORE_PEER_CHAINCODEADDRESS=peer1.org2.example.com:10052      - CORE_PEER_CHAINCODELISTENADDRESS=0.0.0.0:10052      - CORE_PEER_GOSSIP_EXTERNALENDPOINT=peer1.org2.example.com:10051      - CORE_PEER_GOSSIP_BOOTSTRAP=peer0.org2.example.com:9051      - CORE_PEER_LOCALMSPID=Org2MSP      - CORE_PEER_ENBLKROUTER=true    volumes:        - /var/run/:/host/var/run/        - ../crypto-config/peerOrganizations/org2.example.com/peers/peer1.org2.example.com/msp:/etc/hyperledger/fabric/msp        - ../crypto-config/peerOrganizations/org2.example.com/peers/peer1.org2.example.com/tls:/etc/hyperledger/fabric/tls        - peer1.org2.example.com:/var/hyperledger/production    ports:      - 10051:10051      - 10099:9099</code></pre><h2 id="4-修改组织1配置"><a href="#4-修改组织1配置" class="headerlink" title="4. 修改组织1配置"></a>4. 修改组织1配置</h2><h4 id="docker-compose-org1-35-yaml"><a href="#docker-compose-org1-35-yaml" class="headerlink" title="docker-compose-org1-35.yaml"></a>docker-compose-org1-35.yaml</h4><pre><code>version: &#39;2&#39;volumes:  orderer0.org1.example.com:  orderer1.org1.example.com:  orderer2.org1.example.com:  peer0.org1.example.com:  peer1.org1.example.com:networks:  byfn:services:  orderer0.org1.example.com:    environment:      - ORDERER_GENERAL_LOCALMSPID=Org1MSP    extends:      file: base/peer-base.yaml      service: orderer-base    container_name: orderer0.org1.example.com    networks:      - byfn    volumes:      - ./channel-artifacts/genesis.block:/var/hyperledger/orderer/orderer.genesis.block      - ./crypto-config/peerOrganizations/org1.example.com/peers/orderer0.org1.example.com/msp:/var/hyperledger/orderer/msp      - ./crypto-config/peerOrganizations/org1.example.com/peers/orderer0.org1.example.com/tls/:/var/hyperledger/orderer/tls      - orderer0.org1.example.com:/var/hyperledger/production/orderer    ports:      - 7050:7050    extra_hosts:      - orderer0.org1.example.com:192.168.9.35      - orderer1.org1.example.com:192.168.9.35      - orderer2.org1.example.com:192.168.9.35      - orderer0.org2.example.com:192.168.9.28      - orderer1.org2.example.com:192.168.9.28  orderer1.org1.example.com:    environment:      - ORDERER_GENERAL_LOCALMSPID=Org1MSP    extends:      file: base/peer-base.yaml      service: orderer-base    container_name: orderer1.org1.example.com    networks:      - byfn    volumes:      - ./channel-artifacts/genesis.block:/var/hyperledger/orderer/orderer.genesis.block      - ./crypto-config/peerOrganizations/org1.example.com/peers/orderer1.org1.example.com/msp:/var/hyperledger/orderer/msp      - ./crypto-config/peerOrganizations/org1.example.com/peers/orderer1.org1.example.com/tls/:/var/hyperledger/orderer/tls      - orderer1.org1.example.com:/var/hyperledger/production/orderer    ports:      - 8050:7050    extra_hosts:      - orderer0.org1.example.com:192.168.9.35      - orderer1.org1.example.com:192.168.9.35      - orderer2.org1.example.com:192.168.9.35      - orderer0.org2.example.com:192.168.9.28      - orderer1.org2.example.com:192.168.9.28  orderer2.org1.example.com:    environment:      - ORDERER_GENERAL_LOCALMSPID=Org1MSP    extends:      file: base/peer-base.yaml      service: orderer-base    container_name: orderer2.org1.example.com    networks:      - byfn    volumes:      - ./channel-artifacts/genesis.block:/var/hyperledger/orderer/orderer.genesis.block      - ./crypto-config/peerOrganizations/org1.example.com/peers/orderer2.org1.example.com/msp:/var/hyperledger/orderer/msp      - ./crypto-config/peerOrganizations/org1.example.com/peers/orderer2.org1.example.com/tls/:/var/hyperledger/orderer/tls      - orderer2.org1.example.com:/var/hyperledger/production/orderer    ports:      - 9050:7050    extra_hosts:      - orderer0.org1.example.com:192.168.9.35      - orderer1.org1.example.com:192.168.9.35      - orderer2.org1.example.com:192.168.9.35      - orderer0.org2.example.com:192.168.9.28      - orderer1.org2.example.com:192.168.9.28  peer0.org1.example.com:    container_name: peer0.org1.example.com    extends:      file:  base/docker-compose-base.yaml      service: peer0.org1.example.com    networks:      - byfn    extra_hosts:      - orderer0.org1.example.com:192.168.9.35      - orderer1.org1.example.com:192.168.9.35      - orderer2.org1.example.com:192.168.9.35      - orderer0.org2.example.com:192.168.9.28      - orderer1.org2.example.com:192.168.9.28  peer1.org1.example.com:    container_name: peer1.org1.example.com    extends:      file:  base/docker-compose-base.yaml      service: peer1.org1.example.com    networks:      - byfn    extra_hosts:      - orderer0.org1.example.com:192.168.9.35      - orderer1.org1.example.com:192.168.9.35      - orderer2.org1.example.com:192.168.9.35      - orderer0.org2.example.com:192.168.9.28      - orderer1.org2.example.com:192.168.9.28  cli:    container_name: cli    image: 192.168.9.8:80/fabric1.4performance/hyperledger/fabric-tools:sles12sp3-latest    tty: true    stdin_open: true    environment:      - GOPATH=/opt/gopath      - CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock      #- FABRIC_LOGGING_SPEC=DEBUG      - FABRIC_LOGGING_SPEC=INFO      - CORE_PEER_BCCSP_DEFAULT=GM      - CORE_PEER_ID=cli      - CORE_PEER_ADDRESS=peer0.org1.example.com:7051      - CORE_PEER_LOCALMSPID=Org1MSP      - CORE_PEER_TLS_ENABLED=true      - CORE_PEER_TLS_CERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/server.crt      - CORE_PEER_TLS_KEY_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/server.key      - CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt      - CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp    working_dir: /opt/gopath/src/github.com/hyperledger/fabric/peer    command: /bin/bash    volumes:      - /var/run/:/host/var/run/      - ./../chaincode/:/opt/gopath/src/github.com/chaincode      - ./../unionbank/:/opt/gopath/src/unionbank      - ./crypto-config:/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/      - ./scripts:/opt/gopath/src/github.com/hyperledger/fabric/peer/scripts/      - ./channel-artifacts:/opt/gopath/src/github.com/hyperledger/fabric/peer/channel-artifacts    extra_hosts:      - orderer0.org1.example.com:192.168.9.35      - orderer1.org1.example.com:192.168.9.35      - orderer2.org1.example.com:192.168.9.35      - orderer0.org2.example.com:192.168.9.28      - orderer1.org2.example.com:192.168.9.28      - peer0.org1.example.com:192.168.9.35      - peer1.org1.example.com:192.168.9.35      - peer0.org2.example.com:192.168.9.28      - peer1.org2.example.com:192.168.9.28    networks:      - byfn</code></pre><h2 id="5-修改组织2配置"><a href="#5-修改组织2配置" class="headerlink" title="5. 修改组织2配置"></a>5. 修改组织2配置</h2><h4 id="docker-compose-org2-28-yaml"><a href="#docker-compose-org2-28-yaml" class="headerlink" title="docker-compose-org2-28.yaml"></a>docker-compose-org2-28.yaml</h4><pre><code>version: &#39;2&#39;volumes:  orderer0.org2.example.com:  orderer1.org2.example.com:  peer0.org2.example.com:  peer1.org2.example.com:networks:  byfn:services:  orderer0.org2.example.com:    environment:      - ORDERER_GENERAL_LOCALMSPID=Org2MSP    extends:      file: base/peer-base.yaml      service: orderer-base    container_name: orderer0.org2.example.com    networks:      - byfn    volumes:      - ./channel-artifacts/genesis.block:/var/hyperledger/orderer/orderer.genesis.block      - ./crypto-config/peerOrganizations/org2.example.com/peers/orderer0.org2.example.com/msp:/var/hyperledger/orderer/msp      - ./crypto-config/peerOrganizations/org2.example.com/peers/orderer0.org2.example.com/tls/:/var/hyperledger/orderer/tls      - orderer0.org2.example.com:/var/hyperledger/production/orderer    ports:      - 7050:7050    extra_hosts:      - orderer0.org1.example.com:192.168.9.35      - orderer1.org1.example.com:192.168.9.35      - orderer2.org1.example.com:192.168.9.35      - orderer0.org2.example.com:192.168.9.28      - orderer1.org2.example.com:192.168.9.28  orderer1.org2.example.com:    environment:      - ORDERER_GENERAL_LOCALMSPID=Org2MSP    extends:      file: base/peer-base.yaml      service: orderer-base    container_name: orderer1.org2.example.com    networks:      - byfn    volumes:      - ./channel-artifacts/genesis.block:/var/hyperledger/orderer/orderer.genesis.block      - ./crypto-config/peerOrganizations/org2.example.com/peers/orderer1.org2.example.com/msp:/var/hyperledger/orderer/msp      - ./crypto-config/peerOrganizations/org2.example.com/peers/orderer1.org2.example.com/tls/:/var/hyperledger/orderer/tls      - orderer1.org2.example.com:/var/hyperledger/production/orderer    ports:      - 8050:7050    extra_hosts:      - orderer0.org1.example.com:192.168.9.35      - orderer1.org1.example.com:192.168.9.35      - orderer2.org1.example.com:192.168.9.35      - orderer0.org2.example.com:192.168.9.28      - orderer1.org2.example.com:192.168.9.28  peer0.org2.example.com:    container_name: peer0.org2.example.com    extends:      file:  base/docker-compose-base.yaml      service: peer0.org2.example.com    networks:      - byfn    extra_hosts:      - orderer0.org1.example.com:192.168.9.35      - orderer1.org1.example.com:192.168.9.35      - orderer2.org1.example.com:192.168.9.35      - orderer0.org2.example.com:192.168.9.28      - orderer1.org2.example.com:192.168.9.28  peer1.org2.example.com:    container_name: peer1.org2.example.com    extends:      file:  base/docker-compose-base.yaml      service: peer1.org2.example.com    networks:      - byfn    extra_hosts:      - orderer0.org1.example.com:192.168.9.35      - orderer1.org1.example.com:192.168.9.35      - orderer2.org1.example.com:192.168.9.35      - orderer0.org2.example.com:192.168.9.28      - orderer1.org2.example.com:192.168.9.28</code></pre><p>以上步骤完成后，将项目拷贝到其他的主机上</p><h2 id="6-启动fabric网络"><a href="#6-启动fabric网络" class="headerlink" title="6. 启动fabric网络"></a>6. 启动fabric网络</h2><p>启动主机1</p><pre><code>docker-compose -f docker-compose-org1-35.yaml up -d</code></pre><p>启动主机2</p><pre><code>docker-compose -f docker-compose-org2-28.yaml up -d</code></pre><p>启动脚本</p><pre><code>#!/bin/bashexport CHANNEL_NAME=mychannelexport ORDERER_CA=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/orderer0.org1.example.com/msp/tlscacerts/tlsca.org1.example.com-cert.pem## Create channelpeer channel create -o orderer0.org1.example.com:7050 -c $CHANNEL_NAME -f ./channel-artifacts/channel.tx --tls $CORE_PEER_TLS_ENABLED --cafile $ORDERER_CA## Join all the peers to the channelpeer channel join -b $CHANNEL_NAME.block## Set the anchor peers for each org in the channelpeer channel update -o orderer0.org1.example.com:7050 -c $CHANNEL_NAME -f ./channel-artifacts/Org1MSPanchors.tx --tls $CORE_PEER_TLS_ENABLED --cafile $ORDERER_CA## Install chaincode on peer0.org1peer chaincode install -n mycc -v 1.0 -p github.com/chaincode/chaincode_example02peer chaincode install -n public -v 1.0 -p unionbank/chaincode/publicpeer chaincode install -n forfeiting -v 1.0 -p unionbank/chaincode/forfeitingsleep 5## pee1.org1export CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/mspexport CORE_PEER_ADDRESS=peer1.org1.example.com:8051export CORE_PEER_LOCALMSPID=&quot;Org1MSP&quot;export CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer1.org1.example.com/tls/ca.crtpeer channel join -b $CHANNEL_NAME.blockpeer chaincode install -n mycc -v 1.0 -p github.com/chaincode/chaincode_example02peer chaincode install -n public -v 1.0 -p unionbank/chaincode/publicpeer chaincode install -n forfeiting -v 1.0 -p unionbank/chaincode/forfeitingsleep 5## peer0.org2export CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/mspexport CORE_PEER_ADDRESS=peer0.org2.example.com:9051export CORE_PEER_LOCALMSPID=&quot;Org2MSP&quot;export CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crtpeer channel join -b $CHANNEL_NAME.blockpeer channel update -o orderer0.org1.example.com:7050 -c $CHANNEL_NAME -f ./channel-artifacts/Org2MSPanchors.tx --tls $CORE_PEER_TLS_ENABLED --cafile $ORDERER_CApeer chaincode install -n mycc -v 1.0 -p github.com/chaincode/chaincode_example02peer chaincode install -n public -v 1.0 -p unionbank/chaincode/publicpeer chaincode install -n forfeiting -v 1.0 -p unionbank/chaincode/forfeitingsleep 5## peer1.org2export CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/mspexport CORE_PEER_ADDRESS=peer1.org2.example.com:10051export CORE_PEER_LOCALMSPID=&quot;Org2MSP&quot;export CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer1.org2.example.com/tls/ca.crtpeer channel join -b $CHANNEL_NAME.blockpeer chaincode install -n mycc -v 1.0 -p github.com/chaincode/chaincode_example02peer chaincode install -n public -v 1.0 -p unionbank/chaincode/publicpeer chaincode install -n forfeiting -v 1.0 -p unionbank/chaincode/forfeitingsleep 5# Instantiate chaincode on peer0.org1echo &quot;Instantiating chaincode on peer0.org1...&quot;export CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/mspexport CORE_PEER_ADDRESS=peer0.org1.example.com:7051export CORE_PEER_LOCALMSPID=&quot;Org1MSP&quot;export CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crtsleep 5peer chaincode instantiate -o orderer0.org1.example.com:7050 --tls $CORE_PEER_TLS_ENABLED --cafile $ORDERER_CA -C $CHANNEL_NAME -n mycc -v 1.0 -c &#39;{&quot;Args&quot;:[&quot;init&quot;,&quot;a&quot;, &quot;100&quot;, &quot;b&quot;,&quot;200&quot;]}&#39;sleep 5peer chaincode instantiate -o orderer0.org1.example.com:7050 --tls $CORE_PEER_TLS_ENABLED --cafile $ORDERER_CA -C $CHANNEL_NAME -n public -v 1.0 -c &#39;{&quot;Args&quot;:[]}&#39;sleep 5peer chaincode instantiate -o orderer0.org1.example.com:7050 --tls $CORE_PEER_TLS_ENABLED --cafile $ORDERER_CA -C $CHANNEL_NAME -n forfeiting -v 1.0 -c &#39;{&quot;Args&quot;:[]}&#39;sleep 5# Query chaincode on peer0.org1peer chaincode query -C $CHANNEL_NAME -n mycc -c &#39;{&quot;Args&quot;:[&quot;query&quot;,&quot;a&quot;]}&#39;# Invoke chaincode on peer0.org1peer chaincode invoke -o orderer0.org1.example.com:7050 --tls $CORE_PEER_TLS_ENABLED --cafile $ORDERER_CA -C $CHANNEL_NAME -n mycc  -c &#39;{&quot;Args&quot;:[&quot;invoke&quot;,&quot;a&quot;,&quot;b&quot;,&quot;10&quot;]}&#39;sleep 5# Query chaincode on peer0.org1peer chaincode query -C $CHANNEL_NAME -n mycc -c &#39;{&quot;Args&quot;:[&quot;query&quot;,&quot;a&quot;]}&#39;</code></pre><p>注意清除原有不需要的容器和镜像，否则可能会用老的镜像，就比如某些链码的镜像</p><pre><code>docker rm -f $(docker ps -a|grep  dev|awk &#39;{print $1}&#39;)docker rmi -f $(docker images|grep  dev|awk &#39;{print $1}&#39;)docker volume rm -f $(docker volume ls -q)</code></pre><pre><code>version: &#39;2&#39;volumes:  orderer0.example.com:  orderer1.example.com:  orderer2.example.com:  peer0.org1.example.com:  peer1.org1.example.com:  peer0.org2.example.com:  peer1.org2.example.com:networks:  byfn:services:  orderer0.example.com:    environment:      - ORDERER_GENERAL_LOCALMSPID=OrdererMSP    extends:      file: base/peer-base.yaml      service: orderer-base    container_name: orderer0.example.com    networks:      - byfn    volumes:      - ./channel-artifacts/genesis.block:/var/hyperledger/orderer/orderer.genesis.block      - ./crypto-config/ordererOrganizations/example.com/orderers/orderer0.example.com/msp:/var/hyperledger/orderer/msp      - ./crypto-config/ordererOrganizations/example.com/orderers/orderer0.example.com/tls/:/var/hyperledger/orderer/tls      - orderer0.example.com:/var/hyperledger/production/orderer    ports:      - 7050:7050    extra_hosts:      - orderer0.example.com:192.168.9.108      - orderer1.example.com:192.168.9.17      - orderer2.example.com:192.168.9.117      - peer0.org1.example.com:192.168.9.105      - peer1.org1.example.com:192.168.9.13      - peer0.org2.example.com:192.168.9.55      - peer1.org2.example.com:192.168.9.88  orderer1.example.com:    environment:      - ORDERER_GENERAL_LOCALMSPID=OrdererMSP    extends:      file: base/peer-base.yaml      service: orderer-base    container_name: orderer1.example.com    networks:      - byfn    volumes:      - ./channel-artifacts/genesis.block:/var/hyperledger/orderer/orderer.genesis.block      - ./crypto-config/ordererOrganizations/example.com/orderers/orderer1.example.com/msp:/var/hyperledger/orderer/msp      - ./crypto-config/ordererOrganizations/example.com/orderers/orderer1.example.com/tls/:/var/hyperledger/orderer/tls      - orderer1.example.com:/var/hyperledger/production/orderer    ports:      - 8050:7050    extra_hosts:      - orderer0.example.com:192.168.9.108      - orderer1.example.com:192.168.9.17      - orderer2.example.com:192.168.9.117      - peer0.org1.example.com:192.168.9.105      - peer1.org1.example.com:192.168.9.13      - peer0.org2.example.com:192.168.9.55      - peer1.org2.example.com:192.168.9.88  orderer2.example.com:    environment:      - ORDERER_GENERAL_LOCALMSPID=OrdererMSP    extends:      file: base/peer-base.yaml      service: orderer-base    container_name: orderer2.example.com    networks:      - byfn    volumes:      - ./channel-artifacts/genesis.block:/var/hyperledger/orderer/orderer.genesis.block      - ./crypto-config/ordererOrganizations/example.com/orderers/orderer2.example.com/msp:/var/hyperledger/orderer/msp      - ./crypto-config/ordererOrganizations/example.com/orderers/orderer2.example.com/tls/:/var/hyperledger/orderer/tls      - orderer2.example.com:/var/hyperledger/production/orderer    ports:      - 9050:7050    extra_hosts:      - orderer0.example.com:192.168.9.108      - orderer1.example.com:192.168.9.17      - orderer2.example.com:192.168.9.117      - peer0.org1.example.com:192.168.9.105      - peer1.org1.example.com:192.168.9.13      - peer0.org2.example.com:192.168.9.55      - peer1.org2.example.com:192.168.9.88  peer0.org1.example.com:    container_name: peer0.org1.example.com    extends:      file:  base/docker-compose-base.yaml      service: peer0.org1.example.com    networks:      - byfn    extra_hosts:      - orderer0.example.com:192.168.9.108      - orderer1.example.com:192.168.9.17      - orderer2.example.com:192.168.9.117      - peer0.org1.example.com:192.168.9.105      - peer1.org1.example.com:192.168.9.13      - peer0.org2.example.com:192.168.9.55      - peer1.org2.example.com:192.168.9.88  peer1.org1.example.com:    container_name: peer1.org1.example.com    extends:      file:  base/docker-compose-base.yaml      service: peer1.org1.example.com    networks:      - byfn    extra_hosts:      - orderer0.example.com:192.168.9.108      - orderer1.example.com:192.168.9.17      - orderer2.example.com:192.168.9.117      - peer0.org1.example.com:192.168.9.105      - peer1.org1.example.com:192.168.9.13      - peer0.org2.example.com:192.168.9.55      - peer1.org2.example.com:192.168.9.88peer0.org2.example.com:    container_name: peer0.org2.example.com    extends:      file:  base/docker-compose-base.yaml      service: peer0.org2.example.com    networks:      - byfn    extra_hosts:      - orderer0.example.com:192.168.9.108      - orderer1.example.com:192.168.9.17      - orderer2.example.com:192.168.9.117      - peer0.org1.example.com:192.168.9.105      - peer1.org1.example.com:192.168.9.13      - peer0.org2.example.com:192.168.9.55      - peer1.org2.example.com:192.168.9.88peer1.org2.example.com:    container_name: peer1.org2.example.com    extends:      file:  base/docker-compose-base.yaml      service: peer1.org2.example.com    networks:      - byfn    extra_hosts:      - orderer0.example.com:192.168.9.108      - orderer1.example.com:192.168.9.17      - orderer2.example.com:192.168.9.117      - peer0.org1.example.com:192.168.9.105      - peer1.org1.example.com:192.168.9.13      - peer0.org2.example.com:192.168.9.55      - peer1.org2.example.com:192.168.9.88  cli:    container_name: cli    image: 192.168.9.8:80/fabric1.4performance/hyperledger/fabric-tools:sles12sp3-latest    tty: true    stdin_open: true    environment:      - GOPATH=/opt/gopath      - CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock      #- FABRIC_LOGGING_SPEC=DEBUG      - FABRIC_LOGGING_SPEC=INFO      #- CORE_PEER_BCCSP_DEFAULT=GM      - CORE_PEER_BCCSP_DEFAULT=SW      - CORE_PEER_ID=cli      - CORE_PEER_ADDRESS=peer0.org1.example.com:7051      - CORE_PEER_LOCALMSPID=Org1MSP      - CORE_PEER_TLS_ENABLED=true      - CORE_PEER_TLS_CERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/server.crt      - CORE_PEER_TLS_KEY_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/server.key      - CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt      - CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp    working_dir: /opt/gopath/src/github.com/hyperledger/fabric/peer    command: /bin/bash    volumes:      - /var/run/:/host/var/run/      - ./../chaincode/:/opt/gopath/src/github.com/chaincode      - ./../unionbank/:/opt/gopath/src/unionbank      - ./crypto-config:/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/      - ./scripts:/opt/gopath/src/github.com/hyperledger/fabric/peer/scripts/      - ./channel-artifacts:/opt/gopath/src/github.com/hyperledger/fabric/peer/channel-artifacts    extra_hosts:      - orderer0.example.com:192.168.9.108      - orderer1.example.com:192.168.9.17      - orderer2.example.com:192.168.9.117      - peer0.org1.example.com:192.168.9.105      - peer1.org1.example.com:192.168.9.13      - peer0.org2.example.com:192.168.9.55      - peer1.org2.example.com:192.168.9.88    networks:      - byfn</code></pre>]]></content>
      
      
      <categories>
          
          <category> fabric </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fabric部署 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
