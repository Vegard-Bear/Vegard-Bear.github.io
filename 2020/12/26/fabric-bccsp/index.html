<!DOCTYPE HTML>
<html lang="zh-CN">


<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    <meta name="keywords" content="Fabric 1.4源码分析:BCCSP模块, 小熊的作坊">
    <meta name="baidu-site-verification" content="fmlEuI34ir">
    <meta name="google-site-verification" content="yCy2azpds5XSuGZvis6OuA-XIGF5GuGpYRAaGfD6o48">
    <meta name="360-site-verification" content="b7c11a830ef90fd1464ad6206bb7b6e7">
    <meta name="description" content="模块简介
注: 本文所涉及的代码均基于fabric 1.4.6的版本，其他版本可能会略有不同，但大体相似

BCCSP ( Blockchain Cryptographic Service Provider)为 Fabric 其他模块(如 ">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Fabric 1.4源码分析:BCCSP模块 | 小熊的作坊</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/font-awesome.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">
    <style type="text/css">
        
    </style>

    <script src="/libs/jquery/jquery-2.2.0.min.js"></script>
    <script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script>
    <script>
        var _hmt = _hmt || [];
        (function () {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?46e79e71af0709a5b9106bf20cecc493";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    </script>

    
        <script>
            (function(){
                var bp = document.createElement('script');
                var curProtocol = window.location.protocol.split(':')[0];
                if (curProtocol === 'https') {
                    bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
                }
                else {
                    bp.src = 'http://push.zhanzhang.baidu.com/push.js';
                }
                var s = document.getElementsByTagName("script")[0];
                s.parentNode.insertBefore(bp, s);
            })();
        </script>
    

    <script>
        (function(){
        var src = "https://jspassport.ssl.qhimg.com/11.0.1.js?d182b3f28525f2db83acfaaf6e696dba";
        document.write('<script src="' + src + '" id="sozz"><\/script>');
        })();
    </script>

<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>

<body>

    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">小熊的作坊</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fa fa-navicon"></i></a>
<ul class="right">
    
    <li class="hide-on-med-and-down">
        <a href="/" class="waves-effect waves-light">
            
            <i class="fa fa-home"></i>
            
            <span>首页</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/tags" class="waves-effect waves-light">
            
            <i class="fa fa-tags"></i>
            
            <span>标签</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/categories" class="waves-effect waves-light">
            
            <i class="fa fa-bookmark"></i>
            
            <span>分类</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/archives" class="waves-effect waves-light">
            
            <i class="fa fa-archive"></i>
            
            <span>归档</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/about" class="waves-effect waves-light">
            
            <i class="fa fa-user-circle-o"></i>
            
            <span>关于</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/friends" class="waves-effect waves-light">
            
            <i class="fa fa-address-book"></i>
            
            <span>友情链接</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/contact" class="waves-effect waves-light">
            
            <i class="fa fa-comments"></i>
            
            <span>留言板</span>
        </a>
    </li>
    
    <li>
        <a href="#searchModal" class="modal-trigger waves-effect waves-light">
            <i id="searchIcon" class="fa fa-search" title="搜索"></i>
        </a>
    </li>
</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">小熊的作坊</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li>
            <a href="/" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-home"></i>
                
                首页
            </a>
        </li>
        
        <li>
            <a href="/tags" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-tags"></i>
                
                标签
            </a>
        </li>
        
        <li>
            <a href="/categories" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-bookmark"></i>
                
                分类
            </a>
        </li>
        
        <li>
            <a href="/archives" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-archive"></i>
                
                归档
            </a>
        </li>
        
        <li>
            <a href="/about" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-user-circle-o"></i>
                
                关于
            </a>
        </li>
        
        <li>
            <a href="/friends" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-address-book"></i>
                
                友情链接
            </a>
        </li>
        
        <li>
            <a href="/contact" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-comments"></i>
                
                留言板
            </a>
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/Vegard-Bear" class="waves-effect waves-light" target="_blank">
                <i class="fa fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>

        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/Vegard-Bear" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    
<script src="/libs/cryptojs/crypto-js.min.js"></script>
<script>
    (function() {
        let pwd = '';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('请输入访问本文章的密码')).toString(CryptoJS.enc.Hex)) {
                alert('密码错误，将返回主页！');
                location.href = '/';
            }
        }
    })();
</script>




<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/4.jpg')">
    <div class="container">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <div class="description center-align post-title">
                        Fabric 1.4源码分析:BCCSP模块
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>



<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 20px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                        <a href="/tags/fabric/" target="_blank">
                            <span class="chip bg-color">fabric</span>
                        </a>
                        
                        <a href="/tags/bccsp/" target="_blank">
                            <span class="chip bg-color">bccsp</span>
                        </a>
                        
                        <a href="/tags/密码/" target="_blank">
                            <span class="chip bg-color">密码</span>
                        </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fa fa-bookmark fa-fw icon-category"></i>
                        
                        <a href="/categories/fabric/" class="post-category" target="_blank">
                            fabric
                        </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                <div class="post-date info-break-policy">
                    <i class="fa fa-calendar-minus-o fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2020-12-26
                </div>

                <div class="post-author info-break-policy">
                    <i class="fa fa-user-o fa-fw"></i>作者:&nbsp;&nbsp;
                    
                    小熊
                    
                </div>

                
                
                <div class="info-break-policy">
                    <i class="fa fa-file-word-o fa-fw"></i>文章字数:&nbsp;&nbsp;
                    7.7k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="fa fa-clock-o fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    34 分
                </div>
                
                

                
                <div id="busuanzi_container_page_pv" class="info-break-policy">
                    <i class="fa fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                    <span id="busuanzi_value_page_pv"></span>
                </div>
                
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="模块简介"><a href="#模块简介" class="headerlink" title="模块简介"></a>模块简介</h1><blockquote>
<p>注: 本文所涉及的代码均基于fabric 1.4.6的版本，其他版本可能会略有不同，但大体相似</p>
</blockquote>
<p>BCCSP ( Blockchain Cryptographic Service Provider)为 Fabric 其他模块(如 MSP 组件 等)提供密码服务套件，包括<font color="red">加密、解密、签名与验证、哈希函数</font>等方法。目前，原生fabric的BCCSP模块提供了 PKCS11类型和SW类型两种基本实现。</p>
<p>其中：</p>
<ul>
<li>PKCS11 (Public-Key Cryptography Standards)类型是基于 HSM ( Hardware Security Modules)硬件安全模块(https:// github.com/miekg/pkcsll )的加密服务实现,属于通用的接口标准，利 用pkcsll库提供的上下文对象pkcsl l.Ctx在SessionHandle基础上支持密码服务</li>
<li>SW类型是基于软件的加密服务实现的，直接使用crypto库下的包支持密码服务。同时，BCCSP 模块可提供对应的两类工厂对象，其他模块则基于这两类工厂对象调用对应的密码服务接口。</li>
</ul>
<p>本着一切从源码的角度出发，我们先来看看在fabric中的BCCSP模块的代码目录。</p>
<pre><code>$ tree ./bccsp -L 1
./bccsp
├── factory             初始化BCCSP对象及其工厂对象
├── gm                  实现软件加密(国密)的BCCSP、key和keystore接口
├── idemix              身份混淆器(和零知识证明有关)
├── mocks               用于mock测试
├── pkcs11              实现硬件加密的BCCSP、key和keystore接口
├── signer              基于bccsp实现crypto.Signer
├── sw                  实现软件加密(标准加密)的BCCSP、key和keystore接口
└── utils               一些独立封装的辅助函数
├── bccsp.go            定义BCCSP、key接口
├── keystore.go         定义keystore接口
├── idemixerrs.go       定义了idemix的err
├── ecdsaopts.go        
├── aesopts.go
├── gmopts.go
├── hashopts.go         实现各自的opts接口
├── idemixopts.go
├── opts.go
└── rsaopts.go</code></pre><p>这样过了一遍bccsp的代码目录之后，相信大家会对BCCSP模块有一些印象，但是还是没法获得一个整体的认知。下面，我们从一个更宏观的角度来理解bccsp模块的整体架构。</p>
<h1 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h1><p>我根据自己的理解画了一幅bccsp模块架构图，省略掉了细节，只保留了我认为的关键部分，如有不当之处还望大佬指正。</p>
<p><img src="http://qlkvpxmsx.hd-bkt.clouddn.com/BCCSP%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84.png" alt></p>
<p>如图所示，从上往下，我们依次分析。</p>
<h3 id="上层调用模块"><a href="#上层调用模块" class="headerlink" title="上层调用模块"></a>上层调用模块</h3><p>这一层主要是msp模块，msp模块是Fabric架构重要的系统抽象组件，为客户端、Peer<br>节点、Orderer节点等提供PKI数字证书以管理组织成员身份，从而有效控制资源实体（组<br>织、成员等）的认证、授权、撤销等身份权限操作。</p>
<p>而msp要实现组织和成员的认证、授权和撤销等操作就不可避免地需要用到加密、解密、签名与验证、哈希等方法，而这些方法则由BCCSP模块去完成。</p>
<h3 id="BCCSP模块"><a href="#BCCSP模块" class="headerlink" title="BCCSP模块"></a>BCCSP模块</h3><p>具体的，这些方法被bccsp模块拆分成了四类接口，分别是BCCSP接口、key接口、keystore接口、opts系列接口（一共有7个）。</p>
<p>其中：</p>
<ul>
<li>BCCSP接口定义了加密、解密、签名、验签和哈希等10个方法。</li>
<li>key接口定义了密钥管理等5个方法。</li>
<li>keystore接口定义了密钥存储等3个方法。</li>
<li>opts接口定义了主要用来返回参数密钥名称和是否需要持久化密钥（大部分没有给出实现）。</li>
</ul>
<p>关于这些接口下文会详细介绍，这里先简单了解一下即可。</p>
<p>为了实现这四套接口，目前有多种实现，主要包括fabric原生的pkcs11硬件加密插件和sw软件加密插件，以及我们自己实现的gm国密插件，其中sw和gm都属于软实现。</p>
<blockquote>
<p>扩展阅读：密码学通常有软实现和硬实现，软实现就是常用的各种加密库，比如Go中crypto包，硬实现是使用加密机提供的一套加密服务。软实现和硬实现的重要区别是，密码算法的安全性强依赖随机数，软实现利用的是OS的伪随机数，而硬实现利用的是加密机生成的随机数，所以硬实现的安全强度要高于软实现。</p>
</blockquote>
<h3 id="底层实现模块"><a href="#底层实现模块" class="headerlink" title="底层实现模块"></a>底层实现模块</h3><p>目前这些加密插件都需要依赖底层加密库实现。</p>
<ul>
<li>对于SW加密插件，目前底层直接依赖于 Go SDK 原生的加密库(主要是crypto包)；</li>
<li>对于pkcs11加密插件，目前主要依赖的是github上开源的第三方库<br><a href="https://github.com/miekg/pkcs11，" target="_blank" rel="noopener">https://github.com/miekg/pkcs11，</a> 该加密库是PKCS11 API的Go实现。它对库进行了严密的包装，但在有意义的地方使用了Go风格，它已经和SoftHSM测试过了。当然，它也可以直接上硬件加密机。</li>
<li>对于GM国密插件, 目前主要是利用开源的第三方国密库，比如同济的 <a href="https://github.com/tjfoc/gmsm/" target="_blank" rel="noopener">gmsm库</a><br>当然，也可以考虑直接用支持国密的加密机实现，只需要做一些接口的适配工作即可。</li>
</ul>
<h1 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a>运行流程</h1><p>刚才我们都是看的都是静态的代码，接下来我们要让代码动起来，了解一下bccsp模块在fabric运行过程中是如何发挥作用的。</p>
<h2 id="编辑bccsp配置项"><a href="#编辑bccsp配置项" class="headerlink" title="编辑bccsp配置项"></a>编辑bccsp配置项</h2><p>首先我们从配置文件出发：</p>
<p>在 sampleconfig 目录下的 core.yaml 文件中的BCCSP模块可以对加密实现和加密库进行选择和配置。</p>
<pre><code>    # BCCSP (Blockchain crypto provider): Select which crypto implementation or
    # library to use
    BCCSP:
        # if setting is GM, chaincode.golang.dynamiclink must be false.
        Default: SW
        # Settings for the SW crypto provider (i.e. when DEFAULT: SW)
        SW:
            # TODO: The default Hash and Security level needs refactoring to be
            # fully configurable. Changing these defaults requires coordination
            # SHA2 is hardcoded in several places, not only BCCSP
            Hash: SHA2
            Security: 256
            Library:
            # Location of Key Store
            FileKeyStore:
                # If &quot;&quot;, defaults to &#39;mspConfigPath&#39;/keystore
                KeyStore:
        # Settings for the PKCS#11 crypto provider (i.e. when DEFAULT: PKCS11)
        PKCS11:
            # Location of the PKCS11 module library
            Library:
            # Token Label
            Label:
            # User PIN
            Pin:
            Hash:
            Security:
            FileKeyStore:
                KeyStore:</code></pre><p>通过PEER_BCCSP_DEFAULT 字段可选择那种哪种加密方式，比如我们这边选择SW，那么下面就需要对SW的各个配置项进行配置</p>
<h2 id="加载BCCSP配置项"><a href="#加载BCCSP配置项" class="headerlink" title="加载BCCSP配置项"></a>加载BCCSP配置项</h2><p>如果我们熟悉fabric节点启动流程的话，就会知道在orderer和peer节点启动的时候会去加载orderer.yaml和peer.yanl配置文件，通过读取里面的配置文件对节点进行初始化。</p>
<h3 id="orderer节点初始化bccsp"><a href="#orderer节点初始化bccsp" class="headerlink" title="orderer节点初始化bccsp"></a>orderer节点初始化bccsp</h3><p>对于orderer节点来说，该节点的启动命令是orderer start，用于启动主程序的main()函数。 该函数会调用server.Main()主函数，初始化相关组件配置，其中就包括初始化msp组件。该函数位于orderer/common/server/main.go文件中。</p>
<pre><code>// main函数是orderer节点启动进程的入口
func Main() {
    ...
    //加载orderer.yaml配置文件
    conf, err := localconfig.Load()
    ...
    //初始化本地MSP组件
    initializeLocalMsp(conf)
    ...
}</code></pre><p>它首先调用 localconfig.Load() 方法加载orderer.yaml配置文件<br>，读取其中的配置项，当然也包括bccsp配置项，读取完成后会返回一个TopLevel的实例conf</p>
<p>然后再由 initializeLocalMsp（conf）函数调用mspmgmt.LoadLocalMsp（）方法, 接受Orderer配置对象conf中的General通用配置输入参数，即MSP配置文件路径LocalMSPDir、BCCSP配置项与MSP名称LocalMSPID,以初始化本地MSP组件。</p>
<pre><code>// LoadLocalMsp loads the local MSP from the specified directory
// 利用MSP配置文件、BCCSP配置项和MSPID初始化本地MSP组件
func LoadLocalMsp(dir string, bccspConfig *factory.FactoryOpts, mspID string) error {
    ..
    conf, err := msp.GetLocalMspConfig(dir, bccspConfig, mspID)
    ...
}</code></pre><blockquote>
<p>这里值得注意的是，bccsp的配置项和orderer的其他配置项不太一样，orderer的其他配置项会调用uconf.completeInitialization()方法设置缺省的默认值，而bccsp的配置项则是在msp.GetLocalMspConfig方法中单独设置默认值的：</p>
</blockquote>
<pre><code>func GetLocalMspConfig(dir string, bccspConfig *factory.FactoryOpts, ID string) (*msp.MSPConfig, error) {
    signcertDir := filepath.Join(dir, signcerts)
    keystoreDir := filepath.Join(dir, keystore)
    // 设置bccsp配置项缺省的默认值
    bccspConfig = SetupBCCSPKeystoreConfig(bccspConfig, keystoreDir)
    // 根据bccsp配置项初始化 bccsp factory
    err := factory.InitFactories(bccspConfig)
    if err != nil {
        return nil, errors.WithMessage(err, &quot;could not initialize BCCSP Factories&quot;)
    }
    ...
}</code></pre><p>如代码中所示，设置完缺省值之后就开始始化 bccsp factory，至此为止，就正式进入了我们的bccsp模块。</p>
<h3 id="peer节点初始化bccsp"><a href="#peer节点初始化bccsp" class="headerlink" title="peer节点初始化bccsp"></a>peer节点初始化bccsp</h3><p>此时我们在来看看peer节点的初始化过程。</p>
<p>Peer节点启动命令为peer node start,其入口主程序的main()主函数(peer/main.go)负 责初始化peer主命令对象，注册子命令与初始化环境配置，解析用户输入的子命令start并启动Peer节点。</p>
<pre><code>func main() {
    ...
    // 
    mainCmd.AddCommand(node.Cmd())
    ...
}</code></pre><p>在启动peer节点时会初始化本地MSP组件。通过Viper组件获取core.yaml文件中MSP组件的</p>
<ul>
<li>配置文件路径 mspMgrConfigDir</li>
<li>BCCSP 配置项 bccspConfig</li>
<li>MSP 名称 ID 即 localMSPID </li>
<li>MSP 组件类型localMSPType（默认为FABRIC类型）</li>
</ul>
<p>提供给common.InitCrypto()函数作为参数进行调用，以获取BCCSP区块链加密服务组件，并用于 初始化本地MSP组件。</p>
<pre><code>func InitCmd(cmd *cobra.Command, args []string) {
    ...
    // 初始化本地MSP组件对象
    var mspMgrConfigDir = config.GetPath(&quot;peer.mspConfigPath&quot;) // 获取MSP配置文件路径
    var mspID = viper.GetString(&quot;peer.localMspId&quot;) // 获取本地MSP名称，比如Org1MSP
    var mspType = viper.GetString(&quot;peer.localMspType&quot;) // 获取本地MSP组件类型，这个没找到直接指定的地方
    if mspType == &quot;&quot; {
        // 应该是走了默认FABRIC路径
        mspType = msp.ProviderTypeToString(msp.FABRIC)
    }
    // 利用上面的BCCSP组件配置信息，初始化MSP组件对象
    err = InitCrypto(mspMgrConfigDir, mspID, mspType)
    ...
}</code></pre><p>其中 peer.mspConfigPath是通过 <strong>CORE_PEER_MSPCONFIGPATH</strong> 进行解析的，它<br>当前msp配置文件路径在byfn环境变量中有指定，比如peer0.org1节点的配置文件路径是</p>
<pre><code>CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp</code></pre><p>然后就是调用这个InitCrypto方法了</p>
<pre><code>// InitCrypto initializes crypto for this peer
// 初始化MSP组件对象
func InitCrypto(mspMgrConfigDir, localMSPID, localMSPType string) error {
    ···
    // 检查MSP配置文件路径是否存在
    fi, err := os.Stat(mspMgrConfigDir)

    // 检查localMSPID是否存在
    if localMSPID == &quot;&quot; {
        return errors.New(&quot;the local MSP must have an ID&quot;)
    }

    // 重新设置了BCCSP密钥存储文件的绝对路径 peer.BCCSP.SW.FileKeyStore.KeyStore
    SetBCCSPKeystorePath()

    //解析配置文件中的BCCSP配置信息并保存到bccspConfig变量
    err = viperutil.EnhancedExactUnmarshalKey(&quot;peer.BCCSP&quot;, &amp;bccspConfig)

    // 基于上述参数初始化本地MSP组件对象
    err = mspmgmt.LoadLocalMspWithType(mspMgrConfigDir, bccspConfig, localMSPID, localMSPType)
    ···
}</code></pre><p>而最后这个 LoadLocalMspWithType 方法其实本质和orderer节点一样，最后也是调用GetLocalMspConfig，只不过多包了一层，判断msp的类型，是FABRIC还是IDEMIX啥的，目前默认是FABRIC</p>
<p>而我们上面将orderer节点的时候将过在GetLocalMspConfig方法中会初始化bccsp factory。至此，peer节点启动时调用bccsp模块的路径到此为止。</p>
<h3 id="节点初始化BCCSP流程图"><a href="#节点初始化BCCSP流程图" class="headerlink" title="节点初始化BCCSP流程图"></a>节点初始化BCCSP流程图</h3><p><img src="http://qlkvpxmsx.hd-bkt.clouddn.com/%E8%8A%82%E7%82%B9%E5%88%9D%E5%A7%8B%E5%8C%96bccsp.png" alt></p>
<h5 id="此外，启动客户端和实例化链码的时候应该也会初始化这个bccsp组件，这里先略了，下次补上～"><a href="#此外，启动客户端和实例化链码的时候应该也会初始化这个bccsp组件，这里先略了，下次补上～" class="headerlink" title="此外，启动客户端和实例化链码的时候应该也会初始化这个bccsp组件，这里先略了，下次补上～"></a>此外，启动客户端和实例化链码的时候应该也会初始化这个bccsp组件，这里先略了，下次补上～</h5><h1 id="接口及其实现（以SW为例）"><a href="#接口及其实现（以SW为例）" class="headerlink" title="接口及其实现（以SW为例）"></a>接口及其实现（以SW为例）</h1><p>上一节通过分析peer和orderer节点的启动流程知道了节点启动时是如何调用bccsp模块的，最终都会调用这个bccsp模块InitFactories初始化一个bccsp对象。那么这里就从这个InitFactories方法说起，介绍一下BCCSP模块内部是怎么玩的。</p>
<p><img src="http://qlkvpxmsx.hd-bkt.clouddn.com/%E5%88%9D%E5%A7%8B%E5%8C%96bccsp.png" alt></p>
<p>如图所示，initFactories会根据传入的config.opts这个字段判断创建SWFactory、GMFactory、PKCS11Factory以及PluginFactory对象，然后调用initBCCSP构造全局默认的BCCSP对象defaultBCCSP，而这个initBCCSP方法实际上是调用了BCCSPFactory接口下的Get方法创建一个BCCSP工厂对象实例的，这里就讲到了我们的第一套接口BCCSPFactory。</p>
<h2 id="BCCSPFactory接口"><a href="#BCCSPFactory接口" class="headerlink" title="BCCSPFactory接口"></a>BCCSPFactory接口</h2><p>BCCSPFactory接口主要用于构造一个BCCSP实例，它包含 Name 和 Get 两个方法。</p>
<pre><code>// BCCSPFactory is used to get instances of the BCCSP interface.
// A Factory has name used to address it.
// 根据 FactoryOpts 构建一个BCCSP实例
type BCCSPFactory interface {

    // Name returns the name of this factory
    Name() string

    // Get returns an instance of BCCSP using opts.
    Get(opts *FactoryOpts) (bccsp.BCCSP, error)
}</code></pre><h3 id="sw实现"><a href="#sw实现" class="headerlink" title="sw实现"></a>sw实现</h3><ul>
<li><h4 id="Name方法"><a href="#Name方法" class="headerlink" title="Name方法"></a>Name方法</h4></li>
</ul>
<pre><code>const (
    SoftwareBasedFactoryName = &quot;SW&quot;
)

func (f *SWFactory) Name() string {
    // 直接返回工厂类型的名字&quot;SW&quot;
    return SoftwareBasedFactoryName
}</code></pre><ul>
<li><h4 id="Get方法"><a href="#Get方法" class="headerlink" title="Get方法"></a>Get方法</h4></li>
</ul>
<pre><code>// 根据FactoryOpts构建一个BCCSP实例
func (f *SWFactory) Get(config *FactoryOpts) (bccsp.BCCSP, error) {
    // 验证参数是否为空
    if config == nil || config.SwOpts == nil {
        return nil, errors.New(&quot;Invalid config. It must not be nil.&quot;)
    }

    swOpts := config.SwOpts

    var ks bccsp.KeyStore
    // 如果Ephemeral字段为true，说明是一个临时密钥
    if swOpts.Ephemeral == true {
        // 实例化一个既不加载也不存储密钥的虚拟密钥对象
        ks = sw.NewDummyKeyStore()
    } else if swOpts.FileKeystore != nil {
        // 如果非临时密钥，而且FileKeystore字段不为空，则实例化一个存储于文件夹中的密钥对象
        fks, err := sw.NewFileBasedKeyStore(nil, swOpts.FileKeystore.KeyStorePath, false)
        if err != nil {
            return nil, errors.Wrapf(err, &quot;Failed to initialize software key store&quot;)
        }
        ks = fks
    } else if swOpts.InmemKeystore != nil {
        // 如果FileKeystore字段为空，实例化一个暂时存储在内存中的密钥对象
        ks = sw.NewInMemoryKeyStore()
    } else {
        // 如果Ephemeral字段为false，但FileKeystore字段也为空，
        // 那么也是默认实例化一个临时虚拟密钥存储类型
        ks = sw.NewDummyKeyStore()
    }
    // 根据传入参数创建一个软实现的标准加密类型bccsp实例对象(sw.csp类型)
    return sw.NewWithParams(swOpts.SecLevel, swOpts.HashFamily, ks)
}</code></pre><p>细心的听众可能已经注意到在Get方法中调用了sw.NewDummyKeyStore方法和sw.New方法，那这两个方法又是如何实现的呢，这就涉及到我们接下来要讲的KeyStore接口和BCCSP接口了。</p>
<h2 id="KeyStore接口"><a href="#KeyStore接口" class="headerlink" title="KeyStore接口"></a>KeyStore接口</h2><p>KeyStore接口主要用于实现对加密密钥实例bccsp.key对象的存储和检索。它具体包含三个方法，ReadOnly、GetKey和StoreKey。</p>
<pre><code>type KeyStore interface {
    // 返回是否是只读类型的key
    ReadOnly() bool

    // 根据传入的ski返回key对象
    GetKey(ski []byte) (k Key, err error)

    // 存储key
    StoreKey(k Key) (err error)
}</code></pre><h3 id="sw实现-1"><a href="#sw实现-1" class="headerlink" title="sw实现"></a>sw实现</h3><ul>
<li><h4 id="ReadOnly方法"><a href="#ReadOnly方法" class="headerlink" title="ReadOnly方法"></a>ReadOnly方法</h4></li>
</ul>
<pre><code>// 返回readOnly字段
func (ks *fileBasedKeyStore) ReadOnly() bool {
    return ks.readOnly
}</code></pre><ul>
<li><h4 id="GetKey方法"><a href="#GetKey方法" class="headerlink" title="GetKey方法"></a>GetKey方法</h4></li>
</ul>
<pre><code>// 根据传入的ski返回key对象
func (ks *fileBasedKeyStore) GetKey(ski []byte) (bccsp.Key, error) {
    // 验证ski不为空
    if len(ski) == 0 {
        return nil, errors.New(&quot;Invalid SKI. Cannot be of zero length.&quot;)
    }

    // 取ski的后缀
    suffix := ks.getSuffix(hex.EncodeToString(ski))
    // 如果后缀是key，则
    switch suffix {
    case &quot;key&quot;:
        // 加载AES对称密钥
        key, err := ks.loadKey(hex.EncodeToString(ski))
        if err != nil {
            return nil, fmt.Errorf(&quot;Failed loading key [%x] [%s]&quot;, ski, err)
        }

        return &amp;aesPrivateKey{key, false}, nil
    case &quot;sk&quot;:
        // 加载私钥
        key, err := ks.loadPrivateKey(hex.EncodeToString(ski))
        if err != nil {
            return nil, fmt.Errorf(&quot;Failed loading secret key [%x] [%s]&quot;, ski, err)
        }

        switch key.(type) {
        case *ecdsa.PrivateKey:
            return &amp;ecdsaPrivateKey{key.(*ecdsa.PrivateKey)}, nil
        case *rsa.PrivateKey:
            return &amp;rsaPrivateKey{key.(*rsa.PrivateKey)}, nil
        default:
            return nil, errors.New(&quot;Secret key type not recognized&quot;)
        }
    case &quot;pk&quot;:
        // 加载公钥
        key, err := ks.loadPublicKey(hex.EncodeToString(ski))
        if err != nil {
            return nil, fmt.Errorf(&quot;Failed loading public key [%x] [%s]&quot;, ski, err)
        }

        switch key.(type) {
        case *ecdsa.PublicKey:
            return &amp;ecdsaPublicKey{key.(*ecdsa.PublicKey)}, nil
        case *rsa.PublicKey:
            return &amp;rsaPublicKey{key.(*rsa.PublicKey)}, nil
        default:
            return nil, errors.New(&quot;Public key type not recognized&quot;)
        }

    // 如果后缀缀都不符合，则直接去keystore的路径下遍历并解析所有密钥文件，搜索其中和传入的ski相匹配的密钥
    default:
        return ks.searchKeystoreForSKI(ski)
    }
}</code></pre><ul>
<li><h3 id="StoreKey方法"><a href="#StoreKey方法" class="headerlink" title="StoreKey方法"></a>StoreKey方法</h3></li>
</ul>
<pre><code>// 将密钥存储在当前keystore中
func (ks *fileBasedKeyStore) StoreKey(k bccsp.Key) (err error) {
    // 只读类型的keystore不能存储密钥
    if ks.readOnly {
        return errors.New(&quot;Read only KeyStore.&quot;)
    }

    // 存储的密钥不能为空
    if k == nil {
        return errors.New(&quot;Invalid key. It must be different from nil.&quot;)
    }
    switch k.(type) {
    // 存储ecdsa私钥
    case *ecdsaPrivateKey:
        kk := k.(*ecdsaPrivateKey)

        err = ks.storePrivateKey(hex.EncodeToString(k.SKI()), kk.privKey)
        if err != nil {
            return fmt.Errorf(&quot;Failed storing ECDSA private key [%s]&quot;, err)
        }
    // 存储ecdsa公钥
    case *ecdsaPublicKey:
        kk := k.(*ecdsaPublicKey)

        err = ks.storePublicKey(hex.EncodeToString(k.SKI()), kk.pubKey)
        if err != nil {
            return fmt.Errorf(&quot;Failed storing ECDSA public key [%s]&quot;, err)
        }
    // 存储rsa私钥
    case *rsaPrivateKey:
        kk := k.(*rsaPrivateKey)

        err = ks.storePrivateKey(hex.EncodeToString(k.SKI()), kk.privKey)
        if err != nil {
            return fmt.Errorf(&quot;Failed storing RSA private key [%s]&quot;, err)
        }
    // 存储rsa公钥
    case *rsaPublicKey:
        kk := k.(*rsaPublicKey)

        err = ks.storePublicKey(hex.EncodeToString(k.SKI()), kk.pubKey)
        if err != nil {
            return fmt.Errorf(&quot;Failed storing RSA public key [%s]&quot;, err)
        }
    // 存储aes对称密钥
    case *aesPrivateKey:
        kk := k.(*aesPrivateKey)

        err = ks.storeKey(hex.EncodeToString(k.SKI()), kk.privKey)
        if err != nil {
            return fmt.Errorf(&quot;Failed storing AES key [%s]&quot;, err)
        }

    default:
        return fmt.Errorf(&quot;Key type not reconigned [%s]&quot;, k)
    }

    return
}</code></pre><blockquote>
<p>存储密钥其实就是将密钥对象通过x509序列化以及pem编码后写入磁盘文件保存，而读取密钥则是其反向操作，即从文件中读出编码后的密钥，然后使用PEM解码和X509反序列化解析出密钥对象。</p>
</blockquote>
<h2 id="BCCSP接口"><a href="#BCCSP接口" class="headerlink" title="BCCSP接口"></a>BCCSP接口</h2><p>BCCSP接口是BCCSP模块中最核心的接口，主要用于实现密钥生成、派生、签名和验签、加密和解密以及哈希等方法。具体如下。</p>
<pre><code>// 主要用于实现密钥生成、派生、签名和验签、加密和解密以及哈希等方法
type BCCSP interface {

    // 根据参数opts的值生成对应类型的密钥
    KeyGen(opts KeyGenOpts) (k Key, err error)

    // 根据密钥k和参数opts，派生出新的密钥
    KeyDeriv(k Key, opts KeyDerivOpts) (dk Key, err error)

    // 根据指定的opts从raw中导出对应类型的密钥实例
    KeyImport(raw interface{}, opts KeyImportOpts) (k Key, err error)

    // 根据指定的ski获取密钥
    GetKey(ski []byte) (k Key, err error)

    // 获取数据的摘要
    Hash(msg []byte, opts HashOpts) (hash []byte, err error)

    // 根据opts指定的类型获得对应的哈希方法
    GetHash(opts HashOpts) (h hash.Hash, err error)

    // 利用非对称密钥k对数据摘要进行签名
    Sign(k Key, digest []byte, opts SignerOpts) (signature []byte, err error)

    // 利用非对称密钥对数据摘要进行验签
    Verify(k Key, signature, digest []byte, opts SignerOpts) (valid bool, err error)

    // 利用密钥对数据进行加密
    Encrypt(k Key, plaintext []byte, opts EncrypterOpts) (ciphertext []byte, err error)

    // 利用密钥对数据进行解密
    Decrypt(k Key, ciphertext []byte, opts DecrypterOpts) (plaintext []byte, err error)
}</code></pre><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><ul>
<li><h4 id="SW-Wrapper"><a href="#SW-Wrapper" class="headerlink" title="SW/Wrapper"></a>SW/Wrapper</h4></li>
</ul>
<p>SW用于实现这个BCCSP接口的实例叫做CSP，定义如下:</p>
<pre><code>type CSP struct {
    ks bccsp.KeyStore

    KeyGenerators map[reflect.Type]KeyGenerator
    KeyDerivers   map[reflect.Type]KeyDeriver
    KeyImporters  map[reflect.Type]KeyImporter
    Encryptors    map[reflect.Type]Encryptor
    Decryptors    map[reflect.Type]Decryptor
    Signers       map[reflect.Type]Signer
    Verifiers     map[reflect.Type]Verifier
    Hashers       map[reflect.Type]Hasher
}</code></pre><p>这个CSP实际上是一个基于wrappers的BCCSP接口的实现。它其实就是做了一个分类，将BCCSP要实现的那些方法分成这几类：<br>KeyGenerator、KeyDeriver、KeyImporter、Encryptor、Decryptor、Signer、Verifier、Hasher。</p>
<p><img src="http://qlkvpxmsx.hd-bkt.clouddn.com/BCCSP%E6%8E%A5%E5%8F%A3.png" alt></p>
<p>然后每一类实际上是一个map，这个map的键是类型，值是一个实例，这样就可以根据传入的参数选择对应的具体算法实现，比如往KeyGenerators这个map传入一个ecdsa类型的参数，那么就会去调用ecdsa的密钥生成方法了，废话不多说了，直接看源码。</p>
<ul>
<li><h4 id="KeyGen方法"><a href="#KeyGen方法" class="headerlink" title="KeyGen方法"></a>KeyGen方法</h4></li>
</ul>
<pre><code>// 根据参数opts的值生成对应类型的密钥
func (csp *CSP) KeyGen(opts bccsp.KeyGenOpts) (k bccsp.Key, err error) {
    // 验证opts不为空
    if opts == nil {
        return nil, errors.New(&quot;Invalid Opts parameter. It must not be nil.&quot;)
    }

    // 根据传入的参数opts获取相应的KeyGenerator实例（aesKeyGenerator,rsaKeyGenerator,ecdsaKeyGenerator）
    keyGenerator, found := csp.KeyGenerators[reflect.TypeOf(opts)]
    if !found {
        return nil, errors.Errorf(&quot;Unsupported &#39;KeyGenOpts&#39; provided [%v]&quot;, opts)
    }

    // 调用密钥生成方法生成密钥
    k, err = keyGenerator.KeyGen(opts)
    if err != nil {
        return nil, errors.Wrapf(err, &quot;Failed generating key with opts [%v]&quot;, opts)
    }

    // 如果密钥的Ephemeral字段为false，则调用StoreKey存储密钥
    if !opts.Ephemeral() {
        err = csp.ks.StoreKey(k)
        if err != nil {
            return nil, errors.Wrapf(err, &quot;Failed storing key [%s]&quot;, opts.Algorithm())
        }
    }

    return k, nil
}</code></pre><ul>
<li><h4 id="KeyDeriv方法"><a href="#KeyDeriv方法" class="headerlink" title="KeyDeriv方法"></a>KeyDeriv方法</h4></li>
</ul>
<pre><code>// 根据密钥k和参数opts，派生出新的密钥，该方法目前只在idemix中会用到
func (csp *CSP) KeyDeriv(k bccsp.Key, opts bccsp.KeyDerivOpts) (dk bccsp.Key, err error) {

    //  验证传入的密钥不为空
    if k == nil {
        return nil, errors.New(&quot;Invalid Key. It must not be nil.&quot;)
    }

    // 验证传入的opts不为空
    if opts == nil {
        return nil, errors.New(&quot;Invalid opts. It must not be nil.&quot;)
    }

    // 根据传入的密钥k获取相应的KeyDeriver实例
    // （ecdsaPublicKeyKeyDeriver,ecdsaPrivateKeyKeyDeriver,aesPrivateKeyKeyDeriver）
    keyDeriver, found := csp.KeyDerivers[reflect.TypeOf(k)]
    if !found {
        return nil, errors.Errorf(&quot;Unsupported &#39;Key&#39; provided [%v]&quot;, k)
    }

    // 调用KeyDerive方法生成密钥（生成一个和传入密钥相同类型的密钥）
    k, err = keyDeriver.KeyDeriv(k, opts)
    if err != nil {
        return nil, errors.Wrapf(err, &quot;Failed deriving key with opts [%v]&quot;, opts)
    }

    // 如果opts的Ephemeral字段为false，则调用StoreKey存储密钥
    if !opts.Ephemeral() {
        err = csp.ks.StoreKey(k)
        if err != nil {
            return nil, errors.Wrapf(err, &quot;Failed storing key [%s]&quot;, opts.Algorithm())
        }
    }

    return k, nil
}</code></pre><ul>
<li><h4 id="KeyImport方法"><a href="#KeyImport方法" class="headerlink" title="KeyImport方法"></a>KeyImport方法</h4></li>
</ul>
<pre><code>// 根据指定的opts从raw中导出对应类型的密钥实例
func (csp *CSP) KeyImport(raw interface{}, opts bccsp.KeyImportOpts) (k bccsp.Key, err error) {

    // 验证raw不为空
    if raw == nil {
        return nil, errors.New(&quot;Invalid raw. It must not be nil.&quot;)
    }

    //验证opts不为空
    if opts == nil {
        return nil, errors.New(&quot;Invalid opts. It must not be nil.&quot;)
    }

    // 根据传入的密钥k获取相应的KeyImporter实例
    // aes256ImportKeyOptsKeyImporter
    // hmacImportKeyOptsKeyImporter
    // ecdsaPKIXPublicKeyImportOptsKeyImporter
    // ecdsaPrivateKeyImportOptsKeyImporter
    // ecdsaGoPublicKeyImportOptsKeyImporter
    // rsaGoPublicKeyImportOptsKeyImporter
    // x509PublicKeyImportOptsKeyImporter
    keyImporter, found := csp.KeyImporters[reflect.TypeOf(opts)]
    if !found {
        return nil, errors.Errorf(&quot;Unsupported &#39;KeyImportOpts&#39; provided [%v]&quot;, opts)
    }

    // 调用KeyImport方法导入密钥
    k, err = keyImporter.KeyImport(raw, opts)
    if err != nil {
        return nil, errors.Wrapf(err, &quot;Failed importing key with opts [%v]&quot;, opts)
    }

    // 如果opts的Ephemeral字段为false，则调用StoreKey存储密钥
    if !opts.Ephemeral() {

        err = csp.ks.StoreKey(k)
        if err != nil {
            return nil, errors.Wrapf(err, &quot;Failed storing imported key with opts [%v]&quot;, opts)
        }
    }

    return
}</code></pre><ul>
<li><h4 id="GetKey方法-1"><a href="#GetKey方法-1" class="headerlink" title="GetKey方法"></a>GetKey方法</h4></li>
</ul>
<pre><code>// 根据指定的ski获取当前BCCSP实例中存储的对应密钥
func (csp *CSP) GetKey(ski []byte) (k bccsp.Key, err error) {
    k, err = csp.ks.GetKey(ski)
    if err != nil {
        return nil, errors.Wrapf(err, &quot;Failed getting key for SKI [%v]&quot;, ski)
    }

    return
}</code></pre><ul>
<li><h4 id="Hash方法"><a href="#Hash方法" class="headerlink" title="Hash方法"></a>Hash方法</h4></li>
</ul>
<pre><code>// 获取数据摘要
func (csp *CSP) Hash(msg []byte, opts bccsp.HashOpts) (digest []byte, err error) {
    // 验证opts参数不为空
    if opts == nil {
        return nil, errors.New(&quot;Invalid opts. It must not be nil.&quot;)
    }

    // 根据传入的参数opts获取相应的Hasher实例
    hasher, found := csp.Hashers[reflect.TypeOf(opts)]
    if !found {
        return nil, errors.Errorf(&quot;Unsupported &#39;HashOpt&#39; provided [%v]&quot;, opts)
    }

    // 调用hash方法生成摘要
    digest, err = hasher.Hash(msg, opts)
    if err != nil {
        return nil, errors.Wrapf(err, &quot;Failed hashing with opts [%v]&quot;, opts)
    }

    returni
}</code></pre><ul>
<li><h4 id="GetHash方法"><a href="#GetHash方法" class="headerlink" title="GetHash方法"></a>GetHash方法</h4></li>
</ul>
<pre><code>// 根据opts指定的类型获得对应的哈希方法
func (csp *CSP) GetHash(opts bccsp.HashOpts) (h hash.Hash, err error) {

    // 验证opts参数不为空
    if opts == nil {
        return nil, errors.New(&quot;Invalid opts. It must not be nil.&quot;)
    }

    // 根据传入的参数opts获取相应的Hasher实例
    hasher, found := csp.Hashers[reflect.TypeOf(opts)]
    if !found {
        return nil, errors.Errorf(&quot;Unsupported &#39;HashOpt&#39; provided [%v]&quot;, opts)
    }

    // 返回hash方法
    h, err = hasher.GetHash(opts)
    if err != nil {
        return nil, errors.Wrapf(err, &quot;Failed getting hash function with opts [%v]&quot;, opts)
    }

    return
}</code></pre><ul>
<li><h4 id="Sign方法"><a href="#Sign方法" class="headerlink" title="Sign方法"></a>Sign方法</h4></li>
</ul>
<pre><code>// 利用非对称密钥k对数据摘要进行签名
func (csp *CSP) Sign(k bccsp.Key, digest []byte, opts bccsp.SignerOpts) (signature []byte, err error) {

    // 验证私钥不为空
    if k == nil {
        return nil, errors.New(&quot;Invalid Key. It must not be nil.&quot;)
    }

    // 验证摘要内容不为空
    if len(digest) == 0 {
        return nil, errors.New(&quot;Invalid digest. Cannot be empty.&quot;)
    }

    // 根据传入的密钥k获取相应的signer实例
    keyType := reflect.TypeOf(k)
    signer, found := csp.Signers[keyType]
    if !found {
        return nil, errors.Errorf(&quot;Unsupported &#39;SignKey&#39; provided [%s]&quot;, keyType)
    }

    // 调用signer签名方法进行签名，值得注意的是，这个opts在ecdsa中没有用到
    // ecdsaSigner, rsaSigner
    signature, err = signer.Sign(k, digest, opts)
    if err != nil {
        return nil, errors.Wrapf(err, &quot;Failed signing with opts [%v]&quot;, opts)
    }

    return
}</code></pre><ul>
<li><h4 id="Verify"><a href="#Verify" class="headerlink" title="Verify"></a>Verify</h4></li>
</ul>
<pre><code>// 利用非对称密钥对数据摘要进行验签
func (csp *CSP) Verify(k bccsp.Key, signature, digest []byte, opts bccsp.SignerOpts) (valid bool, err error) {

    // 验证传入公钥不为空
    if k == nil {
        return false, errors.New(&quot;Invalid Key. It must not be nil.&quot;)
    }

    // 验证签名不为空
    if len(signature) == 0 {
        return false, errors.New(&quot;Invalid signature. Cannot be empty.&quot;)
    }

    // 验证摘要不为空
    if len(digest) == 0 {
        return false, errors.New(&quot;Invalid digest. Cannot be empty.&quot;)
    }

    // 根据传入的密钥k获取相应的Verifier实例
    // ecdsa、rsa 值得注意的是，如果这里传入的是私钥，则会根据私钥导出公钥再作验证
    verifier, found := csp.Verifiers[reflect.TypeOf(k)]
    if !found {
        return false, errors.Errorf(&quot;Unsupported &#39;VerifyKey&#39; provided [%v]&quot;, k)
    }

    // 调用verify方法进行验签
    valid, err = verifier.Verify(k, signature, digest, opts)
    if err != nil {
        return false, errors.Wrapf(err, &quot;Failed verifing with opts [%v]&quot;, opts)
    }

    return
}</code></pre><ul>
<li><h4 id="Encrypt"><a href="#Encrypt" class="headerlink" title="Encrypt"></a>Encrypt</h4></li>
</ul>
<pre><code>// 利用密钥对数据进行加密
func (csp *CSP) Encrypt(k bccsp.Key, plaintext []byte, opts bccsp.EncrypterOpts) ([]byte, error) {

    // 验证加密密钥不为空
    if k == nil {
        return nil, errors.New(&quot;Invalid Key. It must not be nil.&quot;)
    }
    // 根据传入的密钥k获取相应的Encryptor实例，目前只支持aes
    encryptor, found := csp.Encryptors[reflect.TypeOf(k)]
    if !found {
        return nil, errors.Errorf(&quot;Unsupported &#39;EncryptKey&#39; provided [%v]&quot;, k)
    }

    // 调用Encrypt方法进行加密
    return encryptor.Encrypt(k, plaintext, opts)
}</code></pre><ul>
<li><h4 id="Decrypt"><a href="#Decrypt" class="headerlink" title="Decrypt"></a>Decrypt</h4></li>
</ul>
<pre><code>// 利用密钥对数据进行加密
func (csp *CSP) Encrypt(k bccsp.Key, plaintext []byte, opts bccsp.EncrypterOpts) ([]byte, error) {

    // 验证加密密钥不为空
    if k == nil {
        return nil, errors.New(&quot;Invalid Key. It must not be nil.&quot;)
    }
    // 根据传入的密钥k获取相应的Encryptor实例，目前只支持aes
    encryptor, found := csp.Encryptors[reflect.TypeOf(k)]
    if !found {
        return nil, errors.Errorf(&quot;Unsupported &#39;EncryptKey&#39; provided [%v]&quot;, k)
    }

    // 调用Encrypt方法进行加密
    return encryptor.Encrypt(k, plaintext, opts)
}</code></pre><h2 id="Key接口"><a href="#Key接口" class="headerlink" title="Key接口"></a>Key接口</h2><p>KeyStore接口主要用于实现对密钥管理，它具体包含如下方法：</p>
<pre><code>// key接口主要用于密钥管理
type Key interface {

    // 将密钥key转成bytes格式
    Bytes() ([]byte, error)

    // 返回密钥的key的ski
    SKI() []byte

    // 是否是对称加密密钥
    Symmetric() bool

    // 是否是私钥
    Private() bool

    // 返回该密钥的公钥
    PublicKey() (Key, error)
}</code></pre><h3 id="sw实现-2"><a href="#sw实现-2" class="headerlink" title="sw实现"></a>sw实现</h3><ul>
<li><h4 id="Bytes方法"><a href="#Bytes方法" class="headerlink" title="Bytes方法"></a>Bytes方法</h4></li>
</ul>
<pre><code>// 将ecdsa的公钥转成bytes形式
func (k *ecdsaPublicKey) Bytes() (raw []byte, err error) {
    // 调用go sdk的x509包中的方法
    raw, err = x509.MarshalPKIXPublicKey(k.pubKey)
    if err != nil {
        return nil, fmt.Errorf(&quot;Failed marshalling key [%s]&quot;, err)
    }
    return
}</code></pre><p>值得注意的是，对于rsa和ecdsa的私钥是不支持转成Bytes操作的，如果直接调用这个方法，会返回err</p>
<ul>
<li><h4 id="SKI方法"><a href="#SKI方法" class="headerlink" title="SKI方法"></a>SKI方法</h4></li>
</ul>
<pre><code>// 返回ecdsa公钥的ski
func (k *ecdsaPublicKey) SKI() []byte {
    // 检查密钥是否为空
    if k.pubKey == nil {
        return nil
    }

    // 序列化公钥，调用go sdk的elliptic包的Marshal方法序（将一个点转化成未压缩形式）
    raw := elliptic.Marshal(k.pubKey.Curve, k.pubKey.X, k.pubKey.Y)

    // 将结果用sha256做哈希
    hash := sha256.New()
    hash.Write(raw)
    return hash.Sum(nil)
}</code></pre><ul>
<li><h4 id="Symmetric方法"><a href="#Symmetric方法" class="headerlink" title="Symmetric方法"></a>Symmetric方法</h4></li>
</ul>
<pre><code>// 返回是否是对称密钥
func (k *aesPrivateKey) Symmetric() bool {
    return true
}</code></pre><p>只有aes返回true，rsa和ecdsa均返回false</p>
<ul>
<li><h4 id="Private方法"><a href="#Private方法" class="headerlink" title="Private方法"></a>Private方法</h4></li>
</ul>
<pre><code>// 返回是否是私钥
func (k *ecdsaPrivateKey) Private() bool {
    return true
}</code></pre><h2 id="opts系列接口"><a href="#opts系列接口" class="headerlink" title="opts系列接口"></a>opts系列接口</h2><p>KeyStore接口主要用于实现对密钥管理，它具体包含如下方法：</p>
<pre><code>// 主要用来提供生成密钥的参数
type KeyGenOpts interface {
    Algorithm() string
    Ephemeral() bool
}

// 主要用来从一个Key实例派生出另一个Key实例
type KeyDerivOpts interface {
    Algorithm() string
    Ephemeral() bool
}

// 主要用来在密钥导入时生成参数
type KeyImportOpts interface {
    Algorithm() string
    Ephemeral() bool
}

// 为hash方法提供参数选择
type HashOpts interface {
    Algorithm() string
}

// 为签名方法提供参数选择
type SignerOpts interface {
    crypto.SignerOpts
}

// 无方法，可以根据需要定义加密参数
type EncrypterOpts interface{}

// 无方法，可以根据需要定义加密参数
type DecrypterOpts interface{}</code></pre><h3 id="sw实现-3"><a href="#sw实现-3" class="headerlink" title="sw实现"></a>sw实现</h3><ul>
<li><h4 id="Algorithm方法"><a href="#Algorithm方法" class="headerlink" title="Algorithm方法"></a>Algorithm方法</h4></li>
</ul>
<pre><code>func (opts *ECDSAKeyGenOpts) Algorithm() string {
    return ECDSA
}</code></pre><ul>
<li><h4 id="Ephemeral方法"><a href="#Ephemeral方法" class="headerlink" title="Ephemeral方法"></a>Ephemeral方法</h4></li>
</ul>
<pre><code>func (opts *ECDSAKeyGenOpts) Ephemeral() bool {
    return opts.Temporary
}</code></pre><ul>
<li><h4 id="HashOpts方法"><a href="#HashOpts方法" class="headerlink" title="HashOpts方法"></a>HashOpts方法</h4></li>
</ul>
<pre><code>func (opts *ECDSAKeyGenOpts) Ephemeral() bool {
    return opts.Temporary
}</code></pre><h2 id="接口调用关系图"><a href="#接口调用关系图" class="headerlink" title="接口调用关系图"></a>接口调用关系图</h2><h1 id="GM插件"><a href="#GM插件" class="headerlink" title="GM插件"></a>GM插件</h1><p>至于国密GM插件的实现其实与SW插件类似，基本也是仿照SW插件改造出来的，只不过中间封装了一层sm2、sm3和sm4接口:</p>
<pre><code>type Sm2 interface {
    // 创建私钥
    GenerateKey() (*crypto.PrivateKey, error)

    // 数字签名和验证
    Sign(priv *crypto.PrivateKey, rand io.Reader, digest []byte, opts gocrypto.SignerOpts) ([]byte, error)
    Verify(pub *crypto.PublicKey, digest []byte, sign []byte) bool

    // 非对称加密和解密
    Encrypt(pub *crypto.PublicKey, msg []byte) ([]byte, error)
    Decrypt(priv *crypto.PrivateKey, ciphertext []byte) ([]byte, error)

    // 公钥和私钥的保存与加载
    SavePrivateKeytoPem(fileName string, key *crypto.PrivateKey, pwd []byte) (bool, error)
    LoadPrivateKeyFromPem(fileName string, pwd []byte) (*crypto.PrivateKey, error)
    SavePublicKeytoPem(fileName string, key *crypto.PublicKey, _ []byte) (bool, error)
    LoadPublicKeyFromPem(fileName string, pwd []byte) (*crypto.PublicKey, error)
}

type Sm3 interface {
    // 创建符合Hash接口的sm3实例
    New() hash.Hash
    // 使用sm3计算数据的摘要
    Sum(data []byte) []byte
}

type Sm4 interface {
    // 创建符合Block接口的sm4实例
    NewCipher(key []byte) (cipher.Block, error)

    // 使用对称密钥加密和解密
    Encrypt(key []byte, dst, src []byte)
    Decrypt(key []byte, dst, src []byte)

    // 密钥保存和加载
    SaveKeyToPem(fileName string, key []byte, pwd []byte) (bool, error)
    LoadKeyFromPem(fileName string, pwd []byte) ([]byte, error)
}</code></pre><p>通过将国密算法需要实现的BCCSP模块中的接口整理了一下，归纳成sm2、sm3、sm4这三套接口，这样就使得国密插件的具体实现与BCCSP模块进行了解耦。理论上我们只需要实现这三套接口，就可以实现一个新的国密插件。之所以这样设计，是因为目前底层国密的加密库目前有多个选择，这样就使得国密插件的实现更灵活，可以更方便的引入和适配新的底层国密库。</p>
<p>具体国密插件的实现可参考 <a href="https://blog.csdn.net/weixin_39066447/article/details/111468172" target="_blank" rel="noopener">fabric国密改造</a></p>
<h1 id="pkcs11插件"><a href="#pkcs11插件" class="headerlink" title="pkcs11插件"></a>pkcs11插件</h1><p>1.4版本的pkcs11实现有较多的TODO以及FIXME，并不完善</p>
<p>通过对比pkcs11的factoryOpts和SW的factoryOpts，我们发现</p>
<pre><code>type FactoryOpts struct {
    // 
    ProviderName string      `mapstructure:&quot;default&quot; json:&quot;default&quot; yaml:&quot;Default&quot;`
    SwOpts       *SwOpts     `mapstructure:&quot;SW,omitempty&quot; json:&quot;SW,omitempty&quot; yaml:&quot;SwOpts&quot;`
    PluginOpts   *PluginOpts `mapstructure:&quot;PLUGIN,omitempty&quot; json:&quot;PLUGIN,omitempty&quot; yaml:&quot;PluginOpts&quot;`
}</code></pre><pre><code>type FactoryOpts struct {
    ProviderName string             `mapstructure:&quot;default&quot; json:&quot;default&quot; yaml:&quot;Default&quot;`
    SwOpts       *SwOpts            `mapstructure:&quot;SW,omitempty&quot; json:&quot;SW,omitempty&quot; yaml:&quot;SwOpts&quot;`
    PluginOpts   *PluginOpts        `mapstructure:&quot;PLUGIN,omitempty&quot; json:&quot;PLUGIN,omitempty&quot; yaml:&quot;PluginOpts&quot;`
    Pkcs11Opts   *pkcs11.PKCS11Opts `mapstructure:&quot;PKCS11,omitempty&quot; json:&quot;PKCS11,omitempty&quot; yaml:&quot;PKCS11&quot;`
}</code></pre><p>可以发现pkcs11的FactoryOpts主要是多了Pkcs11Opts这个字段，而在这个字段中定义了library、label、pin这几个值，如果大家还有印象的话应该记得在加载配置文件core.yaml的时候pkcs11那里其实是有这些字段的。</p>
<pre><code>PKCS11:
    # Location of the PKCS11 module library
    Library: /usr/lib/softhsm/libsofthsm2.so 
    #/etc/hyperledger/fabric/libsofthsm2.so
    # Token Label
    Label: ForFabric
    # User PIN
    Pin: &quot;98765432&quot;
    Hash: SHA2
    Security: 256</code></pre><p>而查看和pkcs11的bccsp实例，我们会发现</p>
<pre><code>type impl struct {
    // sw的bccsp实例
    bccsp.BCCSP

    conf *config
    ks   bccsp.KeyStore

    ctx      *pkcs11.Ctx
    sessions chan pkcs11.SessionHandle
    slot     uint

    lib        string
    softVerify bool
    //Immutable flag makes object immutable
    immutable bool
}</code></pre><p>实际上pkcs11的实例中是包含了一个sw的bccsp实例的，这一点在new一个BCCSP实例的时候也得到了验证</p>
<pre><code>func New(opts PKCS11Opts, keyStore bccsp.KeyStore) (bccsp.BCCSP, error) {
    ...
    // 调用了sw的NewWithParams方法new了一个sw的bccsp实例
    swCSP, err := sw.NewWithParams(opts.SecLevel, opts.HashFamily, keyStore)
    if err != nil {
        return nil, errors.Wrapf(err, &quot;Failed initializing fallback SW BCCSP&quot;)
    }

    lib := opts.Library
    pin := opts.Pin
    label := opts.Label
    ...
    sessions := make(chan pkcs11.SessionHandle, sessionCacheSize)
    // 最后返回的bccsp实例包含了一个sw的bccsp的实例
    csp := &amp;impl{swCSP, conf, keyStore, ctx, sessions, slot, lib, opts.SoftVerify, opts.Immutable}
    return csp, nil
}</code></pre><p>而pkcs11插件在实现bccsp接口的时候也多次调用了内部包含sw bccsp对应的方法。</p>
<p>就比如bccsp接口中的KeyGen方法</p>
<pre><code>func (csp *impl) KeyGen(opts bccsp.KeyGenOpts) (k bccsp.Key, err error) {

    switch opts.(type) {
    case *bccsp.ECDSAKeyGenOpts:
        ski, pub, err := csp.generateECKey(csp.conf.ellipticCurve, opts.Ephemeral())
        ···
    case *bccsp.ECDSAP256KeyGenOpts:
        ski, pub, err := csp.generateECKey(oidNamedCurveP256, opts.Ephemeral())
        ···
    case *bccsp.ECDSAP384KeyGenOpts:
        ski, pub, err := csp.generateECKey(oidNamedCurveP384, opts.Ephemeral())
        ···
    default:
        return csp.BCCSP.KeyGen(opts)
    }

    return k, nil
}</code></pre><p>我们可以发现它都是先走自己单独的生成密钥的那套方法，走不通时再去调SW的KeyGen方法。而进一步分析发现，其实pkcs11自己的那套密钥生成方法也是一层接口封装，底层其实用的是开源的一套pkcs11标准实现加密库 <a href="https://github.com/miekg/pkcs11" target="_blank" rel="noopener">https://github.com/miekg/pkcs11</a> ，这个库是pkcs11的Go语言实现，它实现了pkcs11标准规定的那些接口，而且已经通过和SoftHSM的测试，当然底层也可以用硬件加密机实现。</p>
<p><img src="http://qlkvpxmsx.hd-bkt.clouddn.com/pkcs11%E7%9A%84BCCSP%E5%AE%9E%E7%8E%B0.png" alt></p>
<p>值得注意的是，pkcs11由于是采用硬件加密，因此它的密钥是保存在硬件加密模块中的，所以它并没有实现keystore密钥存储接口，同时，它也不会通过软件实现密钥生成、密钥派生以及密钥导入等场景，所以也就不支持opts系列接口，这一点和SW以及GM都不太一样。</p>
<h1 id="idemix插件"><a href="#idemix插件" class="headerlink" title="idemix插件"></a>idemix插件</h1><p>和零知识证明有关</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="http://qlkvpxmsx.hd-bkt.clouddn.com/BCCSP%E6%A8%A1%E5%9D%97%E6%80%BB%E7%BB%93.png" alt></p>

            </div>
            <hr />

            
            <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.88rem;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-large waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fa fa-close"></i></a>
            <h4 class="reward-title">写作不易，客官能否打赏一杯奶茶？</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>
            

            <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">

<div id="article-share">
    
    <div class="social-share" data-disabled="qzone" data-wechat-qrcode-helper="<p>微信里点“发现”->“扫一扫”二维码便可查看分享。</p>"></div>
    
</div>

<script src="/libs/share/js/social-share.min.js"></script>

            

    <div class="reprint" id="reprint-statement">
        <p class="reprint-tip">
            <i class="fa fa-exclamation-triangle"></i>&nbsp;&nbsp;
            <span>转载规则</span>
        </p>
        
            <div class="center-align">
                <a rel="license" href="https://creativecommons.org/licenses/by/4.0/deed.zh">
                    <img alt=""
                         style="border-width:0"
                         src="https://i.creativecommons.org/l/by/4.0/88x31.png"/>
                </a>
            </div>
            <br/>
            <span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/Text"
                  property="dct:title" rel="dct:type">
                    《Fabric 1.4源码分析:BCCSP模块》
                </span> 由
            <a xmlns:cc="http://creativecommons.org/ns#" href="/2020/12/26/fabric-bccsp/" property="cc:attributionName"
               rel="cc:attributionURL">
                小熊
            </a> 采用
            <a rel="license" href="https://creativecommons.org/licenses/by/4.0/deed.zh">
                知识共享署名 4.0 国际许可协议
            </a>进行许可。
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>


        </div>
    </div>

    
    <link rel="stylesheet" href="/libs/gitalk/gitalk.css">
<link rel="stylesheet" href="/css/my-gitalk.css">

<div class="card gitalk-card" data-aos="fade-up">
    <div id="gitalk-container" class="card-content"></div>
</div>

<script src="/libs/gitalk/gitalk.min.js"></script>
<script>
    let gitalk = new Gitalk({
        clientID: '7ab38c55a2aee92f3c3d',
        clientSecret: '0f38c4206bf229166d19576b0463da96ae1b9b54',
        repo: 'Vegard-Bear.github.io',
        owner: 'Vegard',
        admin: "Vegard",
        id: '2020/12/26/fabric-bccsp/',
        distractionFreeMode: false  // Facebook-like distraction free mode
    });

    gitalk.render('gitalk-container');
</script>
    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fa fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2020/12/27/leetcode-76/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/13.jpg" class="responsive-img" alt="【leetcode-76】最小覆盖子串">
                        
                        <span class="card-title">【leetcode-76】最小覆盖子串</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            滑动窗口最重要的是处理好细节问题，比如说如何向窗口中添加新元素，如何缩小窗口，在窗口滑动的哪个阶段更新结果。
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="fa fa-clock-o fa-fw icon-date"></i>2020-12-27
                        </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/leetcode/" class="post-category" target="_blank">
                                    leetcode
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/leetcode/" target="_blank">
                        <span class="chip bg-color">leetcode</span>
                    </a>
                    
                    <a href="/tags/滑动窗口/" target="_blank">
                        <span class="chip bg-color">滑动窗口</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fa fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2020/12/25/go-feature-lock/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/18.jpg" class="responsive-img" alt="【Go特性5】锁和条件变量">
                        
                        <span class="card-title">【Go特性5】锁和条件变量</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            锁是某个协程（线程）在访问某个资源时先锁住，防止其它协程的访问，等访问完毕解锁后其他协程再来加锁进行访问。
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="fa fa-clock-o fa-fw icon-date"></i>2020-12-25
                            </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/go/" class="post-category" target="_blank">
                                    go
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/go/" target="_blank">
                        <span class="chip bg-color">go</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>
</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('120')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'PRE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: 小熊的作坊<br />'
            + '作者: 小熊<br />'
            + '链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () { bodyElement.removeChild(newdiv); }, 200);
    });
</script>

    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="fa fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fa fa-list"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            // headingsOffset: -205,
            headingSelector: 'h1, h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h1, h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).slideUp(500);
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).slideDown(500);
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>
    

</main>


<script src="https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
    MathJax.Hub.Config({
        tex2jax: {inlineMath: [['$', '$'], ['\(', '\)']]}
    });
</script>

<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>
<!-- 代码语言 -->
<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>
<!-- 代码块复制 -->
<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>
<script type="text/javascript" src="/libs/codeBlock/clipboard.min.js"></script>
<!-- 代码块收缩 -->
<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script> 
<!-- 代码块折行 -->
<style type="text/css">code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }</style>


    <footer class="page-footer bg-color">
    <div class="container row center-align">
        <div class="col s12 m8 l8 copy-right">
            &copy; 2017-2020 WeiYang. 版权所有

            
            &nbsp;<i class="fa fa-area-chart"></i>&nbsp;站点总字数:&nbsp;
            <span class="white-color">77.6k</span>
            

            <br>
            <span id="sitetime"></span>

            
            
            <br>
            
            <span id="busuanzi_container_site_pv" style='display:none'>
                <i class="fa fa-heart-o"></i>
                本站总访问量 <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
            <span id="busuanzi_container_site_uv" style='display:none'>
                人次,&nbsp;访客数 <span id="busuanzi_value_site_uv" class="white-color"></span> 人.
            </span>
            
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/Vegard-Bear" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fa fa-github"></i>
    </a>



    <a href="mailto:xwg17826804679@163.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fa fa-envelope-open"></i>
    </a>



    <a href="https://zhihu.com/people/Vegard" class="tooltipped" target="_blank" data-tooltip="访问我的知乎" data-position="top" data-delay="50">
        <i class="fa fa-inverse">知</i>
    </a>



    <a href="http://wpa.qq.com/msgrd?v=3&uin=2282475304&site=qq&menu=yes" class="tooltipped" target="_blank" data-tooltip="访问我的知乎" data-position="top" data-delay="50">
        <i class="fa fa-qq"></i>
    </a>



    <a href="https://weibo.com/Vegard-Bear" class="tooltipped" target="_blank" data-tooltip="关注我的微博" data-position="top" data-delay="50">
        <i class="fa fa-weibo"></i>
    </a>



    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fa fa-rss"></i>
    </a>
</div>
    </div>
</footer>

<div class="progress-bar"></div>

<!-- 不蒜子计数初始值纠正 -->
<script>
    $(document).ready(function () {

        var int = setInterval(fixCount, 50);
        var pvcountOffset = 80000;
        var uvcountOffset = 20000;

        function fixCount() {
            if (document.getElementById("busuanzi_container_site_pv").style.display != "none") {
                $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + pvcountOffset);
                clearInterval(int);
            }
            if ($("#busuanzi_container_site_pv").css("display") != "none") {
                $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + uvcountOffset); // 加上初始数据
                clearInterval(int);
            }
        }
    });
</script>

<script language=javascript>
    function siteTime() {
        window.setTimeout("siteTime()", 1000);
        var seconds = 1000;
        var minutes = seconds * 60;
        var hours = minutes * 60;
        var days = hours * 24;
        var years = days * 365;
        var today = new Date();
        var todayYear = today.getFullYear();
        var todayMonth = today.getMonth() + 1;
        var todayDate = today.getDate();
        var todayHour = today.getHours();
        var todayMinute = today.getMinutes();
        var todaySecond = today.getSeconds();
        /* Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)
        year - 作为date对象的年份，为4位年份值
        month - 0-11之间的整数，做为date对象的月份
        day - 1-31之间的整数，做为date对象的天数
        hours - 0(午夜24点)-23之间的整数，做为date对象的小时数
        minutes - 0-59之间的整数，做为date对象的分钟数
        seconds - 0-59之间的整数，做为date对象的秒数
        microseconds - 0-999之间的整数，做为date对象的毫秒数 */
        var t1 = Date.UTC(2020, 06, 21, 00, 00, 00); //北京时间2018-2-13 00:00:00
        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
        var diff = t2 - t1;
        var diffYears = Math.floor(diff / years);
        var diffDays = Math.floor((diff / days) - diffYears * 365);
        var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
        var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) / minutes);
        var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours - diffMinutes * minutes) / seconds);
        document.getElementById("sitetime").innerHTML = "本站已运行 " + diffYears + " 年 " + diffDays + " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
    }/*因为建站时间还没有一年，就将之注释掉了。需要的可以取消*/
    siteTime();
</script>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fa fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/" + "search.xml", 'searchInput', 'searchResult');
});
</script>
    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fa fa-angle-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <script type="text/javascript"> var OriginTitile = document.title, st; document.addEventListener("visibilitychange", function () { document.hidden ? (document.title = "Σ(っ °Д °;)っ喔哟，崩溃啦！", clearTimeout(st)) : (document.title = "φ(゜▽゜*)♪咦，又好了！", st = setTimeout(function () { document.title = OriginTitile }, 3e3)) })
    </script>

    <!-- Global site tag (gtag.js) - Google Analytics -->

<script async src="https://www.googletagmanager.com/gtag/js?id="></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag() {
        dataLayer.push(arguments);
    }

    gtag('js', new Date());
    gtag('config', '');
</script>



    
    <script src="/libs/others/clicklove.js"></script>
    

    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    <!-- 雪花特效 -->
    

</body>

</html>